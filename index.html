<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chuanleiguo.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
<meta property="og:type" content="website">
<meta property="og:title" content="Chuan&#39;s Cabin">
<meta property="og:url" content="http://chuanleiguo.com/index.html">
<meta property="og:site_name" content="Chuan&#39;s Cabin">
<meta property="og:description" content="正因为未知，人与人之间的羁绊才愈发迷人">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chuanlei Guo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chuanleiguo.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chuan's Cabin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chuan's Cabin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code & Live with Love</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-programming-language">

    <a href="/categories/programming-language" rel="section"><i class="fa fa-rocket fa-fw"></i>编程语言</a>

  </li>
        <li class="menu-item menu-item-sourcecode">

    <a href="/categories/sourcecode" rel="section"><i class="fa fa-code fa-fw"></i>源码分析</a>

  </li>
        <li class="menu-item menu-item-computer-science">

    <a href="/categories/computer-science" rel="section"><i class="fa fa-cogs fa-fw"></i>计算机科学</a>

  </li>
        <li class="menu-item menu-item-mooc">

    <a href="/categories/mooc" rel="section"><i class="fa fa-graduation-cap fa-fw"></i>MOOC</a>

  </li>
        <li class="menu-item menu-item-booknotes">

    <a href="/categories/booknotes" rel="section"><i class="fa fa-book fa-fw"></i>读书笔记</a>

  </li>
        <li class="menu-item menu-item-diary">

    <a href="/categories/diary" rel="section"><i class="fa fa-keyboard fa-fw"></i>日志</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2020/07/12/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/12/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">容器网络原理分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-12 11:13:34" itemprop="dateCreated datePublished" datetime="2020-07-12T11:13:34+08:00">2020-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/07/12/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/07/12/容器网络原理分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>容器，是一种沙盒技术。它本质上是宿主机上的一个普通的进程，但是使用了 <code>Namespace</code> 实现了资源隔离，使用 <code>Cgroups</code> 实现了对进程可用资源的限制。这样，进程之间因为有了边界和限制而能够避免相互干扰，并且能利用容器镜像，能够实现容器的“搬运”。在网络上，容器使用 <code>Network Namespace</code> 实现对网络资源的隔离，被隔离的进程只能看到当前 Namespace 里的网络栈和配置。</p>
<p>所谓“网络栈”，包括了：网卡（Network Interface）、回环设备（Loopback Device）、路由表（Routing Table）和 iptables 规则。对于进程来说，这些组件构成了它发出和响应网络请求的基础环境。虽然可以容器可以在启动的时候通过传入 <code>-net=host</code> 方式直接使用宿主机的网络栈，即不开启 Network Namespace，这样虽然可以提供良好的性能，但是却要需要提前规划好每个容器监听的端口号，否则存在端口冲突的风险。所以，大多数时候，我们希望容器尽可能使用自己的 Network Namespace 中的网络栈，拥有自己的 IP 地址和端口号。</p>
<p>这样做自然就使我们面临一个问题：被隔离的进程，如何与另外一个 Network Namespace 中的进程通信呢？</p>
<h2 id="同主机容器间通信"><a href="#同主机容器间通信" class="headerlink" title="同主机容器间通信"></a>同主机容器间通信</h2><p>为了理解不同容器的通信问题，我们可以想象，对于多台宿主机，使它们通信的最直接的方法就是使用网线或交换机将它们连接。在 Linux 中，网桥（Bridge）能够实现虚拟交换机的作用。网桥工作在数据链路层（Data Link），可以根据 MAC 地址学习并将数据包发送到网桥不同的端口上。在 Docker 项目中，会默认在宿主机上创建一个名为 docker0 的网桥，同宿主机上的容器可以通过连接到网桥而实现通信。</p>
<p>而将容器连接到网桥的方式，是使用一种名叫 <strong>Veth Pair</strong> 的虚拟设备。Veth Pair 的特点是，它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现。并且，从其中一张“网卡”发出的数据包会直接出现在与之对应的另一张“网卡”上，即使它们在不同的 Network Namespace 中。因为有这样的特点，Veth Pair 通常被当做虚拟的“网线”，用于连接不同的 Network Namespace。</p>
<p>这样，同一个宿主机上的不同容器通过 docker0 网桥通信的流程就可以用下图表示：</p>
<img src="/2020/07/12/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/same-host-diff-con.png" class="">

<p>我们进入 <code>Container1</code> 容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it Container sh</span><br></pre></td></tr></table></figure>

<p>查看它的网络设备：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在容器中</span></span><br><span class="line">root:/ ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:acff:fe11:2  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 364  bytes 8137175 (7.7 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 281  bytes 21161 (20.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        </span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">        </span><br><span class="line">$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>

<p>可以看到，这个容器里有一张 <code>eth0</code> 网卡，它正是一个 Veth Pair 设备在容器里这一段。通过 <code>route</code> 命令查看 Container1 容器的路由表，可以看到这个 eth0 网卡是这个容器的默认路由设备：所有对 172.17.0.0/16 网段的请求，都会交给 eth0 来处理。而这个 Veth Pair 的另一端则在宿主机上，可以通过查看宿主机的网络设备看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 在宿主机上</span></span><br><span class="line">$ ifconfig</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:d8:e4:df:c1  </span><br><span class="line">          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:d8ff:fee4:dfc1/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:309 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:372 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:18944 (18.9 KB)  TX bytes:8137789 (8.1 MB)</span><br><span class="line">veth9c02e56 Link encap:Ethernet  HWaddr 52:81:0b:24:3d:da  </span><br><span class="line">          inet6 addr: fe80::5081:bff:fe24:3dda/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:288 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:371 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:21608 (21.6 KB)  TX bytes:8137719 (8.1 MB)</span><br><span class="line">          </span><br><span class="line">$ brctl show</span><br><span class="line">bridge name bridge id  STP enabled interfaces</span><br><span class="line">docker0  8000.0242d8e4dfc1 no  veth9c02e56</span><br></pre></td></tr></table></figure>

<p>可以看到 Container1 对应的 Veth Pair 设备，在宿主机上是一张虚拟网卡，它的名字是 <code>veth9c02e56</code>。而且通过 <code>brctl</code> 的输出，可以看到该网卡被插在 docker0 上。同样的， Container2 容器对应的 Veth Pair 的另一端也以相同的方式插在 docker0 网桥上。这是如果在 Container1 容器里 ping 一下 Container2 的 IP（172.17.0.3），就可以发现同一宿主机上的两个容器默认相互连通。</p>
<p>这样同宿主机上两个容器的通信过程为：当在 Container1 中访问 Container2 的 IP 地址是，172.17.0.3 这个目的地址会匹配到 Container1 容器中的第二条路由规则，该规则的网管是 0.0.0.0，意味着是一条直连规则，即：凡是匹配到这条规则的 IP 包，都应该经过 eth0 网卡，通过二层网络直接发往目的主机。</p>
<p>而要通过二层网络抵达 Container2 容器，就需要 172.17.0.3 这个 IP 对应的 MAC 地址。那么，Container1 的网络协议栈，就需要通过 eth0 网卡发送一个 ARP（Address Resolution Protocol） 广播，通过 IP 地址查到对应的 MAC 地址。这个 eth0 网卡是一个 Veth Pair，它的一端在该容器的 Network Namespace 里，而另一端位于宿主机上，并被插在宿主机的 docker0 网桥上，成功为了网桥的“从设备”。这时，网卡降级为网桥的一个端口，它唯一的作用就是接受流入的数据包，交给网桥。</p>
<p>在收到 ARP 请求后，docker0 就扮演二层交换机的角色，把 ARP 广播到其他被插在 docker0 上的虚拟网卡上。这样同样连接在 docker0 上的 Container2 容器的网络协议栈就会收到这个 ARP 请求，并返回对应的 MAC 地址给 Container1。有了这个目的 MAC 地址，Container1 容器的 eth0 网卡就可以将数据包发出去。该数据包会立刻直接流入 docker0 网桥，网桥继续扮演二层交换机的角色，根据数据包的目的 MAC 地址，在它的 CAM 表中查到对应的端口，并发送数据包。这样，数据包就通过 Container2 的 Veth Pair 进入了新的容器。所以 Container2 容器看到的情况是自己的 eth0 网卡出现了流入的数据包，这样 Container2 就会对请求进行处理，并返回响应。</p>
<p>所以，被限制在 Network Namespace 中的容器进程，实际上是通过 Veth Pair 设备 + 宿主机网桥的方式，实现了与其他容器的数据交换。当用户在宿主机上访问容器的 IP 地址时，请求也是先到达 docker0 网桥，然后被转发到对应的 Veth Pair 设备，最后出现在容器里。</p>
<p>同样的，当容器驶入连接到另外一个宿主机是，如 <code>ping 10.168.0.3</code>，它的请求先经过 docker0 出现在宿主机上，然后根据宿主机的路由表的直连规则将请求交给宿主机的 eth0 处理。接下来，这个数据包经宿主机的网络到达 10.168.0.3 对应的宿主机上，当然，这要求两台宿主机是连通的。</p>
<h2 id="跨主机容器间通信"><a href="#跨主机容器间通信" class="headerlink" title="跨主机容器间通信"></a>跨主机容器间通信</h2><p>在了解了同一宿主机下不同容器的通信方式后，我们自然要思考，不同宿主机的容器要如何通信呢？这就是“跨主机通信问题”。</p>
<p>在 Docker 的默认配置下，一台宿主机的 docker0 网桥和其他宿主机上的 docker0 网桥是没有关联的，它们之间也没有办法连通。所以不同宿主机的容器之间自然也就无法通信了。</p>
<p>不过，我们能够通过软件方式，创建一个整个集群公用的网桥，然后将集群中所有的容器都连接到这个网桥上。这种在已有的宿主机网络上，通过软件构建一个覆盖的、可以把所有容器连通在一起的虚拟网络，被称为 <code>Overlay Network</code>（覆盖网络）。其结构如下图：</p>
<img src="/2020/07/12/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/diff-host-diff-con-bridge.png" class="">

<p>这个 Overlay Network 本身，可以由每台宿主机上的一个特殊网桥共同组成。比如，当 Node1 上的 Container1 要访问 Node2 上 Container2 时，Node1 上的特殊网桥在收到数据包后，可以将数据包发送到正确的宿主机；而 Node2 上的特殊网桥在收到数据包后，也能通过某种方式将数据包转发给正确的容器。甚至，每台宿主机上，都不需要有这样一个特殊的网桥，而仅仅通过某种方式，将数据包转发给正确的容器。甚至，不需要特殊网桥，仅仅通过配置路由表就能转发到正确的宿主机上。</p>
<p>目前，社区中存在多种为解决“跨主机通信”问题而出现的容器网络方案。为了理解其原理，我们从 Flannel 这个项目说起。Flannel 项目是 CoreOS 主推的容器网络方案。该项目本身只是一个框架，真正为我们提供容器网络功能的，是 Flannel 的后端实现。Flannel 支持三种后端实现，分别是：</p>
<ol>
<li>UDP</li>
<li>VXLAN</li>
<li>host-gw</li>
</ol>
<h3 id="Flannel-的-UDP-实现"><a href="#Flannel-的-UDP-实现" class="headerlink" title="Flannel 的 UDP 实现"></a>Flannel 的 UDP 实现</h3><p>假设现在有两台宿主机：</p>
<ul>
<li>宿主机 Node1 上有一个容器 Container1，它的 IP 地址是 100.96.1.2，网桥地址是 100.96.1.1/24；</li>
<li>宿主机 Node2 上有一个容器 Container2，它的 IP 地址是 100.96.2.3，网桥地址是 100.96.2.1/24;</li>
</ul>
<p>现在我们希望 Container1 能够访问 Container2。</p>
<p>这时，Container1 容器里的进程发起的 IP 包，其源地址是 100.96.1.2，目的地址是 100.96.2.3。由于目的地址 100.96.2.3 并不在 Node1 的 docker0 网桥的网段，所以这个 IP 包会被交给默认路由规则，通过容器的网关进入 docker0 网桥从而出现宿主机上。这时候，这个 IP 包的下一个目的地，就取决于宿主机上的路由规则。此时，Flannel 已提前在宿主机创建了一系列的路由规则，在 Node1 上，规则如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Node1 上</span></span><br><span class="line">$ ip route</span><br><span class="line">default via 10.168.0.1 dev eth0</span><br><span class="line">100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.1.0</span><br><span class="line">100.96.1.0/24 dev docker0  proto kernel  scope link  src 100.96.1.1</span><br><span class="line">10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.2</span><br></pre></td></tr></table></figure>

<p>由于 IP 包的目的地址是 100.96.2.3，它匹配不到本机 docker0 网桥对应的 100.96.1.0/24，只能匹配到第二条 100.96.0.0/16 对应的这条路由规则，从而进入到一个叫做 flannel0 的设备中。而这个 flannel0 是一个 TUN 设备（Tunnel 设备）。TUN 设备是一种工作在三层（Network Layer）的虚拟设备。它的功能就是在操作系统内核和用户程序之间传递 IP 包。</p>
<p>对于 flannel0，当操作系统将一个 IP 包发送给 flannel0 设备之后，flannel0 就会把这个 IP 包交给创建这个设备的应用程序，即 Flannel 进程。这个过程中， IP 包从内核态流向了用户态。反之，如果 Flannel 进程想 flannel0 设备发送一个 IP 包，那么这个 IP 包就会出现在宿主机网络栈中，然后根据路由表进行下一步处理。这时， IP 包由用户态流向内核态。</p>
<p>这样，当 IP 包从容器经过 docker0 出现在宿主机，然后又根据路由表进入 flannel0 设备后，宿主机上的 flanneld 进程，就会收到这个 IP 包。根据这个 IP 包的目的地址，将它发送给 Node2 宿主机。那么，flanneld 是如何知道该 IP 地址对应的容器在 Node2 上面呢？</p>
<p>Flannel 项目中子网（Subnet）的概念非常重要。由 Flannel 管理的容器网络中，一台宿主机上面的所有容器，都属于该宿主机被分配的一个 “子网”。在上面的例子汇总， Node1 的子网是 100.96.1.0/24，Container1 的 IP 地址是 100.96.1.2。Node2 的子网是 100.96.2.0/24，Container2 的 IP 地址是 100.96.2.3。而这些子网与宿主机的对应关系都保存在 Etcd 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl ls /coreos.com/network/subnets</span><br><span class="line">/coreos.com/network/subnets/100.96.1.0-24</span><br><span class="line">/coreos.com/network/subnets/100.96.2.0-24</span><br><span class="line">/coreos.com/network/subnets/100.96.3.0-24</span><br></pre></td></tr></table></figure>

<p>当 flanneld 进程在处理由 flannel0 传入的 IP 包时，就可以根据目的 IP 的地址，匹配到对应的子网，从 Etcd 中找到这个子网对应的宿主机的 IP 地址是 10.169.0.3：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl get /coreos.com/network/subnets/100.96.2.0-24</span><br><span class="line">&#123;<span class="string">"PublicIP"</span>:<span class="string">"10.168.0.3"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>而对于 flanneld 来说，只要 Node1 和 Node2 是互通的，那么 flanneld 作为 Node1 上的一个普通进程，就一定可以通过上述 IP 地址访问到 Node2。所以，flanneld 在收到 Container1 发送给 Container2 的 IP 包后，就会把这个 IP 包直接封装在一个 UDP 包中，然后发送给 Node2。UDP 包的源地址是 Node1 的地址，目的地址是 Node2 的地址。这样通过一个 UDP 通信，一个 UDP 包就由 Node1 到达了 Node2。Node2 上的 flanneld 就会从 UDP 包中解析出封装在里面的 Container1 发出的原 IP 包。接下来，就如同虚机上的容器网络，IP 包经 docker0 网桥通过 Veth Pair 设备进入到 Container2 的 Network Namespace 中。需要主机的是，上述流程还有一个重要的前提就是 docker0 网桥的地址范围必须是 Flannel 为宿主机分配的子网。以上就是 Flannel UDP 模式的跨主机通信的原理，可以用下图来表示：</p>
<img src="/2020/07/12/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/flannel-udp.png" class="">

<p>可以看到，Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就像 Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p>
<p>目前，Flannel UDP 方式已经被废弃了，因为它存在严重的性能问题。相比于两台宿主机之间的直接通信，基于 Flannel UDP 模式的容器通信多了一个额外的步骤，即 flanneld 的处理过程。而这个过程，由于使用了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中就需要经过三次用户态与内核态之间的数据拷贝：</p>
<img src="/2020/07/12/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/tun.png" class="">

<ol>
<li>用户态的容器进程发出的 IP 包经过 docker0 网桥进入内核态；</li>
<li>IP 包根据路由表进入 TUN（flannel0）设备，从而回到用户态的 flanneld 进程；</li>
<li>flanneld 进行 UDP 封包之后重新进入内核态，将 UDP 包通过宿主机的 eth0 发出去；</li>
</ol>
<p>另外 Flannel 进行 UDP 封装和解封装的过程也都是在用户态完成的。在 Linux 操作系统中，上述这些上下文切换和用户态操作的代价其实都是比较高的，这也是 Flannel UDP 性能不好的原因。所以，在进行系统级编程的时候，一个非常重要的优化原则，就是要减少用户态到内核态的切换次数，并且把核心的处理逻辑都放在内核态进行。正因为此，Flannel 支持的 <strong>VXLAN</strong> 模式逐渐成为了主流的容器网络方案。</p>
<h3 id="Flannel-的-VXLAN-实现"><a href="#Flannel-的-VXLAN-实现" class="headerlink" title="Flannel 的 VXLAN 实现"></a>Flannel 的 VXLAN 实现</h3><p>VXLAN，即 Virtual Extensible LAN（虚拟可拓展局域网），是 Linux 内核本身就支持的网络虚拟化技术。所以 VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出 Overlay 网络。</p>
<p>VXLAN 的覆盖网络的设计思想是：在现有的三层网络上，“覆盖”一层虚拟的、由内核 VXLAN 模块维护的二层网络，使得连接在这个 VXLAN 二层网络上的主机之前可以像在一个局域网中那样自由通信。当然，实际上这些“主机”可能分布在不同的宿主机上，甚至是分布在不同的物理机房中。</p>
<p>为了在二层网络上打通“隧道”，VXLAN 在宿主机上设置一个特殊的网络设备作为隧道的两端，该设备叫做 VTEP，即 VXLAN Tunnel End Point。VTEP 设备的作用其实跟前面 flanneld 进程非常相似。只不过，它进行封装和解封装的对象，是二层数据帧（Ethernet frame）；而且这个工作的执行流程，全部是在内核中完成的。所以，基于 VTEP 设备进行隧道通信的流程，可以用下图标识：</p>
<img src="/2020/07/12/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/flannel-vxlan.png" class="">

<p>可以看到，每台宿主机上名为 flannel.1 的设备，就是 VXLAN 所需的 VTEP 设备，它既有 IP 地址，也有 MAC 地址。与 UDP 模式的流程类似，当 Container1 发出请求之后，这个目的地址是 10.1.16.3 的 IP 包，会先出现在 docker0 网桥，然后被路由到本机的 flannel.1 设备进行处理。也就是说，来到了“隧道”的入口。为了能将“原始 IP 包”封装并且发送到正确的宿主机，VXLAN 就需要找到这条“隧道”的出口，即：目的宿主机的 VTEP 设备。而这个设备的信息，正是每台宿主机上的 flanneld 进程维护的。VTEP 设备之间需要想办法组成一个虚拟的二层网络，即：通过二层数据帧进行通信。所以“源 VTEP 设备”收到“原始 IP 包”后，就要想办法把“原始 IP 包”加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 VTEP 设备”。“目的 VTEP 设备”的 MAC 地址由 ARP 表记录，而这里的 ARP 记录不是通过发送 ARP 请求获取，而是有 flanneld 在 Node2 节点启动时，自动添加在 Node1 上的。有了这个“目的 VTEP 设备”的 MAC 地址，Linux 内核就可以开始二层封包工作了。</p>
<p>Linux 内核会把“目的 VTEP 设备”的 MAC 地址，填写在图中额 Inner Ethernet Header 字段，二道一个二层数据帧。这些 VTEP 设备的 MAC 地址，对于宿主机来说并没有什么实际意义。所以上面封装的这个数据帧，并不能在宿主机的二层网络中传输，所以，我们将它称为“内部数据帧”。所以接下来，Linux 还需要把“内部数据帧”进一步封装称为宿主机网络里的一个普通的数据帧，好让它承载“内部数据帧”通过宿主机的 eth0 网卡进行传输。我们把这次要封装出来的、宿主机对应的数据帧称为“外部数据帧”。</p>
<p>Linux 内核还会在内部数据帧前面，添加一个特殊的 VXLAN 头，用来表示一个 VXLAN 要使用的数据帧。VXLAN 头里面有个重要的标志叫做 <strong>VNI</strong>，它是 VTEP 设备识别某个数据帧是不是应该归属于自己处理的标志。Flannel 中，VNI 默认都是 1。然后，Linux 内核会把这个数据帧封装进一个 UDP 包里发出去。所以，在宿主机看来，它只是向另外一台宿主机的 flannel.1 设备，发起了一次普通的 UDP 链接。</p>
<p>不过，一个 flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对应的宿主机地址。这种场景下，flannel.1 设备其实要扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。而 Linux 内核中，“网桥”设备进行转发的一句，来自 FDB 转发数据库，其中的信息也有由 flanneld 进程负责维护。</p>
<p>所以接下来就是一个正常的宿主机网络的封包工作。Linux 在它前面加上一个 IP 头，组成一个 IP 包。在 IP 头里，会填上查询得到的目的主机的 IP 地址。然后，Linux 内核再在这个 IP 包前面再加上二层数据帧头，并填入 Node2 的 MAC 地址。这个 MAC 地址本身是 Node1 的 ARP 表要学习的内容，无需 flannel 维护。接下来，Node 1 上的 flannel.1 设备就可以把这个数据帧从 eth0 网卡发出去。</p>
<p>以上就是 Flannel VXLAN 的工作原理了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2020/06/27/Kubernetes-Deployment-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/27/Kubernetes-Deployment-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Kubernetes Deployment 的设计与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-27 11:12:17" itemprop="dateCreated datePublished" datetime="2020-06-27T11:12:17+08:00">2020-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/06/27/Kubernetes-Deployment-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/27/Kubernetes-Deployment-的设计与实现/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>对于在生产或测试环境使用过 Kubernetes,或者对 Kubernetes 有基本了解的用户，Deployment 一定不陌生。Deployment 为 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">Pod</a> 和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">ReplicaSets</a> 提供了声明式管理的功能，每一个 Deployment 对应集群中的一次部署。用户可以利用 Yaml 或 JSON 文件描述的期望状态，Deployment Controller 将会以一定的速度将实际状态调整为与期望状态相同。</p>
<p>本文主要介绍 Deployment 的工作原理，并从源码角度分析它如何实现水平扩缩容、回滚、滚动更新等功能。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Deployment 是 Kubernetes 中最常见，也是最常用的 API 对象。上一篇文章中，介绍了 Kubernetes 的重要编程模型：控制器模型。Deployment Controller 即通过控制器模型为 Deployment 对象实现了声明式 API。</p>
<p>Deployment 看似简单，但是它实现了 Kubernetes 中非常重要的功能呢：Pod 的“水平扩展/收缩”（Horizontal scaling out/in）。而这个功能是从 PaaS 时代开始，任何一个平台级项目都必须具备的编排能力。而这个能力的实现，又依赖 Kubernetes 中的另一个重要的 API 对象：ReplicaSet。ReplicaSet 的 Yaml 非常简单，包含一个对象元数据、副本数定义和一个 Pod 模板:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-rs</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:stable</span></span><br></pre></td></tr></table></figure>

<p>不难发现 ReplicaSet 实际上是 Deployment 的一个子集。实际上，Deployment 直接管理的并不是 Pod，而是 ReplicaSet 对象。所以，对于一个 Deployment 所管理的 Pod，它的 <code>ownerReference</code> 其实是 ReplicaSet。</p>
<p>以一个副本数为 4 的 Deployment 为例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:stable</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在实际上，Deployment、ReplicaSet、Pod 之间的关系是：</p>
<img src="/2020/06/27/Kubernetes-Deployment-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/dep-rs-pod.png" class="">

<p>由上图可以看出，副本数是 4 的 Deployment，与 ReplicaSet，以及 Pod 是一种层层控制关系。其中 ReplicaSet 通过控制器，保证集群中 Pod 的个数永远等于指定的个数。在此基础上，Deployment 同样通过控制器模式，来操作 ReplicaSet 的个数和属性，进而实现“水平拓展/收缩”及“滚动更新”两个编排动作。其中“水平拓展/收缩”较为简单，Deployment Controller 只要修改它控制的 ReplicaSet 的副本数，ReplicaSet Controller 则根据期望的副本数新建或删除 Pod。</p>
<p>下面通过一个例子来解释“滚动更新”。首先，我们创建一个 <code>nginx-deployment</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">nginx-deploy.yaml</span> <span class="string">--record</span></span><br></pre></td></tr></table></figure>

<p>然后，检查创建后的状态：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">deployments</span></span><br><span class="line"><span class="string">NAME</span>               <span class="string">DESIRED</span>   <span class="string">CURRENT</span>   <span class="string">UP-TO-DATE</span>   <span class="string">AVAILABLE</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">nginx-deployment</span>   <span class="number">4</span>         <span class="number">0</span>         <span class="number">0</span>            <span class="number">0</span>           <span class="string">1s</span></span><br></pre></td></tr></table></figure>

<ol>
<li>DESIRED：表示期望的 Pod 个数；</li>
<li>CURRENT：当前 Running 状态 Pod 个数；</li>
<li>UP-TO-DATE：处于最新版本 Pod 个数；</li>
<li>AVAILABLE：当前已经可用的 Pod 个数，即既是 Running，又是最新版本，并且健康检查已为 Ready 的 Pod 个数；</li>
</ol>
<p>待全部 Pod 均处于 AVAILABLE 状态后，可以再查询 Deployment 所控制的 ReplicaSet：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">rs</span></span><br><span class="line"><span class="string">NAME</span>                          <span class="string">DESIRED</span>   <span class="string">CURRENT</span>   <span class="string">READY</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">nginx-deployment-3167673210</span>   <span class="number">4</span>         <span class="number">4</span>         <span class="number">4</span>       <span class="string">20s</span></span><br></pre></td></tr></table></figure>

<p>可以看到，创建 Deployment 后，Deployment Controller 就会立即创建一个 Pod 副本数为 4 的 ReplicaSet。而 ReplicaSet 的名字，则是由 Deployment 的名字和一个随机字符串组成。Deployment 的状态是在 ReplicaSet 的基础上，添加了和版本相关的 <code>UP-TO-DATE</code> 字段。</p>
<p>这时候，如果修改 Deployment 的 Pod 模板，就会触发“滚动更新”。当使用 <code>kubectl edit deployment</code> 或 <code>kubectl apply</code> 提交新的 yaml 后，可以通过查看 Deployment 的 Events，看到这个“滚动更新”的流程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ kubectl describe deployment nginx-deployment</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason             Age   From                   Message</span><br><span class="line">  ----    ------             ----  ----                   -------</span><br><span class="line">...</span><br><span class="line">  Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica <span class="built_in">set</span> nginx-deployment-1764197365 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica <span class="built_in">set</span> nginx-deployment-3167673210 to 2</span><br><span class="line">  Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica <span class="built_in">set</span> nginx-deployment-1764197365 to 2</span><br><span class="line">  Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica <span class="built_in">set</span> nginx-deployment-3167673210 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica <span class="built_in">set</span> nginx-deployment-1764197365 to 3</span><br><span class="line">  Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica <span class="built_in">set</span> nginx-deployment-3167673210 to 0</span><br></pre></td></tr></table></figure>

<p>可以看到当修改 PodTemplate 后，Deployment Controller 会使用这个新的 PodTemplate 创建一个新的 ReplicaSet，它初始的副本数是 0。然后 Deployment Controller 开始将新的 ReplicaSet 所控制的 Pod 副本数由 0 个变成 1 个，即：“水平拓展”出一个副本；接着又将旧的 ReplicaSet 所控制的 Pod 副本数减少一个，即：“水平收缩”。如此交替进行，最后新的 ReplicaSet 所管理的 Pod 个数上升为 4，而旧的 ReplicaSet 所管理的 Pod 个数收缩为 0 个。</p>
<p>这样，将集群中正在运行的多个 Pod 版本，交替逐一升级更换的过程就是“滚动更新”。更新结束后，可以查看新、旧两个 ReplicaSet 的状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME                          DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deployment-1764197365   4         4         4       6s</span><br><span class="line">nginx-deployment-3167673210   0         0         0       30s</span><br></pre></td></tr></table></figure>

<p>滚动更新有很明显的好处。比如当新的 Pod 因为故障无法启动时，“滚动更新”就会停止，允许开发者介入。而此时应用本身还是有两个旧版本的 Pod 在线，所以服务不会受到太大的影响。当然这也要求开发者一定要使用 Health Check 检查应用的运行状态，而不是依赖于容器的 Running 状态。此外，Deployment Controller 还会保证在任何时间窗口内，只有指定比例的新 Pod 被创建，及指定比例的旧 Pod 处于离线状态。这两个比例的默认值均为 25%，且可以在 <code>spec.rollingUpdateStrategy</code> 中配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br></pre></td></tr></table></figure>

<p>结合“滚动更新”，Deployment、ReplicaSet、Pod 的关系图为：</p>
<img src="/2020/06/27/Kubernetes-Deployment-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/dep-rs-pod-2.png" class="">

<p>如图中所示，Deployment Controller 实际上控制 ReplicaSet 的数量，以及每个 ReplicaSet 的属性。而应用的一个版本对应的正是一个 ReplicaSet，这个版本的 Pod 数量则由 ReplicaSet Controller 保证。通过多个 ReplicaSet，Kubernetes 就实现了对多个“应用版本”的描述。</p>
<p>当在滚动更新，发现新版本不符合预期，需要回滚到旧版本的时候，可以执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ kubectl rollout undo deployment/nginx-deployment</span><br><span class="line">deployment.extensions/nginx-deployment</span><br></pre></td></tr></table></figure>

<p>在具体操作上，Deployment Controller 就是让旧的 ReplicaSet 再次扩展成 4 个 Pod，而让新的 Pod 重新收缩为 0 个。那么更进一步，如果需要回滚到更早的版本，要怎么办呢？</p>
<p>首先，需要使用 <code>kubectl roll history</code> 命令，查看每次 Deployment 变更对应的版本：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">rollout</span> <span class="string">history</span> <span class="string">deployment/nginx-deployment</span></span><br><span class="line"><span class="string">deployments</span> <span class="string">"nginx-deployment"</span></span><br><span class="line"><span class="string">REVISION</span>    <span class="string">CHANGE-CAUSE</span></span><br><span class="line"><span class="number">1</span>           <span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">nginx-deployment.yaml</span> <span class="string">--record</span></span><br><span class="line"><span class="number">2</span>           <span class="string">kubectl</span> <span class="string">edit</span> <span class="string">deployment/nginx-deployment</span></span><br><span class="line"><span class="number">3</span>           <span class="string">kubectl</span> <span class="string">set</span> <span class="string">image</span> <span class="string">deployment/nginx-deployment</span> <span class="string">nginx=nginx:alpine</span></span><br></pre></td></tr></table></figure>

<p>然后可以在回滚的时候通过指定版本的版本号，回滚到指定版本：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">rollout</span> <span class="string">undo</span> <span class="string">deployment/nginx-deployment</span> <span class="string">--to-revision=2</span></span><br><span class="line"><span class="string">deployment.extensions/nginx-deployment</span></span><br></pre></td></tr></table></figure>

<p>这里我们可能已经想到一个问题：对 Deployment 的每次更新操作，都会产生一个新的 ReplicaSet，这会不会浪费资源呢？</p>
<p>其中一个方法是可以使用 <code>kubectl rollout pause</code> 指令暂停滚动更新，当完成对 Deployment 的全部修改后，在使用 <code>kubectl rollout resume</code> 指令恢复继续进行滚动更新。这时，只会生成一个 ReplicaSet。不过，其实这样控制 ReplicaSet 的数量，随着应用的不断更新，ReplicaSet 的数量还是会不断增加。Deployment 利用一个 <code>spec.revisionHistoryLimit</code> 字段，限制了保存的历史版本个数。所以如果将它设置为 0，那么就无法进行回滚操作了。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>前文我们从实践角度分析了 Deployment 的工作原理。下面通过分析源码，研究 Deployment 的具体实现。</p>
<p>在 Kubernetes 的结构中存在一个叫做 <code>kube-controller-manager</code> 的组件。其实这个组件就是一系列控制器的组合。在项目源代码 <code>pkg/controller</code> 目录下可以看到一系列 controller：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">$</span> <span class="string">cd</span> <span class="string">kubernetes/pkg/controller/</span></span><br><span class="line"><span class="string">$</span> <span class="string">ls</span> <span class="string">-d</span> <span class="string">*/</span>              </span><br><span class="line"><span class="string">deployment/</span>             <span class="string">job/</span>                    <span class="string">podautoscaler/</span>          </span><br><span class="line"><span class="string">cloud/</span>                  <span class="string">disruption/</span>             <span class="string">namespace/</span>              </span><br><span class="line"><span class="string">replicaset/</span>             <span class="string">serviceaccount/</span>         <span class="string">volume/</span></span><br><span class="line"><span class="string">cronjob/</span>                <span class="string">garbagecollector/</span>       <span class="string">nodelifecycle/</span>          <span class="string">replication/</span>            <span class="string">statefulset/</span>            <span class="string">daemon/</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>这个目录下的每一个控制器，都以独特的方式负责某种编排功能，都遵循通用的编排功能：控制循环。而 Deployment 正式控制器中的一种。</p>
<p><code>DeploymentController</code> 作为管理 Deployment 资源的控制器，会在启动时利用 <code>Informer</code> 监听 Pod、ReplicaSet、Deployment 三种资源对象的通知，这三种资源的变动都会触发控制器中的回调函数。</p>
<p>不同对象的事件在被过滤后进行工作队列，等待工作进程的消费，以下事件会触发 Deployment 的同步：</p>
<ol>
<li>Deployment 变化；</li>
<li>Deployment 控制的 ReplicaSet 的变化；</li>
<li>Deployment 下的 Pod 数量为 0 时，Pod 的删除事件；</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewDeploymentController creates a new DeploymentController.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDeploymentController</span><span class="params">(dInformer appsinformers.DeploymentInformer, </span></span></span><br><span class="line"><span class="function"><span class="params">                             rsInformer appsinformers.ReplicaSetInformer,         </span></span></span><br><span class="line"><span class="function"><span class="params">                             podInformer coreinformers.PodInformer, </span></span></span><br><span class="line"><span class="function"><span class="params">                             client clientset.Interface)</span></span> </span><br><span class="line">                             (*DeploymentController, error) {</span><br><span class="line">    </span><br><span class="line">    dc := &amp;DeploymentController{</span><br><span class="line">		client:        client,</span><br><span class="line">		eventRecorder: eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: <span class="string">"deployment-controller"</span>}),</span><br><span class="line">		queue:         workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), <span class="string">"deployment"</span>),</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    dInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{</span><br><span class="line">		AddFunc:    dc.addDeployment,</span><br><span class="line">		UpdateFunc: dc.updateDeployment,</span><br><span class="line">		<span class="comment">// This will enter the sync loop and no-op, because the deployment has been deleted from the store.</span></span><br><span class="line">		DeleteFunc: dc.deleteDeployment,</span><br><span class="line">	})</span><br><span class="line">	rsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{</span><br><span class="line">		AddFunc:    dc.addReplicaSet,</span><br><span class="line">		UpdateFunc: dc.updateReplicaSet,</span><br><span class="line">		DeleteFunc: dc.deleteReplicaSet,</span><br><span class="line">	})</span><br><span class="line">	podInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{</span><br><span class="line">		DeleteFunc: dc.deletePod,</span><br><span class="line">    })</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> dc, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>DeploymentController 在调用 Run 的时候启动多个工作进程，这些工作进程运行 worker 方法从队列中读取最新 Deployment 对象进行同步。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>DeploymentController 对 Deployment 的通过通过以 <code>syncDeployment</code> 方法进行，该方法包含同步、回滚及更新逻辑，也是同步 Deployment 资源的唯一入口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syncDeployment will sync the deployment with the given key.</span></span><br><span class="line"><span class="comment">// This function is not meant to be invoked concurrently with the same key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">syncDeployment</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">error</span></span> {</span><br><span class="line">    namespace, name, err := cache.SplitMetaNamespaceKey(key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	deployment, err := dc.dLister.Deployments(namespace).Get(name)</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) {</span><br><span class="line">		klog.V(<span class="number">2</span>).Infof(<span class="string">"Deployment %v has been deleted"</span>, key)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    d := deployment.DeepCopy()</span><br><span class="line">    <span class="comment">// List ReplicaSets owned by this Deployment, while reconciling ControllerRef</span></span><br><span class="line">	<span class="comment">// through adoption/orphaning.</span></span><br><span class="line">    rsList, _ := dc.getReplicaSetsForDeployment(d)</span><br><span class="line">    <span class="comment">// List all Pods owned by this Deployment, grouped by their ReplicaSet.</span></span><br><span class="line">	<span class="comment">// Current uses of the podMap are:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// * check if a Pod is labeled correctly with the pod-template-hash label.</span></span><br><span class="line">	<span class="comment">// * check that no old Pods are running in the middle of Recreate Deployments.</span></span><br><span class="line">    podMap, _ := dc.getPodMapForDeployment(d, rsList)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> d.Spec.Paused {</span><br><span class="line">		<span class="keyword">return</span> dc.sync(d, rsList)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    scalingEvent, err := dc.isScalingEvent(d, rsList)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> scalingEvent {</span><br><span class="line">		<span class="keyword">return</span> dc.sync(d, rsList)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> d.Spec.Strategy.Type {</span><br><span class="line">	<span class="keyword">case</span> apps.RecreateDeploymentStrategyType:</span><br><span class="line">		<span class="keyword">return</span> dc.rolloutRecreate(d, rsList, podMap)</span><br><span class="line">	<span class="keyword">case</span> apps.RollingUpdateDeploymentStrategyType:</span><br><span class="line">		<span class="keyword">return</span> dc.rolloutRolling(d, rsList)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"unexpected deployment strategy type: %s"</span>, d.Spec.Strategy.Type)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>在删除简化后的流程中：</p>
<ol>
<li><p>由传入的 key 获取 Deployment；</p>
</li>
<li><p>调用 <code>getReplicaSetsForDeployment</code> 获取集群中与 Deployment 相关的所有 ReplicaSet；</p>
<ol>
<li>查找所有 ReplicaSet；</li>
<li>根据 Deployment 中的选择器对 ReplicaSet 建立或释放从属关系；</li>
</ol>
</li>
<li><p>调用 <code>getPodMapForDeployment</code> 查询 Deployment 控制的 ReplicaSet 到 Pod 的映射；</p>
<ol>
<li>根据选择器查询全部 Pod；</li>
<li>根据 Pod 的控制器 ReplicaSet 对上述 Pod 进行分类；</li>
</ol>
</li>
<li><p>如果 Deployment 处于暂停状态或者需要扩容，就会调用 <code>sync</code> 方法同步 Deployment；</p>
</li>
<li><p>在正常情况下会根据规格中的策略对 Deployment 进行更新：</p>
<ol>
<li><code>Recreate</code> 策略调用 <code>rolloutRecreate</code> 方法，先杀掉所有存在的 Pod 后启动新的 Pod 副本；</li>
<li><code>RollingUpdate</code> 策略调用 <code>rolloutRolling</code> 方法，根据 <code>maxSurge</code> 和 <code>maxUnavailable</code> 配置对 Pod 进行滚动更新。</li>
</ol>
</li>
</ol>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>如果当前需要更新的 Deployment 由 <code>isScalingEvent</code> 检查发现更新事件是一次扩缩容事件，那么 ReplicaSet 持有的 Pod 数量和规格中的 ReplicaSet 不一致，那么就调用 <code>sync</code> 方法对 Deployment 进行同步：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync is responsible for reconciling deployments on scaling events or when they</span></span><br><span class="line"><span class="comment">// are paused.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">sync</span><span class="params">(d *apps.Deployment, rsList []*apps.ReplicaSet)</span> <span class="title">error</span></span> {</span><br><span class="line">    newRS, oldRSs, err := dc.getAllReplicaSetsAndSyncRevision(d, rsList, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> err := dc.scale(d, newRS, oldRSs); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// If we get an error while trying to scale, the deployment will be requeued</span></span><br><span class="line">		<span class="comment">// so we can abort this resync</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    allRSs := <span class="built_in">append</span>(oldRSs, newRS)</span><br><span class="line">	<span class="keyword">return</span> dc.syncDeploymentStatus(allRSs, newRS, d)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><code>sync</code> 从 apiserver 获取当前 Deployment 对应的最新 ReplicaSet 和历史 ReplicaSet 并调用 <code>scale</code> 方法开始扩容。<code>scale</code> 即为扩容主要执行的方法。该方法较长，本文分为几部分来分析具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">scale</span><span class="params">(deployment *apps.Deployment, newRS *apps.ReplicaSet, oldRSs []*apps.ReplicaSet)</span> <span class="title">error</span></span> {</span><br><span class="line">    <span class="comment">// If there is only one active replica set then we should scale that up to the full count of the</span></span><br><span class="line">	<span class="comment">// deployment. If there is no active replica set, then we should scale up the newest replica set.</span></span><br><span class="line">	<span class="keyword">if</span> activeOrLatest := deploymentutil.FindActiveOrLatest(newRS, oldRSs); activeOrLatest != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">if</span> *(activeOrLatest.Spec.Replicas) == *(deployment.Spec.Replicas) {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		}</span><br><span class="line">		_, _, err := dc.scaleReplicaSetAndRecordEvent(activeOrLatest, *(deployment.Spec.Replicas), deployment)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the new replica set is saturated, old replica sets should be fully scaled down.</span></span><br><span class="line">	<span class="comment">// This case handles replica set adoption during a saturated new replica set.</span></span><br><span class="line">	<span class="keyword">if</span> deploymentutil.IsSaturated(deployment, newRS) {</span><br><span class="line">		<span class="keyword">for</span> _, old := <span class="keyword">range</span> controller.FilterActiveReplicaSets(oldRSs) {</span><br><span class="line">			<span class="keyword">if</span> _, _, err := dc.scaleReplicaSetAndRecordEvent(old, <span class="number">0</span>, deployment); err != <span class="literal">nil</span> {</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>假如集群中只有一个活跃的 ReplicaSet，那么就对该 ReplicaSet 进行直接扩缩容，但是如果不存在活跃 ReplicaSet 则选择最新 ReplicaSet。这部分工作由 <code>FindActiveOrLatest</code> 及 <code>scaleReplicaSetAndRecordEvent</code> 共同完成。</p>
<p>当调用 <code>IsSaturated</code> 发现当前 Deployment 对应的副本数已饱和时，则删除所有历史版本 ReplicaSet 持有的 Pod 副本。</p>
<p>当 Deployment 使用滚动更新策略时，如果发现当前 ReplicaSet 没有饱和并且存在多个活跃的 ReplicaSet 对象，则按照比例分别对各个活跃的 ReplicaSet 进行扩容或缩容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// There are old replica sets with pods and the new replica set is not saturated.</span></span><br><span class="line"><span class="comment">// We need to proportionally scale all replica sets (new and old) in case of a</span></span><br><span class="line"><span class="comment">// rolling deployment.</span></span><br><span class="line"><span class="keyword">if</span> deploymentutil.IsRollingUpdate(deployment) {</span><br><span class="line">	allRSs := controller.FilterActiveReplicaSets(<span class="built_in">append</span>(oldRSs, newRS))</span><br><span class="line">	allRSsReplicas := deploymentutil.GetReplicaCountForReplicaSets(allRSs)</span><br><span class="line"></span><br><span class="line">	allowedSize := <span class="keyword">int32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> *(deployment.Spec.Replicas) &gt; <span class="number">0</span> {</span><br><span class="line">		allowedSize = *(deployment.Spec.Replicas) + deploymentutil.MaxSurge(*deployment)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Number of additional replicas that can be either added or removed from the total</span></span><br><span class="line">	<span class="comment">// replicas count. These replicas should be distributed proportionally to the active</span></span><br><span class="line">	<span class="comment">// replica sets.</span></span><br><span class="line">	deploymentReplicasToAdd := allowedSize - allRSsReplicas</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The additional replicas should be distributed proportionally amongst the active</span></span><br><span class="line">	<span class="comment">// replica sets from the larger to the smaller in size replica set. Scaling direction</span></span><br><span class="line">	<span class="comment">// drives what happens in case we are trying to scale replica sets of the same size.</span></span><br><span class="line">	<span class="comment">// In such a case when scaling up, we should scale up newer replica sets first, and</span></span><br><span class="line">	<span class="comment">// when scaling down, we should scale down older replica sets first.</span></span><br><span class="line">	<span class="keyword">var</span> scalingOperation <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">switch</span> {</span><br><span class="line">	<span class="keyword">case</span> deploymentReplicasToAdd &gt; <span class="number">0</span>:</span><br><span class="line">		sort.Sort(controller.ReplicaSetsBySizeNewer(allRSs))</span><br><span class="line">		scalingOperation = <span class="string">"up"</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> deploymentReplicasToAdd &lt; <span class="number">0</span>:</span><br><span class="line">		sort.Sort(controller.ReplicaSetsBySizeOlder(allRSs))</span><br><span class="line">		scalingOperation = <span class="string">"down"</span></span><br><span class="line">	}</span><br></pre></td></tr></table></figure>

<ol>
<li><p>调用 <code>FilterActiveReplicaSets</code> 查询所有活跃的 ReplicaSet；</p>
</li>
<li><p>调用 <code>GetReplicaCountForReplicaSets</code> 计算当前 Deployment 对应 ReplicaSet 持有的全部 Pod 副本个数；</p>
</li>
<li><p>根据 Deployment 配置的 <code>maxSurge</code> 和 <code>replicas</code> 计算允许创建的 Pod 数量；</p>
</li>
<li><p>利用 <code>allowedSize</code> 和 <code>allRSsReplicas</code> 计算出需要增加或者删除的副本数；</p>
</li>
<li><p>根据 <code>deploymentReplicasToAdd</code> 变量的符号对 ReplicaSet 数组进行排序并确定当前的操作是扩容还是缩容：</p>
<ol>
<li>若 <code>deploymentReplicasToAdd</code> &gt; 0，ReplicaSet 按照从新到旧的顺序进行扩容；</li>
<li>若 <code>deploymentReplicasToAdd</code> &lt; 0，ReplicaSet 按照从旧到新的顺序进行缩容；</li>
</ol>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Iterate over all active replica sets and estimate proportions for each of them.</span></span><br><span class="line"><span class="comment">// The absolute value of deploymentReplicasAdded should never exceed the absolute</span></span><br><span class="line"><span class="comment">// value of deploymentReplicasToAdd.</span></span><br><span class="line">deploymentReplicasAdded := <span class="keyword">int32</span>(<span class="number">0</span>)</span><br><span class="line">nameToSize := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int32</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> allRSs {</span><br><span class="line">	rs := allRSs[i]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Estimate proportions if we have replicas to add, otherwise simply populate</span></span><br><span class="line">	<span class="comment">// nameToSize with the current sizes for each replica set.</span></span><br><span class="line">	<span class="keyword">if</span> deploymentReplicasToAdd != <span class="number">0</span> {</span><br><span class="line">		proportion := deploymentutil.GetProportion(rs, *deployment, deploymentReplicasToAdd, deploymentReplicasAdded)</span><br><span class="line"></span><br><span class="line">		nameToSize[rs.Name] = *(rs.Spec.Replicas) + proportion</span><br><span class="line">		deploymentReplicasAdded += proportion</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		nameToSize[rs.Name] = *(rs.Spec.Replicas)</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>由于当前的 Deployment 持有了多个活跃的 ReplicaSet，所以在计算了需要增加或者删除的副本数 <code>deploymentReplicasToAdd</code>后，就会为多个活跃的 ReplicaSet 分配需要改变的副本数，<code>GetProportion</code> 会根据以下几个参数确定结果:</p>
<ol>
<li>Deployment 期望的 Pod 副本数量；</li>
<li>需要新增或减少的副本数量；</li>
<li>Deployment 目前通过 ReplicaSet 持有的 Pod 总数；</li>
</ol>
<p>Kubernetes 在 <code>getReplicaSetFraction</code> 中使用下面的公式计算每个 ReplicaSet 在 Deployment 资源中的占比，最后返回该 ReplicaSet 需要改变的副本数：</p>
<p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -2.148ex" xmlns="http://www.w3.org/2000/svg" width="89.491ex" height="5.451ex" role="img" focusable="false" viewBox="0 -1460 39555 2409.5" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-1D45F"></use></g><g data-mml-node="mi" transform="translate(451, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(917, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(1420, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(1718, 0)"><use xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(2063, 0)"><use xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(2496, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(3025, 0)"><use xlink:href="#MJX-TEX-I-1D446"></use></g><g data-mml-node="mi" transform="translate(3670, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(4136, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(4497, 0)"><use xlink:href="#MJX-TEX-N-2E"></use></g><g data-mml-node="mi" transform="translate(4941.7, 0)"><use xlink:href="#MJX-TEX-I-1D446"></use></g><g data-mml-node="mi" transform="translate(5586.7, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(6089.7, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(6555.7, 0)"><use xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mo" transform="translate(6988.7, 0)"><use xlink:href="#MJX-TEX-N-2E"></use></g><g data-mml-node="mi" transform="translate(7433.3, 0)"><use xlink:href="#MJX-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(8192.3, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(8658.3, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(9161.3, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(9459.3, 0)"><use xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(9804.3, 0)"><use xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(10237.3, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(10766.3, 0)"><use xlink:href="#MJX-TEX-I-1D460"></use></g><g data-mml-node="mo" transform="translate(11457.6, 0)"><use xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="mrow" transform="translate(12457.8, 0)"><g data-mml-node="mo"><use xlink:href="#MJX-TEX-S3-28"></use></g><g data-mml-node="mfrac" transform="translate(736, 0)"><g data-mml-node="mrow" transform="translate(220, 710)"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(520, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(986, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(1489, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(1787, 0)"><use xlink:href="#MJX-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(2272, 0)"><use xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(2762, 0)"><use xlink:href="#MJX-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(3640, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(4106, 0)"><use xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(4706, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(5067, 0)"><use xlink:href="#MJX-TEX-N-2E"></use></g><g data-mml-node="mi" transform="translate(5511.7, 0)"><use xlink:href="#MJX-TEX-I-1D446"></use></g><g data-mml-node="mi" transform="translate(6156.7, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(6659.7, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(7125.7, 0)"><use xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mo" transform="translate(7558.7, 0)"><use xlink:href="#MJX-TEX-N-2E"></use></g><g data-mml-node="mi" transform="translate(8003.3, 0)"><use xlink:href="#MJX-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(8762.3, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(9228.3, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(9731.3, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(10029.3, 0)"><use xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(10374.3, 0)"><use xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(10807.3, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(11336.3, 0)"><use xlink:href="#MJX-TEX-I-1D460"></use></g><g data-mml-node="mo" transform="translate(12027.6, 0)"><use xlink:href="#MJX-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(13027.8, 0)"><use xlink:href="#MJX-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(13905.8, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(14434.8, 0)"><use xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(15006.8, 0)"><use xlink:href="#MJX-TEX-I-1D446"></use></g><g data-mml-node="mi" transform="translate(15651.8, 0)"><use xlink:href="#MJX-TEX-I-1D462"></use></g><g data-mml-node="mi" transform="translate(16223.8, 0)"><use xlink:href="#MJX-TEX-I-1D45F"></use></g><g data-mml-node="mi" transform="translate(16674.8, 0)"><use xlink:href="#MJX-TEX-I-1D454"></use></g><g data-mml-node="mi" transform="translate(17151.8, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mo" transform="translate(17617.8, 0)"><use xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(18006.8, 0)"><use xlink:href="#MJX-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(18526.8, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(18992.8, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(19495.8, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(19793.8, 0)"><use xlink:href="#MJX-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(20278.8, 0)"><use xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(20768.8, 0)"><use xlink:href="#MJX-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(21646.8, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(22112.8, 0)"><use xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(22712.8, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(23073.8, 0)"><use xlink:href="#MJX-TEX-N-29"></use></g></g><g data-mml-node="mrow" transform="translate(5603.7, -686)"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(520, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(986, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(1489, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(1787, 0)"><use xlink:href="#MJX-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(2272, 0)"><use xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mi" transform="translate(2762, 0)"><use xlink:href="#MJX-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(3640, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(4106, 0)"><use xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(4706, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(5067, 0)"><use xlink:href="#MJX-TEX-N-2E"></use></g><g data-mml-node="mi" transform="translate(5511.7, 0)"><use xlink:href="#MJX-TEX-I-1D446"></use></g><g data-mml-node="mi" transform="translate(6156.7, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(6517.7, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(7046.7, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(7407.7, 0)"><use xlink:href="#MJX-TEX-I-1D462"></use></g><g data-mml-node="mi" transform="translate(7979.7, 0)"><use xlink:href="#MJX-TEX-I-1D460"></use></g><g data-mml-node="mo" transform="translate(8448.7, 0)"><use xlink:href="#MJX-TEX-N-2E"></use></g><g data-mml-node="mi" transform="translate(8893.3, 0)"><use xlink:href="#MJX-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(9652.3, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(10118.3, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(10621.3, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(10919.3, 0)"><use xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(11264.3, 0)"><use xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(11697.3, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(12226.3, 0)"><use xlink:href="#MJX-TEX-I-1D460"></use></g></g><rect width="23662.8" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(24861, 0)"><use xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(25861.2, 0)"><use xlink:href="#MJX-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(26361.2, 0)"><use xlink:href="#MJX-TEX-S3-29"></use></g></g></g></g></svg></mjx-container></p>
<p>该结果又会与目前期望的剩余变化量对比，保证变化的副本数量不会超过期望值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update all replica sets</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> allRSs {</span><br><span class="line">	rs := allRSs[i]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add/remove any leftovers to the largest replica set.</span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">0</span> &amp;&amp; deploymentReplicasToAdd != <span class="number">0</span> {</span><br><span class="line">		leftover := deploymentReplicasToAdd - deploymentReplicasAdded</span><br><span class="line">		nameToSize[rs.Name] = nameToSize[rs.Name] + leftover</span><br><span class="line">		<span class="keyword">if</span> nameToSize[rs.Name] &lt; <span class="number">0</span> {</span><br><span class="line">			nameToSize[rs.Name] = <span class="number">0</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Use transactions when we have them.</span></span><br><span class="line">	<span class="keyword">if</span> _, _, err := dc.scaleReplicaSet(rs, nameToSize[rs.Name], deployment, scalingOperation); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="comment">// Return as soon as we fail, the deployment is requeued</span></span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p><code>scale</code> 方法的最后会直接调用 <code>scaleReplicaSet</code> 将每一个 ReplicaSet 都扩容或缩容到期望的副本数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">scaleReplicaSet</span><span class="params">(rs *apps.ReplicaSet, newScale <span class="keyword">int32</span>, deployment *apps.Deployment, scalingOperation <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">bool</span>, *apps.ReplicaSet, error)</span></span> {</span><br><span class="line"></span><br><span class="line">	sizeNeedsUpdate := *(rs.Spec.Replicas) != newScale</span><br><span class="line"></span><br><span class="line">	annotationsNeedUpdate := deploymentutil.ReplicasAnnotationsNeedUpdate(rs, *(deployment.Spec.Replicas), *(deployment.Spec.Replicas)+deploymentutil.MaxSurge(*deployment))</span><br><span class="line"></span><br><span class="line">	scaled := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">if</span> sizeNeedsUpdate || annotationsNeedUpdate {</span><br><span class="line">		rsCopy := rs.DeepCopy()</span><br><span class="line">		*(rsCopy.Spec.Replicas) = newScale</span><br><span class="line">		deploymentutil.SetReplicasAnnotations(rsCopy, *(deployment.Spec.Replicas), *(deployment.Spec.Replicas)+deploymentutil.MaxSurge(*deployment))</span><br><span class="line">		rs, err = dc.client.AppsV1().ReplicaSets(rsCopy.Namespace).Update(context.TODO(), rsCopy, metav1.UpdateOptions{})</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; sizeNeedsUpdate {</span><br><span class="line">			scaled = <span class="literal">true</span></span><br><span class="line">			dc.eventRecorder.Eventf(deployment, v1.EventTypeNormal, <span class="string">"ScalingReplicaSet"</span>, <span class="string">"Scaled %s replica set %s to %d"</span>, scalingOperation, rs.Name, newScale)</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> scaled, rs, err</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>该方法会直接修改目标 ReplicaSet.Spec 中的 Replicas 参数和注解 <code>deployment.kubernetes.io/desired-replicas</code> 的值并通过 API 请求更新当前的 ReplicaSet 对象。</p>
<p>用户可以通过 <code>kubectl describe</code> 命令查看 ReplicaSet 的 Annotations，其实能发现当前 RS 的期待副本数和最大副本数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe rs nginx-deployment-76bf4969df</span><br><span class="line">Name:           nginx-deployment-76bf4969df</span><br><span class="line">Namespace:      default</span><br><span class="line">Selector:       app=nginx,pod-template-hash=76bf4969df</span><br><span class="line">Labels:         app=nginx</span><br><span class="line">                pod-template-hash=76bf4969df</span><br><span class="line">Annotations:    deployment.kubernetes.io/desired-replicas=4</span><br><span class="line">                deployment.kubernetes.io/max-replicas=5</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="重新创建"><a href="#重新创建" class="headerlink" title="重新创建"></a>重新创建</h3><p>当 Deployment 使用的更新策略是 <code>Recreate</code> 时，DeploymentController 就会使用如下的 <code>rolloutRecreate</code> 方法对 Deployment 进行更新：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rolloutRecreate implements the logic for recreating a replica set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">rolloutRecreate</span><span class="params">(d *apps.Deployment, rsList []*apps.ReplicaSet, podMap <span class="keyword">map</span>[types.UID][]*v1.Pod)</span> <span class="title">error</span></span> {</span><br><span class="line">	<span class="comment">// Don't create a new RS if not already existed, so that we avoid scaling up before scaling down.</span></span><br><span class="line">	newRS, oldRSs, _ := dc.getAllReplicaSetsAndSyncRevision(d, rsList, <span class="literal">false</span>)</span><br><span class="line">	allRSs := <span class="built_in">append</span>(oldRSs, newRS)</span><br><span class="line">	activeOldRSs := controller.FilterActiveReplicaSets(oldRSs)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scale down old replica sets.</span></span><br><span class="line">	scaledDown, _ := dc.scaleDownOldReplicaSetsForRecreate(activeOldRSs, d)</span><br><span class="line">	<span class="keyword">if</span> scaledDown {</span><br><span class="line">		<span class="comment">// Update DeploymentStatus.</span></span><br><span class="line">		<span class="keyword">return</span> dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do not process a deployment when it has old pods running.</span></span><br><span class="line">	<span class="keyword">if</span> oldPodsRunning(newRS, oldRSs, podMap) {</span><br><span class="line">		<span class="keyword">return</span> dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we need to create a new RS, create it now.</span></span><br><span class="line">	<span class="keyword">if</span> newRS == <span class="literal">nil</span> {</span><br><span class="line">		newRS, oldRSs, _ = dc.getAllReplicaSetsAndSyncRevision(d, rsList, <span class="literal">true</span>)</span><br><span class="line">		allRSs = <span class="built_in">append</span>(oldRSs, newRS)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// scale up new replica set.</span></span><br><span class="line">	<span class="keyword">if</span> _, err := dc.scaleUpNewReplicaSetForRecreate(newRS, d); err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> util.DeploymentComplete(d, &amp;d.Status) {</span><br><span class="line">		<span class="keyword">if</span> err := dc.cleanupDeployment(oldRSs, d); err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sync deployment status.</span></span><br><span class="line">	<span class="keyword">return</span> dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<ol>
<li>调用 <code>getAllReplicaSetsAndSyncRevision</code> 和 <code>FilterActiveReplicaSets</code> 两个方法获取 Deployment 中所有的 ReplicaSet 以及其中活跃的 ReplicaSet 对象；</li>
<li>调用 <code>scaleDownOldReplicaSetsForRecreate</code> 方法将所有活跃的历史 ReplicaSet 持有的 Pod 数降低至 0；</li>
<li>同步 Deployment 的最新状态并等待 Pod 的终止；</li>
<li>在需要时通过 <code>getAllReplicaSetsAndSyncRevision</code> 方法创建新的 ReplicaSet 并调用 <code>scaleUpNewReplicaSetForRecreate</code> 函数对 ReplicaSet 进行扩容；</li>
<li>更新完成之后会调用 cleanupDeployment 方法删除历史全部的 ReplicaSet 对象并更新 Deployment 的状态；</li>
</ol>
<p>也就是说在更新的过程中，之前创建的 ReplicaSet 和 Pod 资源会被全部删除，只是 Pod 会先被删除而 ReplicaSet 会后被删除；上述方法也会创建新的 ReplicaSet 和 Pod 对象。但是需要注意旧的 Pod 副本一定会被先删除，所以会有一段时间不存在可用的 Pod。</p>
<h3 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h3><p>在使用 Deployment 对象时，我们更常用的更新策略是 <code>RollingUpdate</code>。在介绍滚动更新流程前，需要先了解两个参数：</p>
<ol>
<li><code>maxUnavailable</code>：表示在更新过程中能够进入不可用状态的 Pod 数量的最大值；</li>
<li><code>maxSurge</code>：表示在更新过程汇总能够额外创建的 Pod 数量的最大值；</li>
</ol>
<p><code>maxUnavailable</code> 和 <code>maxSurge</code> 这两个滚动更新所使用的配置都可以用百分比或者绝对值表示；当使用百分比时，会使用 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="47.205ex" height="2.059ex" role="img" focusable="false" viewBox="0 -705 20864.8 910" xmlns:xlink="http://www.w3.org/1999/xlink"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(759, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(1225, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(1728, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(2026, 0)"><use xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(2371, 0)"><use xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(2804, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(3333, 0)"><use xlink:href="#MJX-TEX-I-1D460"></use></g><g data-mml-node="mo" transform="translate(4024.2, 0)"><use xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="mi" transform="translate(5024.4, 0)"><use xlink:href="#MJX-TEX-I-1D446"></use></g><g data-mml-node="mi" transform="translate(5669.4, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(6030.4, 0)"><use xlink:href="#MJX-TEX-I-1D45F"></use></g><g data-mml-node="mi" transform="translate(6481.4, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(7010.4, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(7371.4, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(7837.4, 0)"><use xlink:href="#MJX-TEX-I-1D454"></use></g><g data-mml-node="mi" transform="translate(8314.4, 0)"><use xlink:href="#MJX-TEX-I-1D466"></use></g><g data-mml-node="mo" transform="translate(8804.4, 0)"><use xlink:href="#MJX-TEX-N-2E"></use></g><g data-mml-node="mi" transform="translate(9249.1, 0)"><use xlink:href="#MJX-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(10008.1, 0)"><use xlink:href="#MJX-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(10493.1, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(10791.1, 0)"><use xlink:href="#MJX-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(11089.1, 0)"><use xlink:href="#MJX-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(11434.1, 0)"><use xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(12034.1, 0)"><use xlink:href="#MJX-TEX-I-1D454"></use></g><g data-mml-node="mi" transform="translate(12511.1, 0)"><use xlink:href="#MJX-TEX-I-1D448"></use></g><g data-mml-node="mi" transform="translate(13278.1, 0)"><use xlink:href="#MJX-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(13781.1, 0)"><use xlink:href="#MJX-TEX-I-1D451"></use></g><g data-mml-node="mi" transform="translate(14301.1, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(14830.1, 0)"><use xlink:href="#MJX-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(15191.1, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g><g data-mml-node="mo" transform="translate(15657.1, 0)"><use xlink:href="#MJX-TEX-N-2E"></use></g><g data-mml-node="mi" transform="translate(16101.8, 0)"><use xlink:href="#MJX-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(17152.8, 0)"><use xlink:href="#MJX-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(17681.8, 0)"><use xlink:href="#MJX-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(18253.8, 0)"><use xlink:href="#MJX-TEX-I-1D446"></use></g><g data-mml-node="mi" transform="translate(18898.8, 0)"><use xlink:href="#MJX-TEX-I-1D462"></use></g><g data-mml-node="mi" transform="translate(19470.8, 0)"><use xlink:href="#MJX-TEX-I-1D45F"></use></g><g data-mml-node="mi" transform="translate(19921.8, 0)"><use xlink:href="#MJX-TEX-I-1D454"></use></g><g data-mml-node="mi" transform="translate(20398.8, 0)"><use xlink:href="#MJX-TEX-I-1D452"></use></g></g></g></svg></mjx-container> 计算得到相应的值。</p>
<p><code>rolloutRolling</code> 为处理滚动更新的方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rolloutRolling implements the logic for rolling a new replica set.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">rolloutRolling</span><span class="params">(d *apps.Deployment, rsList []*apps.ReplicaSet)</span> <span class="title">error</span></span> {</span><br><span class="line">	newRS, oldRSs, err := dc.getAllReplicaSetsAndSyncRevision(d, rsList, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	allRSs := <span class="built_in">append</span>(oldRSs, newRS)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scale up, if we can.</span></span><br><span class="line">	scaledUp, err := dc.reconcileNewReplicaSet(allRSs, newRS, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> scaledUp {</span><br><span class="line">		<span class="comment">// Update DeploymentStatus</span></span><br><span class="line">		<span class="keyword">return</span> dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scale down, if we can.</span></span><br><span class="line">	scaledDown, err := dc.reconcileOldReplicaSets(allRSs, controller.FilterActiveReplicaSets(oldRSs), newRS, d)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> scaledDown {</span><br><span class="line">		<span class="comment">// Update DeploymentStatus</span></span><br><span class="line">		<span class="keyword">return</span> dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> deploymentutil.DeploymentComplete(d, &amp;d.Status) {</span><br><span class="line">		<span class="keyword">if</span> err := dc.cleanupDeployment(oldRSs, d); err != <span class="literal">nil</span> {</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sync deployment status</span></span><br><span class="line">	<span class="keyword">return</span> dc.syncRolloutStatus(allRSs, newRS, d)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，获取 Deployment 持有的全部 ReplicaSet 的资源；</li>
<li>调用 <code>reconcileNewReplicaSet</code> 调节新的 ReplicaSet 的副本数，创建新的 Pod 并保证额外的副本数量不超过 <code>maxSurge</code>;</li>
<li>调用 <code>reconcileOldReplicaSets</code> 调节历史 ReplicaSet 的副本数，删除旧的 Pod 并保证不可用的部分不超过 <code>maxUnavailable</code>;</li>
<li>删除无用的 ReplicaSet 并更新 Deployment 的状态；</li>
</ol>
<p>注意，在滚动更新过程中，Kubernetes 不是一次性就切换到期望的状态，即「目标副本数」，而是先启动新的 ReplicaSet 及一部分 Pod，然后删除历史 ReplicaSet 中的部分；如此往复，最终达到集群期望的状态。</p>
<p>当使用 <code>reconcileNewReplicaSet</code> 对新 ReplicaSet 进行调节时，如果发现新 ReplicaSet 中副本数满足期望则直接返回，在超过期望时则缩容。：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">reconcileNewReplicaSet</span><span class="params">(allRSs []*apps.ReplicaSet, newRS *apps.ReplicaSet, deployment *apps.Deployment)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> {</span><br><span class="line">	<span class="keyword">if</span> *(newRS.Spec.Replicas) == *(deployment.Spec.Replicas) {</span><br><span class="line">		<span class="comment">// Scaling not required.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> *(newRS.Spec.Replicas) &gt; *(deployment.Spec.Replicas) {</span><br><span class="line">		<span class="comment">// Scale down.</span></span><br><span class="line">		scaled, _, err := dc.scaleReplicaSetAndRecordEvent(newRS, *(deployment.Spec.Replicas), deployment)</span><br><span class="line">		<span class="keyword">return</span> scaled, err</span><br><span class="line">	}</span><br><span class="line">	newReplicasCount, err := deploymentutil.NewRSNewReplicas(deployment, allRSs, newRS)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	}</span><br><span class="line">	scaled, _, err := dc.scaleReplicaSetAndRecordEvent(newRS, newReplicasCount, deployment)</span><br><span class="line">	<span class="keyword">return</span> scaled, err</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<p>如果 ReplicaSet 的数量不够则调用 <code>NewRSNewReplicas</code> 计算新的副本个数，计算过程为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">currentPodCount := GetReplicaCountForReplicaSets(allRSs)</span><br><span class="line">maxTotalPods := *(deployment.Spec.Replicas) + <span class="keyword">int32</span>(maxSurge)</span><br><span class="line"><span class="comment">// Scale up.</span></span><br><span class="line">scaleUpCount := maxTotalPods - currentPodCount</span><br><span class="line"><span class="comment">// Do not exceed the number of desired replicas.</span></span><br><span class="line">scaleUpCount = Min(<span class="keyword">int</span>(scaleUpCount), <span class="keyword">int</span>(*(deployment.Spec.Replicas)-*(newRS.Spec.Replicas))))</span><br><span class="line"><span class="keyword">return</span> *(newRS.Spec.Replicas) + scaleUpCount</span><br></pre></td></tr></table></figure>

<p>该过程中需要考虑 Deployment 期望的副本数、当前可用的副本数记忆新的 RS 持有的副本数，此外还有最大最小值的限制。</p>
<p>另一个滚动更新中使用的方法 <code>reconcileOldReplicaSets</code> 主要作用是对历史 ReplicaSet 对象持有的副本数量进行缩容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dc *DeploymentController)</span> <span class="title">reconcileOldReplicaSets</span><span class="params">(allRSs []*apps.ReplicaSet, oldRSs []*apps.ReplicaSet, newRS *apps.ReplicaSet, deployment *apps.Deployment)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> {</span><br><span class="line">	oldPodsCount := deploymentutil.GetReplicaCountForReplicaSets(oldRSs)</span><br><span class="line">	<span class="keyword">if</span> oldPodsCount == <span class="number">0</span> {</span><br><span class="line">		<span class="comment">// Can't scale down further</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	allPodsCount := deploymentutil.GetReplicaCountForReplicaSets(allRSs)</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"New replica set %s/%s has %d available pods."</span>, newRS.Namespace, newRS.Name, newRS.Status.AvailableReplicas)</span><br><span class="line">	maxUnavailable := deploymentutil.MaxUnavailable(*deployment)</span><br><span class="line">	minAvailable := *(deployment.Spec.Replicas) - maxUnavailable</span><br><span class="line">	newRSUnavailablePodCount := *(newRS.Spec.Replicas) - newRS.Status.AvailableReplicas</span><br><span class="line">	maxScaledDown := allPodsCount - minAvailable - newRSUnavailablePodCount</span><br><span class="line">	<span class="keyword">if</span> maxScaledDown &lt;= <span class="number">0</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">	oldRSs, cleanupCount, err := dc.cleanupUnhealthyReplicas(oldRSs, deployment, maxScaledDown)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Cleaned up unhealthy replicas from old RSes by %d"</span>, cleanupCount)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Scale down old replica sets, need check maxUnavailable to ensure we can scale down</span></span><br><span class="line">	allRSs = <span class="built_in">append</span>(oldRSs, newRS)</span><br><span class="line">	scaledDownCount, err := dc.scaleDownOldReplicaSetsForRollingUpdate(allRSs, oldRSs, deployment)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">	}</span><br><span class="line">	klog.V(<span class="number">4</span>).Infof(<span class="string">"Scaled down old RSes of deployment %s by %d"</span>, deployment.Name, scaledDownCount)</span><br><span class="line"></span><br><span class="line">	totalScaledDown := cleanupCount + scaledDownCount</span><br><span class="line">	<span class="keyword">return</span> totalScaledDown &gt; <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<ol>
<li>计算历史 ReplicaSet 持有的副本总数；</li>
<li>计算全部 ReplicaSet 持有的副本总数；</li>
<li>根据 Deployment 期望的副本数、最大不可用的副本数以及新的 ReplicaSet 中不可用的 Pod 数量计算最大缩容个副本个数；</li>
<li>利用 <code>cleanupUnhealthyReplicas</code> 清理 ReplicaSet 中处于不健康状态的副本；</li>
<li>利用 <code>scaleDownOldReplicaSetsForRollingUpdate</code> 对历史 ReplicaSet 中的副本进行缩容；</li>
</ol>
<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>Kubernetes 中的每一个 Deployment 资源都包含 <code>revision</code> 概念，版本的使用可以让我们在更新不符合预期是及时通过 Deployment 的版本对其进行回滚。当我们更新 Deployment 时，之前 Deployment 持有的 ReplicaSet 会被清理。Deployment 通过规格中的 <code>revisionHistoryLimit</code> 字段配置最多保留的 ReplicaSet 数量，及多少个版本，这些 ReplicaSet 并不会被删除，它们只是不持有任何的 Pod 副本。</p>
<p>保留这些资源能够方便 Deployment 进行回滚，回滚荣国客户端调用 <code>rollout undo</code> 命令实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployment.v1.apps/nginx-deployment</span><br><span class="line">deployment.apps/nginx-deployment</span><br></pre></td></tr></table></figure>

<p>上述命令没有指定版本号，所以默认回滚到上一个版本。如果在回滚时指定版本，那么 Kubernetes 就会根据传入的版本查找历史的 ReplicaSet 资源，并触发一个资源更新请求.</p>
<p>回滚对于 Kubernetes 来说与更新操作没有区别，在每次更新时都会根据模板在历史 ReplicaSet 中查询是否有相同的 ReplicaSet 存在。如果存在规格完全相同的 ReplicaSet，就会保留这个 ReplicaSet 历史上使用的版本号并对该 ReplicaSet 重新扩容并对正在工作的 ReplicaSet 进行缩容以实现期望状态。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如果用户在 Kubernetes 中删除了一个 Deployment 资源，那么 Deployment 持有的 ReplicaSet 以及 ReplicaSet 持有的副本都会被 Kubernetes 中的垃圾收集器删除。</p>
<p>由于和当前 Deployment 有关的 ReplicaSet 历史和最新版本都会被删除，所以对应的 Pod 副本也都会随之被删除，这些字段都是通过 <code>metadata.ownerReference</code> 字段关联。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了 Deployment 这个在 Kubernetes 中最常使用的编排控制的实现和工作原理。</p>
<p>Deployment 实际上是一个两层控制器。首先它通过 ReplicaSet 的个数描述应用的版本；然后通过 ReplicaSet 的属性，保证 Pod 的数量。</p>
<blockquote>
<p>Deployment 控制 ReplicaSet（版本），ReplicaSet 控制 Pod（副本数）。</p>
</blockquote>
<p>Deployment 的设计实际上代替了对应用的抽象，是我们可以使用该 Deployment 来描述应用。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener">Kubernetes — Deployment</a></li>
<li><a href="https://time.geekbang.org/column/article/40906" target="_blank" rel="noopener">极客时间 — 深入剖析 Kubernetes</a></li>
<li><a href="https://draveness.me/kubernetes-deployment/" target="_blank" rel="noopener">详解 Kubernetes Deployment 的实现原理</a></li>
</ol>
<svg style="display: none" id="MJX-SVG-global-cache"><defs><path id="MJX-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path><path id="MJX-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path><path id="MJX-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-I-1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path><path id="MJX-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-TEX-I-1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path><path id="MJX-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-TEX-N-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path><path id="MJX-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path><path id="MJX-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path><path id="MJX-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path><path id="MJX-TEX-S3-28" d="M701 -940Q701 -943 695 -949H664Q662 -947 636 -922T591 -879T537 -818T475 -737T412 -636T350 -511T295 -362T250 -186T221 17T209 251Q209 962 573 1361Q596 1386 616 1405T649 1437T664 1450H695Q701 1444 701 1441Q701 1436 681 1415T629 1356T557 1261T476 1118T400 927T340 675T308 359Q306 321 306 250Q306 -139 400 -430T690 -924Q701 -936 701 -940Z"></path><path id="MJX-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path><path id="MJX-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-TEX-I-1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-TEX-I-1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path><path id="MJX-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-TEX-S3-29" d="M34 1438Q34 1446 37 1448T50 1450H56H71Q73 1448 99 1423T144 1380T198 1319T260 1238T323 1137T385 1013T440 864T485 688T514 485T526 251Q526 134 519 53Q472 -519 162 -860Q139 -885 119 -904T86 -936T71 -949H56Q43 -949 39 -947T34 -937Q88 -883 140 -813Q428 -430 428 251Q428 453 402 628T338 922T245 1146T145 1309T46 1425Q44 1427 42 1429T39 1433T36 1436L34 1438Z"></path><path id="MJX-TEX-I-1D448" d="M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z"></path><path id="MJX-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path></defs></svg>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Kubernetes 控制器模式分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 18:12:37" itemprop="dateCreated datePublished" datetime="2020-06-14T18:12:37+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/14/Kubernetes-控制器模式分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是“控制器模型“"><a href="#什么是“控制器模型“" class="headerlink" title="什么是“控制器模型“"></a>什么是“控制器模型“</h2><p>在 Kubernetes 中，Pod 是最小的 API 对象，是原子调度单位。Pod 通过对“容器”这个概念的进一步封装和抽象，添加更多属性和字段，使得描述及调度应用更加容易。而完成对 Pod 的调度和操作的逻辑就由控制器（Controller）实现。</p>
<p>控制器模型能够统一地实现对各种不同的对象或者资源的编排操作，保证对象和实际状态与对象的期望状态相同。对象的实际状态即直接访问 Kubernetes 的 ApiServer 得到的结果，而期望状态则来自于用户向集群提交的 Yaml 文件。以一个简单的部署了 Nginx 的 Deployment 控制器对象为例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:stable</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>这个 Deployment 确保携带了 <code>app=nginx</code> 标签的 Pod 个数永远等于 <code>spec.replicas</code> 指定的个数，即 2 个。那么，当集群中携带了 <code>app=nginx</code> 标签的 Pod 个数大于 2 的时候，控制器会删除多余的 Pod；反之，则会新建 Pod。</p>
<p>控制器模型的遵循 Kubernetes 中的一个通用编排模式：控制循环（control loop）。对于该 Deployment 我们可以用一段伪代码来描述这个控制循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    actualState := getActualStateOfDeployment(<span class="string">"nginx"</span>)</span><br><span class="line">    expectedState := getExpectedStateOfDeployment(<span class="string">"nginx"</span>)</span><br><span class="line">    <span class="keyword">if</span> actualState == expectedState &#123;</span><br><span class="line">        <span class="comment">// 什么都不做</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行编排动作，将实际状态调整为期望状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的伪代码中：</p>
<ol>
<li>Deployment 控制器从 Etcd 中查询所有携带了 <code>app=nginx</code> 标签的 Pod，并计数得到实际状态；</li>
<li>根据 <code>spec.replicas</code> 得到期望状态；</li>
<li>Deployment 控制器根据比较两个状态的结果确定应该创建还是删除已有的 Pod。</li>
</ol>
<p>像 Deployment 这种控制器的设计原理，实现了“一种对象控制另一种对象”。控制器对象本身负责定义被管理对象的期望状态，而被控制对象的定义则来自一个模板，即 PodTemplate。所以类似 Deployment 这样一个控制器，由上半部分包含了控制器定义及期望状态，加上下半部分被控制对象的模板组成。</p>
<img src="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/controller-structure.png" class="">

<p>Kubernetes 中通过使用控制器模型这个统一的编排框架，不同的控制器可以在具体的过程中设计不同的业务逻辑，达到不同的编排效果。</p>
<h3 id="“控制器模型“与“事件驱动模型“的区别"><a href="#“控制器模型“与“事件驱动模型“的区别" class="headerlink" title="“控制器模型“与“事件驱动模型“的区别"></a>“控制器模型“与“事件驱动模型“的区别</h3><p>笔者在接触 Kubernetes 之前，在业务中维持对象的状态一直采用的是“事件驱动模型”，即通过回调或者消息队列得到指令或事件后，执行一系列预先定义好的逻辑。这时，业务系统“被动”地等到具体事件的到来，并触发相应的操作。由于事件往往是一次性的，这导致在执行指令失败的情况下比较难以处理，通常是进行日志保存、报警及回滚操作。 </p>
<p>而在 Kubernetes 中，控制器模型是持续、“主动”地观察目标对象的状态，不断尝试，最终实现实际状态与期望状态的一致。</p>
<h2 id="声明式-API"><a href="#声明式-API" class="headerlink" title="声明式 API"></a>声明式 API</h2><p>在 Kubernetes 项目中，存在一个叫做 <code>kube-controller-manager</code> 的组件。这个组件，就是一系列控制器的集合。在 Kubernetes 项目的 <code>pkg/controller</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -d */</span><br><span class="line">apis/                   cronjob/                endpoint/               job/                    podautoscaler/          resourcequota/          testutil/               volume/</span><br><span class="line">bootstrap/              daemon/                 endpointslice/          namespace/              podgc/                  service/                ttl/</span><br><span class="line">certificates/           deployment/             garbagecollector/       nodeipam/               replicaset/             serviceaccount/ </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个目录的每个控制器都遵循通用的编排模式：控制循环（control loop），Deployment Controller 就是其中之一。</p>
<p>使用遵循“控制器模型”实现的各类 Controller，同 Kubernetes 里 API 对象的 CRUD 接口进行协作，完成用户业务逻辑的编写，也成为了 Kubernetes 的编程范式，实现了 Kubernetes 的声明式 API。</p>
<p>为了创建 Kubernetes 中的 API 对象，无一例外，用户都需要编写一个对应的 Yaml 文件交给 Kubernetes，这正是声明式 API 的一个要素。</p>
<p>但是声明式 API 并不仅仅意味着用 Yaml 文件代替命令行操作。例如，我们通过 <code>kubectl create</code> 命令创建 Deployment：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx.yaml</span><br></pre></td></tr></table></figure>

<p>通过 <code>kubectl set image</code> 命令更新容器镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment&#x2F;nginx-deployment nginx&#x3D;nginx:1.16.1</span><br></pre></td></tr></table></figure>

<p>等等操作并不是声明式 API，这些应该被称为“命令式配置文件操作”。真正的声明式 API 是 <code>kubectl apply</code> 命令。用户可以使用 <code>kubectl apply</code> 创建 Deployment，之后修改 Yaml 并再次调用该命令将修改提交到 Kubernetes 的 ApiServer。<code>kubectl create</code> 及 <code>kubectl replace</code> 的执行过程，是使用新的 Yaml 文件中的 API 对象去<strong>替换</strong>原有对象；而 <code>kubectl apply</code> 则是执行了一个对原有 API 对象的 <strong>PATCH 操作</strong>。</p>
<p>更进一步，kube-apiserver 在响应命令式请求（如，<code>kubectl replace</code>）时，一次只能处理一个写请求，否则可能产生冲突。而对于声明式请求（如，<code>kubectl apply</code>），一次能处理多个写操作，并且具备 Merge 能力。</p>
<p>所谓“声明式”，指的就是用户只需要提交一个定义好的 API 对象来“声明”期望的状态；“声明式” API 允许有多个 API 写端，以 PATCH 方式对 API 对象进行修改，而无需关心本地原始 Yaml 文件的内容；最后，Kubernetes 可以完成对实际状态和期望状态的调谐过程。</p>
<h3 id="声明式-API-的设计"><a href="#声明式-API-的设计" class="headerlink" title="声明式 API 的设计"></a>声明式 API 的设计</h3><p>为了回答当一个 Yaml 文件被提交给 Kubernetes 后，它是如何创建出一个 API 对象的，我们需要知道在 Kubernetes 中，一个 API 对象在 Etcd 中的完整资源路径，是由 Group（API 组）、Version(API 版本) 和 Resource（API 资源类型）组成的。</p>
<img src="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/apiGroupVersion.png" class="">

<p>可以看到 Kubernetes 中的 API 对象的组织方式是层层递进的。以 Deployment 为例，那么 Yaml 的开始部分的写法为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>在这个 Yaml 文件中，组（Group）为 <code>apps</code>，版本（Version）为 <code>v1</code>，资源类型（Resource）为 <code>Deployment</code>。当提交这个 Yaml 文件之后，Kubernetes 将会把这个 Yaml 文件里面描述的内容转换成集群内一个 Deployment 对象。</p>
<p>为了找到 API 对象的定义，首先 Kubernetes 会匹配 API 对象的组。对于核心 API 对象如 Pod、Node 等不需要 Group。所以对于核心对象，Kubernetes 会直接在 <code>/api</code> 这个层级下进行下一步匹配。而 Deployment 等非核心 API，Kubernetes 就需要在 <code>/apps</code> 下查找对应的 Group。</p>
<p>然后，Kubernetes 进一步匹配 API 对象的版本。对于 Deployment 对象来说，Kubernetes 在 <code>/apps</code> 这个 Group 下，匹配到的版本就是 <code>v1</code>。API 版本话管理保证了向后兼容。</p>
<p>最后 Kubernetes 匹配 API 对象的资源类型。最后，Kubernetes 就得到，要创建的对象是 <code>/apps/v1/</code> 下的 Deployment 对象。</p>
<h3 id="自定义资源类型（CustomResourceDefinition-CRD）"><a href="#自定义资源类型（CustomResourceDefinition-CRD）" class="headerlink" title="自定义资源类型（CustomResourceDefinition, CRD）"></a>自定义资源类型（CustomResourceDefinition, CRD）</h3><p>在 Kubernetes 中除了预定义的 API 对象外，用户可以利用 CRD 来向 kube-apiserver 中新增自定义 API 资源类型。例如，要在集群中添加一个描述网络资源的自定义 API 对象 Network，用以描述期望的网络参数。</p>
<p>这个 Network 对象的 Yaml 文件可以如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">sample.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Network</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sample-net</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">cidr:</span> <span class="string">"192.168.0.0/16"</span></span><br><span class="line">    <span class="attr">gatewar:</span> <span class="string">"192.168.0.1"</span></span><br></pre></td></tr></table></figure>

<p>那么，Kubernetes 应该如何知道该 API 对象 <code>sample.k8s.io/v1/netword</code> 的存在呢？其实，该 Yaml 文件是一个自定义 API 资源，也叫 Custom Resource（CR）。为了让 Kubernetes 知道这个 CR，就需要该 CR 的定义是什么，即CustomResourceDefinition（CRD）。</p>
<p>一个 CRD 的定义 Yaml 为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">networks.sample.k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">sample.k8s.io</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">names:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Network</span></span><br><span class="line">    <span class="attr">plural:</span> <span class="string">networks</span></span><br><span class="line">  <span class="attr">scope:</span> <span class="string">Namespaced</span></span><br></pre></td></tr></table></figure>

<p>文件中，指定了 “group: sample.k8s.io” 及 “version: v1”，也指定了这个 CR 的资源类型叫做 Network，复数是 networks。也声明了它的 scope 是 Namespaced，即这个 Network 是一个属于命名空间的对象。</p>
<p>通过执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f network.yaml</span><br></pre></td></tr></table></figure>

<p>即可在集群中创建 Network 对象的 CRD。</p>
<h3 id="自定义控制器"><a href="#自定义控制器" class="headerlink" title="自定义控制器"></a>自定义控制器</h3><p>“声明式 API” 并不像 “命令式 API” 那样有着明显的执行逻辑，这就使得集群声明式 API 的业务功能实现，通常需要控制器模式来监听 API 对象的变化，然后以此来决定实际需要执行的具体工作。</p>
<p>要实现一个自定义控制器，需要：</p>
<ol>
<li>根据 kubeconfig 或者以 InClusterCofig 初始化用于访问集群 API 对象的 <code>kubeClient</code>，及用于访问自定义对象的自定义 Client，如 <code>networkClient</code>;</li>
<li>利用自定义对象的 Client 初始化对应的 <code>InformorerFactory</code>, 并使用它生成自定义对象的 Informer， 传给 controller；</li>
<li>启动 informer 及 controller；</li>
</ol>
<p>在 Kubernetes 中，一个自定义控制器的工作原理，可以用下图表示。</p>
<img src="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/controller.png" class="" title="自定义控制器的工作流程示意图">

<p>控制器的第一件事，是从 Kubernetes 的 APIServer 里获取关心的对象。这个操作，依赖 Informer 代码库完成。Informer 与 API 对象是一一对应的。</p>
<p>在创建 InformerFactory 的时候需要传递一个 client，实际上，Informer 正式利用这个 Client，与 APIServer 建立的连接。不过真正维护这个连接的，则是  Informer 所使用的 Reflector 包。</p>
<p>Reflector 使用被称为 <strong>ListAndWatch</strong> 的方法，来获取并监听目标对象的实例变化。</p>
<p>在 ListAndWatch 机制下，一旦 APIServer 端有新的对象实例被创建、删除或更新，Reflector 都会收到事件通知。这时，该事件及它对应的 API 对象这个组合，就被称为增量（Delta），它会被放入一个 Delta FIFO Queue 中。</p>
<p>另一方面，Informer 会不断从这个 Delta FIFO Queue 里读取（Pop）增量。每拿到一个增量，Informer 就会判断这个增量里的事件类型，然后创建或者更新本地对象的缓存。这个缓存，在 Kubernetes 中一般被叫做 Store。</p>
<p>例如，如果该事件类型是 Added，那么 Informer 就会通过一个叫做 Indexer 的库把这个增量里面的 API 对象保存在本地缓存中，并为它创建索引。相反，如果增量的事件是 Deleted，那么 Informer 就会从本地缓存中删除这个对象。</p>
<p>这个同步本地缓存的工作，是 Informer 的第一个职责，也是它最重要的职责。</p>
<p>Informer 的第二个职责，就是根据这些事件的类型，触发事先注册好的 ResourceEventHandler。这些 Handler 需要在创建控制器的时候注册给它对应的 Informer。</p>
<p>一个控制器的定义可以如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  kubeclientset kubernetes.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">  networkclientset clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">  networkInformer informers.NetworkInformer)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    controller := &amp;Controller&#123;</span><br><span class="line">        kubeclientset:    kubeclientset,</span><br><span class="line">        networkclientset: networkclientset,</span><br><span class="line">        networksLister:   networkInformer.Lister(),</span><br><span class="line">        networksSynced:   networkInformer.Informer().HasSynced,</span><br><span class="line">        workqueue:        workqueue.NewNamedRateLimitingQueue(...,  <span class="string">"Networks"</span>),</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    networkInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">    AddFunc: controller.enqueueNetwork,</span><br><span class="line">    UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        oldNetwork := old.(*samplecrdv1.Network)</span><br><span class="line">        newNetwork := <span class="built_in">new</span>.(*samplecrdv1.Network)</span><br><span class="line">        <span class="keyword">if</span> oldNetwork.ResourceVersion == newNetwork.ResourceVersion &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        controller.enqueueNetwork(<span class="built_in">new</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    DeleteFunc: controller.enqueueNetworkForDelete,</span><br><span class="line"> <span class="keyword">return</span> controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在这个自定义控制器里面，还设置了一个工作队列（work queue），它正是图中间的 WorkQueue。这个工作队列的作用是，负责同步 Informer 和控制循环之间的数据。</p>
<p>然后，为 Informer 添加了三个 Handler，分别对应 API 对象的添加、更新和删除事件，而具体的处理操作则是将事件对应的 API 对象加入到工作队列中。实例入队列的不是 API 对象本身，而是它们的 key，及 <code>{namespace}/{name}</code>。</p>
<p>而控制循环，则是不断从工作队列里拿到 Key，然后开始执行真正的控制循环。</p>
<p>所以，Informer 其实就是一个带有本地缓存和索引机制的，可以注册 EventHandler 的 client。它是自定义控制器跟 APIServer 进行数据同步的重要组件。Informer 通过 ListAndWatch 方法，将 APIServer 中的 API 对象缓存在了本地，并负责更新和维护这个缓存。</p>
<p>ListAndWatch 首先通过 List API 获取所有最新版本的 API 对象；然后再通过 Watch API 实时更新本地缓存，并且调用这些事件对应的 EventHandler。</p>
<p>此外，每经过 resyncPeriod 指定的时间，Informer 维护的本地缓存，都会使用最近一次 List 返回的结果强制更新一次，从而保证缓存的有效性。这个强制更新的操作叫做 <code>resync</code>。</p>
<p>需要注意，这个定时 resync 的操作，也会触发 informer 的“更新”事件。但是此时，“更新”事件对应的 Network 实际上没有变化，这种情况下，Informer 不需要对这个更新事件再做进一步处理。</p>
<p>以上，就是 Informer 的工作原理了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>控制器模型能够统一地实现对各种不同的对象或者资源的编排操作，保证对象和实际状态与对象的期望状态相同。对象的实际状态即直接访问 Kubernetes 的 ApiServer 得到的结果，而期望状态则来自于用户向集群提交的 Yaml 文件。</p>
<p>所谓“声明式”，指的就是用户只需要提交一个定义好的 API 对象来“声明”期望的状态；“声明式” API 允许有多个 API 写端，以 PATCH 方式对 API 对象进行修改，而无需关心本地原始 Yaml 文件的内容；最后，Kubernetes 可以完成对实际状态和期望状态的调谐过程。</p>
<p>Informer 是一个自带缓存和索引机制，可以触发 Handler 的客户端，缓存被称为 Store，索引被称为 Index。<br>Informer 使用 Reflector 报，通过 ListAndWatch 机制获取并监听 API 对象变化。</p>
<p>Informer 和 Reflector 之间使用一个增量先进先出队列来协同，而Informer 与控制循环之间则使用一个工作队列来协同。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://time.geekbang.org/column/article/40583" target="_blank" rel="noopener">谈谈控制器模型 — 极客时间</a></li>
<li><a href="https://time.geekbang.org/column/article/41876" target="_blank" rel="noopener">声明式 API — 极客时间</a></li>
<li><a href="https://time.geekbang.org/column/article/42076" target="_blank" rel="noopener">编写自定义控制器 — 极客时间</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2020/05/16/Kubernetes-Pod-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/16/Kubernetes-Pod-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index/" class="post-title-link" itemprop="url">Kubernetes Pod 的设计与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-16 12:26:00" itemprop="dateCreated datePublished" datetime="2020-05-16T12:26:00+08:00">2020-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/16/Kubernetes-Pod-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/16/Kubernetes-Pod-的设计与实现/index/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么需要-Pod"><a href="#为什么需要-Pod" class="headerlink" title="为什么需要 Pod"></a>为什么需要 Pod</h2><p>Pod 是 Kubernetes 项目中最小的 API 对象；是 Kubernetes 项目的原子调度单位。但是，为什么需要 Pod 呢？</p>
<p>在学习容器本质后，我们都知道：</p>
<blockquote>
<p>Namespace 做隔离，Cgroups 做限制，rootfs 作为文件系统。</p>
</blockquote>
<p>Pod 存在的必要性是什么呢？</p>
<p>Pod 存在的主要目的为：1. 抽象进程组概念 2. 引入“容器设计模式”</p>
<p>Pod 对“进程组”概念进行了抽象。如果说容器的本质是云计算系统中的进程，那么 Kubernetes 就相当于云计算的操作系统。在一个真正的操作系统里，如果在终端输入 <code>pstree</code> 命令，就可以以树形结构展示系统中的进程。这时我们可以发现进程通常并不是独自运行，而是被有组织地组合在一起。如用于处理系统日志中的 rsyslogd，与内核日志模块 imklog 同属于一个进程组，他们协作完成日志的收集。Kubernetes 的很多设计思想来源与 Google 内部系统 Borg，在 Borg 的实践过程中，工程师就发现应用之间通常存在类似于“进程组”的关系，它们密切协作，必须部署在同一台机器上。如果存在了“组”的概念，那么就能很好地处理这样的运维关系，Kubernetes 按照 Pod 的资源需求进行计算进行资源调度。所以，Kubernetes 使用 Pod 将“进程组”的概念映射到了容器技术中，使其成为云计算“操作系统”里面的“一等公民”。</p>
<p>Pod 引入了“容器设计模式”。Pod 本身仅仅是一个逻辑概念。Kubernetes 仍然是使用 Namespace 和 Cgroups 实现资源的隔离和限制，而并不存在一个「Pod 边界」。Pod 里的所有容器，共享同一个 Network Namespace，并且能够声明共享同一个 Volume。如果共享网络配置及 Volume 是通过类似运行 docker run 命令来实现，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net&#x3D;other --volumes-from&#x3D;other --name&#x3D;this ...</span><br></pre></td></tr></table></figure>

<p>那么一个容器就必须比另外一个容器先启动，这样容器间就成为了拓扑关系，而不是对等关系了。所以，在 Kubernetes 中，Pod 使用了一个中间容器 Infra，Infra 一定是在 Pod 中首先被创建的容器，而其他容器则通过 Join Network Namespace 的方式与 Infra 容器关联在一起。</p>
<p><img src="/images/2020-05-16/pod.png" alt="Pod"></p>
<p>Infra 容器使用一个特殊的镜像，叫做：<code>k8s.gcr.io/pause</code>，它占用极少的资源。Infra 容器被创建后会初始化 Network Namespace，之后用户容器就可以加入到 Infra 容器中了。所以对于 Pod 中的容器 A 和 B 来说，它们：</p>
<ol>
<li>能够直接使用 localhost 通信；</li>
<li>看到与 Infra 容器相同的网络设备</li>
<li>Pod 只有一个 IP 地址，也就是该 Pod 的 Network Namespace 对应的 IP 地址；</li>
<li>所有网络资源均一个 Pod 一份，被 Pod 中所有容器共享；</li>
<li>Pod 的生命周期仅与 Infra 容器一致，与用户容器无关。</li>
</ol>
<p>对于同一个 Pod 中的用户来说，它们的进出流量可以认为都是通过 Infra 容器完成的。所以当进行网络插件开发时，应该主要考虑如何配置 Pod 的 Network Namespace，而不是去配置用户容器。</p>
<p>有了使用 Infra 容器的设置后，共享的 Volume 也就成为了 Pod 层级的字段。这样 Volume 对应的宿主机目录对于 Pod 来说只有一个，Pod 中的容器只要声明挂载这个 Volume，就一定可以共享这个 Volume 对应的宿主机目录。</p>
<p><img src="/images/2020-05-16/pod_share_volume.png" alt="pod-share-volumes"></p>
<p>Pod 的设计希望当用户想在一个容器里面运行多个功能不相关，但是关系紧密的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。</p>
<p>所以，当进行业务「上云」的时候，应该把整个虚拟机想象成一个 Pod，把这些进程分别做成容器镜像，把存在顺序关系的容器定义为 Init Container。这样就实现了更加合理的，容耦合的容器编排方法。</p>
<blockquote>
<p>Pod 提供的是一种编排思想，而不是具体的技术方案。</p>
</blockquote>
<h2 id="Pod-对象的基本概念"><a href="#Pod-对象的基本概念" class="headerlink" title="Pod 对象的基本概念"></a>Pod 对象的基本概念</h2><p>Pod，而不是容器，是 Kubernetes 项目中的最小编排单位。如果将这个思想落实到 API 和数据接口定义上，那么容器就成为了 Pod 属性中一个普通的字段。那么，哪些属性应该放到 Pod 中，哪些应该放到 Container 中呢？</p>
<p>Pod 扮演了传统环境中的「虚拟机」角色，容器扮演了进程。理解了 Pod 的设计原则之后，我们就可以明白，在设计 Pod 数据结构时：</p>
<ol>
<li>凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的；</li>
<li>凡是跟容器的 Linux Namespace 相关的属性，一定是 Pod 级别的；</li>
<li>凡是 Pod 中容器要共享宿主机的 Namespace，一定是 Pod 级别的；</li>
</ol>
<p>应用调度、网络、存储及安全相关的属性的共同特征是，它们描述“机器”这个整体，而不是里面的“程序”。</p>
<ul>
<li><strong>NodeSelector</strong>：供用户将 Pod 与 Node 进行绑定。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure>

<p>这样的配置意味着 Pod 永远只能运行在携带了 <code>disktype:ssd</code> 标签（Label）的节点上；否则将会调度失败。</p>
<ul>
<li><p><strong>NodeName</strong>:：该字段一般由调度器负责设置，因为一旦 Pod 中的该字段被赋值，Kubernetes 就认为这个 Pod 已经经过了调度，调度的结果就是赋值的节点名字。但是用户可以设置它来“骗过”调度器，一般在测试和调试时这样做。</p>
</li>
<li><p><strong>NodeName</strong>：定义了 Pod 的 hosts 文件（/etc/hosts）中的内容。</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostAliases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">"10.1.2.3"</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"foo.remote"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"bar.remote"</span></span><br></pre></td></tr></table></figure>

<p>当 Pod 启动后，生成的 /etc/hosts 文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;hosts</span><br><span class="line"># Kubernetes-managed hosts file.</span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">...</span><br><span class="line">10.244.135.10 hostaliases-pod</span><br><span class="line">10.1.2.3 foo.remote</span><br><span class="line">10.1.2.3 bar.remote</span><br></pre></td></tr></table></figure>

<p>Linux Namespace 相关的属性，也一定是 Pod 级别的。因为 Pod 的设计原则就是希望其中的容器能够尽可能多地共享 Linux Namespace，仅保留必要的隔离和限制能力。这样 Pod 模拟出的效果会更加类似虚拟机中进程间的关系。</p>
<p>假如设置 <code>sharePrecessNamespace=true</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">shareProcessNamespace:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shell</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>就意味着 Pod 中的容器要共享 PID Namespace。之后，在 busybox 容器中运行 <code>ps aux</code>，就不仅仅能够看到 ps 命令本身，还能够看到 nginx 容器的进程以及 pause 进程。这就意味着，整个 Pod 里的每个容器的进程，对于所有容器来说都是可见的。</p>
<p>凡是 Pod 中的容器要共享宿主机的 Namespace，也一定是 Pod 级别的。比如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostIPC:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostPID:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shell</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这个 Pod 中我们定义了共享宿主机的 Network、IPC 和 PID Namespace。这就意味着，这个 Pod 里面的所有容器，会直接使用宿主机的网络、直接与宿主机进行 IPC 通信、看到宿主机里面正在运行的所有进程。</p>
<p>在 Pod 中，最重要的就是 <code>Containers</code> 了，另外，<code>Init Container</code> 也属于 Pod 对容器的定义，内容和 <code>Container</code> 完全相同，只是 <code>Init Container</code> 的声明周期会限于所有的 <code>Containers</code>，并且严格按照顺序执行。</p>
<p>Kubernetes 对 Container 的定义，与 Docker 相比差别不大，主要有：Image，Command，workingDir，Ports，及 volumeMounts。另外需要注意的有：</p>
<ul>
<li><p><strong>ImagePullPolicy</strong>：定义了镜像的拉取策略，默认值是 <code>Always</code>，即每次创建 Pod 时都重新拉取镜像；如果它的值被定义为 <code>Never</code> 或者 <code>IfNotPresent</code>，则意味着 Pod 永远不会主动拉取这个镜像，或者只有当宿主机上不存在该镜像时才拉取。</p>
</li>
<li><p><strong>Lifecycle</strong>：定义了 Container Lifecycle Hooks，也就是容器状态发生变化时触发的一系列“钩子”。</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/bin/sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"echo Hello from the postStart handler &gt; /usr/share/message"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/usr/sbin/nginx","-s","quit"]</span></span><br></pre></td></tr></table></figure>

<p>可以看到在 <code>Container</code> 中为 nginx 容器设置了 <code>postStart</code> 和 <code>preStop</code>，分别表示在容器启动后或者在容器被杀死前执行一个指定的操作。</p>
<p>Pod 生命周期的变化，主要体现在 Pod 的 <code>Status</code> 部分，这是它除了 <code>Metadata</code> 和 <code>Spec</code> 之外的第三重要的字段。其中，<code>pod.status.phase</code> 就是 Pod 的当前状态，它可能的情况有：</p>
<ol>
<li>Pending。表示 Pod 的 YAML 文件已经提交给了 Kubernetes，对象已经被创建被保存在了 Etcd 中。但是 Pod 中的有些容器因为某种原因而不能被顺利创建。</li>
<li>Running。表示 Pod 已经调度成功，其中包含的容器都已经创建成功，且至少有一个正在运行中。</li>
<li>Succeeded。表示 Pod 中所有的容器都已经正常运行完毕，并且已经退出了。这在 Job 对象中较常见。</li>
<li>Failed。表示 Pod 中至少有一个容器已不正常的状态（非 0 返回码）退出。</li>
<li>Unknown。表示一个异常状态，Pod 的状态不能持续地被 kubelet 汇报给 kube-apiserver，可能的原因是主从节点间的通信出现了问题。</li>
</ol>
<p>更进一步。Pod 的 Status 字段还可以再细分中一组 Conditions。细分的状态包括：PodScheduled、Ready、Initialized，以及 Unschedulable。它们主要用于描述造成当前 Status 的具体原因是什么。</p>
<h2 id="Pod-的实现原理"><a href="#Pod-的实现原理" class="headerlink" title="Pod 的实现原理"></a>Pod 的实现原理</h2><p>我们可以查看 Pod 数据结构的<a href="https://github.com/kubernetes/kubernetes/blob/4e8b56e6671893757d40e2001a3c615acebc13a2/staging/src/k8s.io/api/core/v1/types.go#L3549" target="_blank" rel="noopener">完整定义</a>，来进一步理解 Pod 的设计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pod is a collection of containers that can run on a host. This resource is created</span></span><br><span class="line"><span class="comment">// by clients and scheduled onto hosts.</span></span><br><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	<span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specification of the desired behavior of the pod.</span></span><br><span class="line">	<span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Spec PodSpec <span class="string">`json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Most recently observed status of the pod.</span></span><br><span class="line">	<span class="comment">// This data may not be up to date.</span></span><br><span class="line">	<span class="comment">// Populated by the system.</span></span><br><span class="line">	<span class="comment">// Read-only.</span></span><br><span class="line">	<span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Status PodStatus <span class="string">`json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Kubernetes 中任何一个 API 对象一样，Pod 首先也嵌入（embed）了 <code>TypeMeta</code> 和 <code>ObjectMeta</code> 属性。<code>TypeMeta</code> 中的 <code>apiVersion</code> 和 <code>kind</code> 描述了 API 组及资源类型，能够确定该对象应该由谁来处理。而 <code>metadata</code> 则为我们提供能够唯一识别对象的信息，包括集群中的 <code>namespace</code> 及在命名空间中唯一的 <code>name</code>，还有用于分类的 <code>labels</code> 字段及用于功能拓展的 <code>annotations</code> 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ObjectMeta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Namespace <span class="keyword">string</span></span><br><span class="line">	Labels <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	Annotations <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最重要的属性为 <a href="https://github.com/kubernetes/kubernetes/blob/4e8b56e6671893757d40e2001a3c615acebc13a2/staging/src/k8s.io/api/core/v1/types.go#L2842" target="_blank" rel="noopener">PodSpec</a> 的定义。它定义了 Pod 的期望状态，其中包含了大量本文中未介绍的属性。</p>
<p>Pod 的基本生命周期为，首先创建 Pod，之后进入健康检查状态，当 Kubernetes 确定 Pod 已经能够接受外部请求时，将流量打到新的 Pod 上并继续对外提供服务；如果 Pod 发生错误就触发重启机制。 </p>
<p>Pod 的在集群中的创建由 kubelet 完成，Pod 的创建过程的入口为 <a href="https://github.com/kubernetes/kubernetes/blob/4e8b56e6671893757d40e2001a3c615acebc13a2/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L647" target="_blank" rel="noopener">SyncPod 方法</a>。</p>
<p>创建 Pod 的流程基本可以分为 6 步：</p>
<ol>
<li>计算 Pod 中沙盒和容器的变更；</li>
<li>强制停止 Pod 中对应的沙盒；</li>
<li>强制停止所有不应该运行的容器；</li>
<li>为 Pod 创建新的沙盒；</li>
<li>创建 PodSpec 中指定的初始化容器；</li>
<li>依次创建 PodSpec 中指定的常规容器； </li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line">    podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line">    <span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		ref, _ := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">			m.purgeInitContainers(pod, podStatus)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">			m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, <span class="literal">nil</span>)			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	podSandboxID := podContainerChanges.SandboxID</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		podSandboxID, _, _ = m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line">	&#125;</span><br><span class="line">	podSandboxConfig, _ := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">		container := &amp;pod.Spec.Containers[idx]</span><br><span class="line">		msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Pod 的创建流程首先是计算 Pod规格和沙箱的变更，然后停止所有可能影响这一次创建或更新的容器，最后依次创建沙盒、初始化容器和常规容器。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://time.geekbang.org/column/intro/116" target="_blank" rel="noopener">深入剖析 Kubernetes — 极客时间</a></li>
<li><a href="https://draveness.me/kubernetes-pod/" target="_blank" rel="noopener">详解 Kubernetes 的实现原理</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">Pod — Kubernetes</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2019/12/22/concurrency-patterns-in-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/22/concurrency-patterns-in-go/" class="post-title-link" itemprop="url">Go 语言中的常用并发模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-22 10:34:23" itemprop="dateCreated datePublished" datetime="2019-12-22T10:34:23+08:00">2019-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming-language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019/12/22/concurrency-patterns-in-go/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/22/concurrency-patterns-in-go/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>正式工作半年来，公司项目以 Go 作为主要语言。由于有 C 语言基础，刚开始我感觉上手 Go 语言很容易，而且比 C 语言有更好的可读性，再加上「函数」变成了一等公民，函数式的写法也让部分功能的实现变得更加简练和易读。但是，我对 Go 语言的并发特性却一直理解不深，总觉得在处理并发任务的时候我的思路依然是使用 Java 的 <em>communicate by sharing memory</em>，而不是 Go 语言所提倡的 <em>share memory by communicating</em>。所以，近期阅读和实践了一些 Go 语言并发编程相关的书籍和资料，总结了 Go 语言中常用的并发编程模式，记录在这里。</p>
<h2 id="for-select-loop"><a href="#for-select-loop" class="headerlink" title="for-select-loop"></a>for-select-loop</h2><p><code>select</code> 组合多个 <code>channel</code> ，<code>channel</code> 组合多个 <code>goroutine</code>。<code>select</code> 是 Go 语言并发编程中最终的指令之一，我们可以在任何上下文，无论是函数、还是多个子系统，中将多个 <code>channel</code> 组合在一起，并加入如「取消」、「限时等待」和「默认值」等功能。最简单的例子就是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1, ch2 &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">// logic 1</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">    <span class="comment">// logic 2</span></span><br><span class="line"><span class="keyword">case</span> ch3&lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">    <span class="comment">// logic 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>switch</code> 不同的是，多个 <code>case</code> 不是同步判断是否满足条件，而是异步判断，如果所有 <code>case</code> 都不满足，那么 <code>select</code> 语句将一直阻塞。、</p>
<p><code>for-select-loop</code> 是 Go 语言中最常见的使用方法，可以被应用在多个场景中：</p>
<p>顺序写入变量到 <code>channel</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"str1"</span>, <span class="string">"str2"</span>, <span class="string">"str3"</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> strChan&lt;- str:</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无限循环执行任务直到被取消：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>并发编程中，错误处理非常困难。我们花费大量时间思考多个线程之间的内存共享和协调，但是忽略如何优雅地处理错误。Go 语言抛弃了在其他语言中常见的异常抛出机制，并提出开发者应该给予错误处理逻辑分支与正产流程相同的关注。在错误处理汇总最基本的问题是「谁应该处理错误？」。有时候，程序需要停止进一步沿着调用栈向上传递异常，而是处理异常。</p>
<p>在并发编程中，这个问题会变得更加复杂。因为 <code>goroutine</code> 是独立于它的父亲和兄弟 goroutine 执行的，很难确定应该如何处理错误。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">checkStatus := <span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, urls ...<span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    responses := <span class="built_in">make</span>(<span class="keyword">chan</span> *http.Response)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(responses)</span><br><span class="line">        <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">            resp, err := http.Get(url)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> responses &lt;- resp:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> responses</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(stop)</span><br><span class="line"></span><br><span class="line">urls := []<span class="keyword">string</span>&#123;<span class="string">"https://google.com"</span>, <span class="string">"https://host"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> response := <span class="keyword">range</span> checkStatus(stop, urls...) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Response: %v\n"</span>, response.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中发送 http 请求的 goroutine 没有办法将错误返回，只能打印错误信息防止将错误吞掉。所以，不应该使 goroutine 无法回传错误。更好的方式是注意点分离，并发的 goroutine 应该将错误信息传递给另外一个更够访问程序全部状态的组件，并正确处理错误。如我们可以封装返回值和错误信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error error</span><br><span class="line">    Response *http.Response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkStatus := <span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, urls ...<span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(results)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">            resp, err := http.Get(url)</span><br><span class="line">            result = Result&#123;Error: err, Response: resp&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> results &lt;- result:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(stop)</span><br><span class="line"></span><br><span class="line">urls := []<span class="keyword">string</span>&#123;<span class="string">"https://google.com"</span>, <span class="string">"https://host"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> checkStatus(stop, urls...) &#123;</span><br><span class="line">    <span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"error: %v"</span>, result.Error)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Response: %v\n"</span>, result.Response.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的关键在于我们将可能的结果和错误封装在一起，可能够表示 <code>checkStatus</code> 所能够产生的全部结果，而使我们的主流程可能决定应该处理错误情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/10/05/%E4%B8%AD%E5%A4%AE%E5%B8%9D%E5%9B%BD%E7%9A%84%E8%B4%A2%E6%94%BF%E5%AF%86%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/%E4%B8%AD%E5%A4%AE%E5%B8%9D%E5%9B%BD%E7%9A%84%E8%B4%A2%E6%94%BF%E5%AF%86%E7%A0%81/" class="post-title-link" itemprop="url">中央帝国的财政密码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 10:05:30" itemprop="dateCreated datePublished" datetime="2018-10-05T10:05:30+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/booknotes/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/10/05/%E4%B8%AD%E5%A4%AE%E5%B8%9D%E5%9B%BD%E7%9A%84%E8%B4%A2%E6%94%BF%E5%AF%86%E7%A0%81/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/05/中央帝国的财政密码/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/2018-10-05/cover.jpg" alt="中央帝国的财政密码"></p>
<p>因为对历史感兴趣，所以我希望从各个角度审视中国历史，所以选择到了这本⎡中央帝国的财政密码⎦。书的作者叫郭建龙，曾经是财政记者，多年的采访与资料收集使他能从财政的角度分析中国的现实。书的内容以分析中华帝国的历代的财政为主，却也通过回看历史来分析当前的中央经济改革。作者认为中国经济的三大底线是：国有企业不放弃、公有土地制度不触及、政府控制发钞权。我们通常认为这是社会主义的特征，是从马克思开始就决定要必须守住的三大基础。但是作者通过回看历史发现，其实，这所谓三大基础并非舶来品，而是中国历史上一直依赖的手段，中国古代的各个王朝已经频繁使用国有企业、公有土地制度、垄断货币发行的手段敛财，这些手段不是从外国学来的理论，而是传统带来的本能。</p>
<p>本书将中国的历史依据制度和财政的传承性分为三个周期：</p>
<ol>
<li>第一个周期以官僚制度上以中央集权为主，残存一定的诸侯制；经济上实行土地私有制，财政税收最初以土地税为主，逐渐开辟出国有企业、金融垄断与卖官鬻爵。这个周期始于秦汉，结束于南朝。</li>
<li>第二个周期的制度特征是较为完善的中央集权制和科举制，经济上采用土地公有制，税收上实行较为复杂的租用调制，并辅以政府机关的自我经营。这个周期从北魏开始，结束于南宋。</li>
<li>第三个周期的特征是土地制度重回私有制，官僚制度上建立起了具有无限控制力的集权模式，并依靠封锁人们的求知欲形成了巨大的稳定性。这个周期在财政上是保守的，以土地税为主，放弃了纸币体系，回顾原始货币体系。这个周期从辽金出现萌芽，在元代继续发展，到了明清两代形成了稳定的模式。</li>
</ol>
<p>这每个周期都包含若干个朝代，第一个朝代往往从混乱中建立新的官僚和财政制度，形成基础；在后来的朝代中即使出现了改朝换代，却往往没有彻底推翻前朝的制度基础，在管制、财政上有很强的继承性，所以被视为周期的延续；直到周期的最后一个朝代，巨大的社会崩溃引起社会基础的全面改变，才会被新的周期所取代。</p>
<p>汉代最初面对强大的诸侯制残余和崩溃的经济结构，他们采取了鼓励自由经济，并逐渐从财政上收缩诸侯权利的做法，并取得了成功，形成了初步的中央集权。但到了汉武帝时期，由于战争财政的需要，建立了国有企业和金融垄断，并以破坏正常官制为代价加强中央集权。王莽时期，政府进行了激烈的、带着计划经济色彩的财金计划，但是由于政府干预对社会经济的破坏太大，导致了政府垮台。</p>
<p>东汉继承了西汉的社会经济结构，也全盘接收西汉的社会弊病。由于官商结构的发展，东汉出现了板结的社会分层，这种分层一致持续到魏晋南朝，严重到影响政权存续。第一周期由于户籍人口消失、财税不足，政府变得羸弱不堪，最终因丧失了调整能力而崩塌。</p>
<p>北魏出现了土地公有制，历经西魏、北周和隋，到了唐初，形成了以政府分配和回收土地为特征的公有制。但是唐代的土地公有制去很快失败了。唐代的土地公有制崩溃直接影响了税收，此外政府必须同时统计人口、土地和家庭，由于这超出了当时政府的统计能力，对财政照成了巨大的拖累。所以，唐代虽然经济大发展，财政却不健康，这导致了安史之乱。唐代后期进行了土地私有制改革，加强专卖制度，形成了庞大的国有垄断经济。这些特征传给了五代、两宋，并在宋代形成了庞大的政府垄断。</p>
<p>宋代，因为高昂的战争和养官成本，需要庞大的财政支持，形成了中国离殇上最壮观的专卖制度，并开创了有历史性意义的纸币实验。纸币最初由民间发行，后由政府将发行权收归国有，并发现了纸币巨大的财富再分配效应。从这时开始，后代政府都通过纸币从民间吸取财富，形成了世界上最早的一系列恶性通货膨胀。</p>
<p>从辽金开始，土地制度重回私有制，放弃了不稳定的纸币系统，回归原始的货币制度，但是这套制度又足够简单，足以维持很长时间。实际上，清朝的经济一直处于高速发展中。但是到了清末，随着海外影响的到来，中国财政才开始了近代化的路程，并有了突破农业社会桎梏的机会。</p>
<p>这本书不仅仅是回顾古代，而且通过研究古代问题来研究现代。了解了古代的财政逻辑之后，再看待现代问题，就有个更广阔的视角。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/10/05/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">JVM 垃圾收集算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 09:10:46" itemprop="dateCreated datePublished" datetime="2018-10-05T09:10:46+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming-language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/10/05/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/05/JVM垃圾收集算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>垃圾收集（Garbage collection, GC）是 Java 流行的重要原因。GC 是一种能够自动回收不用内存的机制。本质上，GC 追踪所有正在被使用的对象，并将剩余对象标记为「垃圾」（garbage）。因为程序员不需要刻意将对象标记为「可回收」，所以 Java 的 GC 被认为是自动内存管理模式。GC 以低优先级线程运行。</p>
<h2 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h2><p>JVM 中对象的生命周期可以被分为3个阶段：</p>
<ol>
<li>对象创建（Object creation）</li>
</ol>
<p>创建对象通常使用 <code>new</code> 关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>当对象创建完成后，操作系统会分配特定大小的内存来保存对象。分配的内存大小与操作系 统体系结构以及 JVM 种类有关。</p>
<ol start="2">
<li>对象使用（Object in use）</li>
</ol>
<p>在这个阶段，对象正在被应用程序的其他对象使用（其他对象有指向该对象的引用）。此时，对象被保存在内存中并且可能持有指向其他对象的引用。</p>
<ol start="3">
<li>对象销毁（Object destruction）</li>
</ol>
<p>GC 系统检测每个对象，并做引用计数。当没有引用指向某个对象时，挡圈运行的程序没有任何方法可以访问该对象，所以就可以回收该对象所占用的内存。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>对象有程序员编写的代码，以及为了使用框架所提供的特性而创建，但是不需要显式地回收内存。内存的回收由运行在 JVM 层级的垃圾收集器完成。在 JVM 的进化过程中出现了很多垃圾收集算法。</p>
<h3 id="标记-清除（Mark-and-sweep）"><a href="#标记-清除（Mark-and-sweep）" class="headerlink" title="标记-清除（Mark and sweep）"></a>标记-清除（Mark and sweep）</h3><p><strong>标记-清除</strong> 是最初也是最基本的垃圾收集算法，它有两个阶段：</p>
<ol>
<li>标记活跃对象</li>
<li>删除不可达对象</li>
</ol>
<p>在开始，GC 定义了一些特定对象，被称为<strong>根对象</strong>（Garbage Collection Roots），如：本地变量、当前执行方法、活跃线程、类静态域的输入参数等。GC 从根对象开始，沿着指向其他对象的引用遍历内存中的所有对象，将所有访问到的对象标记为「存活」。</p>
<blockquote>
<p>在运行标记算法时，应用程序需要暂停运行，因为无法遍历不断变化的引用图。这被称为 <strong>Stop The World pause</strong>。</p>
</blockquote>
<p>第二个阶段清理内存。这一步可以用多种方法实现：</p>
<ol>
<li><strong>普通删除</strong>（Normal deletion）：释放没有被引用的对象所占用的内存，不修改被引用的对象。memory allocator 保存着指向可以创建对象的空闲内存区域。这通常被称为<strong>标记-清除</strong>算法。</li>
</ol>
<p><img src="/images/2018-10-05/Normal-Deletion-Mark-and-Sweep.png" alt="Normal-Deletion.png"></p>
<ol start="2">
<li><strong>删除-整理</strong>（Deletion with compacting）：仅仅删除无用的对象是不够的，因为空闲内存以碎片的形式分布在内存中，如果创建较大的对象，但是却无法找到足够大的连续内存空间，则可能抛出 <code>OutOfMemoryError</code> 。<br> 为了解决这个问题，在删除无用对象后，会将存活的对象所占内存合并，以消除内存碎片。这使得分配新内存更容易也更快。这通常被称为<strong>标记-整理</strong>算法，</li>
</ol>
<p><img src="/images/2018-10-05/Deletion-with-compacting.png" alt="Deletion-with-compacting.png"></p>
<ol start="3">
<li><strong>删除-复制</strong>（Deletion with copying）：这与标记-整理算法相似，它们都移动内存中存活对象的位置。不同之处在于，删除-复制算法将对象移动到不同的区域。</li>
</ol>
<p><img src="/images/2018-10-05/Deletion-with-copying-Mark-and-Sweep.png" alt="Deletion-with-copying-Mark-and-Sweep.png"></p>
<h3 id="并发标记删除垃圾收集（Concurrent-mark-sweep，CMS）"><a href="#并发标记删除垃圾收集（Concurrent-mark-sweep，CMS）" class="headerlink" title="并发标记删除垃圾收集（Concurrent mark sweep，CMS）"></a>并发标记删除垃圾收集（Concurrent mark sweep，CMS）</h3><p>CMS 在本质上是对标记清除算法的升级。它使用多个线程扫描堆内存。它可以利用现代计算机多核的结构，在性能上有显著提升。</p>
<p>CMS 通过与应用程序线程并发地进行垃圾收集，尝试最小化程序的停顿时间。它在新生代使用并行的<strong>标记-复制</strong>算法，在老年代使用并发的<strong>标记-清除</strong>算法。</p>
<p>为了开启 CMS ，需要设置 JVM 的参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserConcMarkSweepGC</span><br></pre></td></tr></table></figure>

<h4 id="CMS-的优化选项"><a href="#CMS-的优化选项" class="headerlink" title="CMS 的优化选项"></a>CMS 的优化选项</h4><table>
<thead>
<tr>
<th>FLAG</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseCMSInitiating\OccupancyOnly</td>
<td>Indicates that you want to solely use occupancy as a criterion for starting a CMS collection operation.</td>
</tr>
<tr>
<td>-XX:CMSInitiating\OccupancyFraction=70</td>
<td>Sets the percentage CMS generation occupancy to start a CMS collection cycle.</td>
</tr>
<tr>
<td>-XX:CMSTriggerRatio=70</td>
<td>This is the percentage of MinHeapFreeRatio in CMS generation that is allocated prior to a CMS cycle starts.</td>
</tr>
<tr>
<td>-XX:CMSTriggerPermRatio=90</td>
<td>Sets the percentage of MinHeapFreeRatio in the CMS permanent generation that is allocated before starting a CMS collection cycle.</td>
</tr>
<tr>
<td>-XX:CMSWaitDuration=2000</td>
<td>Use the parameter to specify how long the CMS is allowed to wait for young collection.</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>Elects to use the parallel algorithm for young space collection.</td>
</tr>
<tr>
<td>-XX:+CMSConcurrentMTEnabled</td>
<td>Enables the use of multiple threads for concurrent phases.</td>
</tr>
<tr>
<td>-XX:ConcGCThreads=2</td>
<td>Sets the number of parallel threads used for the concurrent phases.</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads=2</td>
<td>Sets the number of parallel threads you want used for stop-the-world phases.</td>
</tr>
<tr>
<td>-XX:+CMSIncrementalMode</td>
<td>Enable the incremental CMS (iCMS) mode.</td>
</tr>
<tr>
<td>-XX:+CMSClassUnloadingEnabled</td>
<td>If this is not enabled, CMS will not clean permanent space.</td>
</tr>
<tr>
<td>-XX:+ExplicitGCInvokes\Concurrent</td>
<td>This allows System.gc() to trigger concurrent collection instead of a full garbage collection cycle.</td>
</tr>
</tbody></table>
<h3 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h3><p>G1（Garbage First）从 Java7 开始可用，并希望在未来逐渐替代 CMS。目前，在 Java8中，G1 是默认的垃圾收集器。G1 是并行、并发、分代收集、低停顿的垃圾收集器。</p>
<p>G1 将按区（region）将堆分割，每个 region 的大小通常为 2048 字节。每个 region 可能是新生代或老年代（新生代又被分为 eden 和 survivor region）。这允许 GC 不需要一次对整个堆进行垃圾回收，而是可以增量地进行。这意味着一次只在一部分 region 上进行垃圾回收。</p>
<p><img src="/images/2018-10-05/Memory-regions-marked-G1.png" alt="Memory-regions-marked-G1.png"></p>
<p>G1 追踪每个 region 中包含的存活数据的数量。追踪的结果被用于觉得那些 region 中 garbage 最多，最多的被最先回收。</p>
<p>和其他算法一样，整理的操作也会暂停程序的运行。但是我们可以配置暂停时间。G1将尽可能的满足配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/08/05/Docker-Namespace-Cgroup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/05/Docker-Namespace-Cgroup/" class="post-title-link" itemprop="url">Docker 基础知识之 Namespace, Cgroup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-05 22:14:46" itemprop="dateCreated datePublished" datetime="2018-08-05T22:14:46+08:00">2018-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/08/05/Docker-Namespace-Cgroup/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/08/05/Docker-Namespace-Cgroup/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近工作上需要使用 Docker，在阅读「<a href="https://www.amazon.cn/dp/B01E5P05KU/ref=sr_1_1?s=books&ie=UTF8&qid=1532857475&sr=1-1&keywords=第一本docker书" target="_blank" rel="noopener">第一本 Docker 书</a>」后了解了如何成为 Docker 的用户，但对 Docker 中用到技术却不甚了解。都说 Docker 是「新瓶装旧球」，文中笔者将学习到的 Docker 基础技术中的 Namespace，Cgroup 与 AUFS 记录如下。</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Linux Namespace 是 Linux 内核提供的一个功能，可以实现系统资源的隔离，如：PID、User ID、Network 等。Linux 中的 chroot 命令可以将当前目录设置为根目录，使得用户的操作被限制在当前目录之下而不影响其他目录。</p>
<p>假设我们成立了一家向外售卖计算资源的公司，用户购买了一个实例在运行自己的应用。如果某些用户能够进入到其他人的实例中，修改或关闭其他实例中应用的状态，那么就会导致不同用户之间相互影响；用户的某些操作可能需要 root 权限，假如我们给每个用户都赋予了 root 权限，那么我们的机器也就没有任何安全性可言了。使用 Namespace，Linux 可以做到 UID 级别的隔离，也就是说，UID 为 n 的用户在自己的 Namespace 中是有 root 权限的，但是在真实的物理机上，他仍然是 UID 为 n 的用户。</p>
<p>目前 Linux 共实现了 6 种不同的 Namespace。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>系统调用参数</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mount Namespace</td>
<td>CLONE_NEWNS</td>
<td>2.4.19</td>
</tr>
<tr>
<td>UTS Namespace</td>
<td>CLONE_NEWUTS</td>
<td>2.6.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>CLONE_NEWIPC</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>CLONE_NEWPID</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Network Namespace</td>
<td>CLONE_NEWNET</td>
<td>2.6.29</td>
</tr>
<tr>
<td>User Namespace</td>
<td>CLONE_NEWUSER</td>
<td>3.8</td>
</tr>
</tbody></table>
<h3 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h3><blockquote>
<p>UTS namespaces allow a single system to appear to have different host and domain names to different processes.</p>
</blockquote>
<p>UTS(UNIX Timesharing System) Namespace 可以用来隔离 nodename 和 domainname 两个系统标识。在 UTS Namespace 中，每个 Namespace 可以有自己的 hostname。</p>
<p>我们运行下面程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要是通过系统调用 <code>clone</code>，并传入 <code>CLONE_NEWUTS</code> 作为参数创建一个新进程，并在新进程内运行 <code>zsh</code> 命令。在 Ubuntu 14.04 上运行这段代码，就可以进入一个交互环境，在环境中运行 <code>ps -af --forest</code> 就可以看到如下的进程树：</p>
<p><img src="/images/2018-08-05/uts-pstree.png" alt="UTS PS"></p>
<p>验证下父进程和子进程是否在同一个 UTS Namespace 中：</p>
<p><img src="/images/2018-08-05/uts-ns.png" alt="UTS NS"></p>
<p>可以看到他们的 UTS Namespace 的编号不同。因为 UTS Namespace 对 hostname 做了隔离，所以在这个环境内修改 hostname 不会影响外部主机。</p>
<p>在目前的 zsh 环境中我们修改 hostname 并打印:</p>
<p><img src="/images/2018-08-05/hostname-chuan.png" alt="hostname-chuan"></p>
<p>在宿主机上打印 hostname：</p>
<p><img src="/images/2018-08-05/hostname-main.png" alt="hostname-root"></p>
<p>可以看到，外部的 hostname 没有被内部的修改所影响。</p>
<h3 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h3><blockquote>
<p>IPC namespaces isolate processes from SysV style inter-process communication.</p>
</blockquote>
<p>IPC(Interprocess Communication) Namespace 用来隔离 System V IPC 和 POSIX message queues。每一个 IPC Namespace 都有自己的 System V IPC 和 POSIX message queue。</p>
<p>我们在上一段代码的基础上增加 <code>CLONE_NEWIPC</code> 标识，表示我们要创建 IPC Namespace。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在宿主器机查看并创建一个 message queue：</p>
<p><img src="/images/2018-08-05/ipc-main.png" alt="ipc-main"></p>
<p>运行代码并查看 message queue：</p>
<p><img src="/images/2018-08-05/ipc-chuan.png" alt="ipc-chuan"></p>
<h3 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h3><blockquote>
<p>The PID namespace provides processes with an independent set of process IDs (PIDs) from other namespaces.</p>
</blockquote>
<p>PID(Process ID) Namespace 可以用来隔离进程 ID。同一个进程在不同的 PID Namespace 中可以拥有不同的 PID。在 Docker Container 中，使用 <code>ps -ef</code> 可以看到启动容器的进程 PID 为 1，但是在宿主机上，该进程却又有不同的 PID。</p>
<p>继续在代码上添加 <code>CLONE_NEWPID</code> 为子进程创建 PID Namespace。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，首先在宿主机上查看进程树：</p>
<p><img src="/images/2018-08-05/pid-main.png" alt="pid-main"></p>
<p>可以看到 zsh 的 PID 为 11321。在 Namespace 中打印进程 PID：</p>
<p><img src="/images/2018-08-05/pid-chuan.png" alt="pid-chuan"></p>
<p>可以看到，打印出的当前 Namespace 的 PID 为 1，也就是说 11321 的进程被映射到 Namespace 中后 PID 为 1。</p>
<h3 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h3><blockquote>
<p>Mount namespaces control mount points.</p>
</blockquote>
<p>Mount Namespace 用来隔离各个进程看到的挂载点视图。在不同的 Namespace 中，看到的挂载点文件系统层次是不一样的。在 Mount Namespace 中调用 <code>mount</code> 和 <code>unmount</code> 仅仅会影响当前 Namespace 内的文件系统，而对全局文件系统是没有影响的。</p>
<p>在代码中，我们继续加入 <code>CLONE_NEWNS</code> 标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先运行代码，然后查看 <code>/proc</code> 的文件内容：</p>
<p><img src="/images/2018-08-05/mount-main.png" alt="mount-main"></p>
<p>可以看到宿主机的 <code>/proc</code> 中文件较多，其中的数字是对应进程的相关信息。下面，将 <code>/proc</code> mount 到 Namespace 中。</p>
<p><img src="/images/2018-08-05/mount-chuan.png" alt="mount-chuan"></p>
<p>可以看到现在以 PID 命名的文件夹明显减少。下面使用 <code>ps -ef</code> 查看系统进程：</p>
<p><img src="/images/2018-08-05/mount-chuan-ps.png" alt="mount-chuan-ps"></p>
<p>可以看到，在当前的 Namespace 中，zsh 是 PID 为 1 的进程。这就说明当前 Namespace 中的 mount 和外部是隔离的，mount 操作没有影响到外部。Docker 的 volumn 正是利用了这个特性。</p>
<h3 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h3><blockquote>
<p>User namespaces are a feature to provide both privilege isolation and user identification segregation across multiple sets of processes.</p>
</blockquote>
<p>User Namespace 主要是隔离用户的用户组 ID。也就是说，一个进程的 User ID 和 Group ID 在 User Namespace 内外可以是不同的。比较常用的是，在宿主机上以一个非 root 用户运行创建一个 User Namespace，然后在 User Namespace 中被映射为了 root 用户。这意味着这个进程在 User Namespace 中有 root 权限，但是在宿主机上却没有 root 权限。</p>
<p>继续修改代码，添加 <code>CLONE_NEWUSER</code> 标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">    Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID |</span><br><span class="line">        syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在宿主机上查看当前用户和用户组：</p>
<p><img src="/images/2018-08-05/user-main.png" alt="user-main"></p>
<p>接下来运行程序，并查看用户组：</p>
<p><img src="/images/2018-08-05/user-chuan.png" alt="user-chuan"></p>
<p>可以看到，UID 是不同的，说明 User Namespace 生效了。</p>
<h3 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h3><blockquote>
<p>Network namespaces virtualize the network stack. On creation a network namespace contains only a loopback interface.</p>
</blockquote>
<p>Network Namespace 用来隔离网络设置、IP 地址和端口号等网络栈的 Namespace。Network Namespace 可以让每个容器拥有自己独立的网络设备，而且容器内的应用可以绑定到自己的端口，每个 Namespace 的端口都不会有冲突。在宿主机搭建网桥后，就能很方便地实现容器之间的通信。</p>
<p>我们继续在代码基础上添加 <code>CLONE_NEWNET</code> 标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID |</span><br><span class="line">        syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNET,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，在宿主机上查看自己的网络设备：</p>
<p><img src="/images/2018-08-05/network-main.png" alt="network-main"></p>
<p>可以看到在宿主机上有 eth0 和 lo 等网络设备。下面，运行程序，并运行 <code>ifconfig</code>：</p>
<p><img src="/images/2018-08-05/network-chuan.png" alt="network-chuan"></p>
<p>我们发现，在 Namespace 中什么网络设备都没有。这可以断定 Namespace 与宿主机之间的网络是处于隔离状态的。</p>
<h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>Linux Namespace 帮助进程隔离出自己的单独空间，而 Cgroups 则可以限制每个空间的大小。Cgroups 提供了对一组进程及将来子进程的资源限制、控制和统计的能力。</p>
<p>Cgroups 有三个组件：</p>
<ol>
<li>cgroup 负责对进程分组管理，一个 cgroup 包含一组进程并可以设置进程参数</li>
<li>subsystem 是一组资源控制模块，可以关联到 cgroup 上，并对 cgroup 中的进程做出相应限制。</li>
<li>hierarchy 可以把一组 cgroup 串成一个树状结构，这样 cgroup 可以做到继承。</li>
</ol>
<p>Cgroups 中的 hierarchy 是一种树状结构，Kernel 为了使得对 Cgroups 的配置更加直观，通过一个虚拟的树状文件系统配置 Cgroups 的，通过层级的目录虚拟出 cgroup 树。我们可以在系统上做实验：</p>
<ol>
<li><p>首先，创建并挂载一个 hierarchy<br><img src="/images/2018-08-05/cgroup-mount.png" alt="cgroup-mount"></p>
<ul>
<li><code>cgroup.clone_children</code>，<code>cpuset</code> 的 subsystem 会读取这个配置文件，如果这个值是 1，子 cgroup 才会继承父 cgroup 的 <code>cputset</code> 的配置</li>
<li><code>cgroup.procs</code> 是树中当前节点 cgroup 中的进程组 ID</li>
<li><code>notify_on_release</code> 和 <code>release_agent</code> 会一起使用。<code>notify_on_release</code> 标识当这个 cgroup 最后一个进程退出的时候是否执行了 <code>release_agent</code>；<code>release_agent</code> 使进程退出后自动清理掉不再使用的 cgroup</li>
<li><code>tasks</code> 标识该 cgroup 下的进程 ID，将进程 ID 写入 <code>tasks</code> 文件中，便会将相应进程加入到这个 cgroup 中</li>
</ul>
</li>
<li><p>在刚创建好的 hierarchy 上 cgroup 的根节点中拓展出两个子 cgroup<br><img src="/images/2018-08-05/cgroup-tree.png" alt="cgroup-tree"><br>可以看到在 cgroup 目录下创建文件夹的时候，Kernel 会把文件夹标记为子 cgroup，她们继承父 cgroup 的属性。</p>
</li>
<li><p>在 cgroup 中添加和移动进程只需要将进程 ID 写到或移动到 cgroup 节点的 <code>tasks</code> 文件中即可</p>
</li>
</ol>
<p><img src="/images/2018-08-05/cgroup-mv.png" alt="cgroup-mv"></p>
<p>这样，我们就把当前的 3217 进程加入到 cgroup-test:/cgroup-1 中了</p>
<ol start="4">
<li>通过 subsystem 限制 cgroup 中的进程的资源。我们使用系统为每个 subsystem 默认创建的 hierarchy，如 memory 的 hierarchy 来完成实验。</li>
</ol>
<p><img src="/images/2018-08-05/cgroup-mem.png" alt="cgroup-mem"></p>
<p><img src="/images/2018-08-05/cgroup-stress.png" alt="cgroup-stress"></p>
<p>可以看到系统总的内存为 2GB，其中 stess 只能占用到 5% 左右，也就是 100MB。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/04/09/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/09/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/" class="post-title-link" itemprop="url">网络是如何连接的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-10 02:16:23" itemprop="dateCreated datePublished" datetime="2018-04-10T02:16:23+08:00">2018-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/04/09/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/04/09/网络是怎样连接的/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>网络是个巨大而复杂的系统，在我们尝试了解网络如何工作的时候，首先需要从高空俯瞰网络的全貌，否则如果过早地沉溺于细节，就很难理解每一种网络技术背后的意义；如果无法理解技术的本质意义，就只能停留在死记硬背的程度，无法做到实际运用。当年在课上学习了计算机网络，课本上的内容基本都仅仅用来应付考试和求职面试了，而没有真正内化为自己的实力。最近朋友推荐了《网路是如何连接的》，日本技术人员的书从来都以知识面广、细致周全著称，所以我希望抛开学院派的教条，理解网络的全貌。</p>
<h2 id="网络的全貌"><a href="#网络的全貌" class="headerlink" title="网络的全貌"></a>网络的全貌</h2><p>对网络的探索之旅从在浏览器地址框输入网址开始，随后浏览器解析网址并利用 DNS 服务获取域名对应的服务器 IP 地址，为了发送数据到服务器，浏览器委托系统的网络协议栈将消息打包并加上目的地址等控制信息，然后协议栈将数据包交给主机网卡，主机网卡将数据包转换为比特流发送到服务器。主机通过光纤等线路接入网络运营商，网络运营商对比特流进行分拣，再通过骨干网络的路由器的不断接力将信息最终传递到 Web 服务器。通过骨干网络后，网络包抵达 Web 服务器，服务器的防火墙将对包进行检查并决定是否放行。信息包在通过防火墙后，可能还会遇到缓存和负载均衡器，最终被服务器处理。在服务器中，数据包被还原成为原始的请求信息，并通过服务器主机的协议栈交给程序，服务器程序将响应数据按同样的流程回传给客户端浏览器。最终浏览器得以将响应信息渲染为网页。</p>
<h2 id="浏览器发送请求"><a href="#浏览器发送请求" class="headerlink" title="浏览器发送请求"></a>浏览器发送请求</h2><p>在地址框输入网址后，浏览器首先会解析 URL 得到访问方法（HTTP，FTP)、域名、端口号和文件路径。之后，浏览器生成符合 HTTP 格式的请求信息。</p>
<p>生成 HTTP 消息之后，浏览器需要委托操作系统将消息传递到服务器，为了发送消息，操作系统需要知道服务器的 IP 地址。因此，浏览器会通过请求 DNS 服务器来获取服务器的 IP 地址。在主机中，请求 DNS 服务器查询 IP 地址的功能通常包含在操作系统的 <code>Socket</code> 库中。浏览器调用 <code>Socket</code> 库中的解析器（resolver）完成 IP 地址的查询。</p>
<blockquote>
<p><code>Socket</code> 是调用网络功能的程序组件集合。</p>
</blockquote>
<p>与浏览器一样，解析器在生成 DNS 请求后也需要委托操作系统的网络协议栈发送请求。从这里我们也可以看出，委托协议栈发送消息是一个通用的过程，与具体应用无关，这体现了程序设计上的<code>解耦合</code>原则。</p>
<p>DNS 系统是典型的、非常成功的分布式系统。在收到客户端发出的 IP 地址解析请求后，如果本地没有保存域名对应的 IP 地址，DNS 服务器会按照树形结构不断向上级 DNS 服务器查询，直到顺藤摸瓜找到 IP 地址或确认不存在该域名对应的 IP 地址。</p>
<p>在查询到服务器的 IP 地址，并生成 HTTP 请求内容后，浏览器则会委托系统协议栈完成数据的发送。</p>
<h2 id="协议栈发送数据"><a href="#协议栈发送数据" class="headerlink" title="协议栈发送数据"></a>协议栈发送数据</h2><p>委托协议栈发送数据同样通过调用 <code>Socket</code> 库来完成。协议栈通过 TCP 协议发送数据包裹四个阶段：</p>
<ol>
<li>创建套接字</li>
<li>连接服务器</li>
<li>收发数据</li>
<li>断开连接并删除套接字</li>
</ol>
<p>协议栈的内部结构为：</p>
<p><img src="/images/2018-3-31/protocol_stack.png" alt="协议栈内部结构"></p>
<p>在协议栈中，上面的部分想下面的部分委派工作，下面的部分接受委派并实际执行。所以，当调用 <code>Socket</code> 库时，实际的工作会有操作系统的协议栈完成。协议栈中的 <code>TCP</code> 和 <code>UDP</code> 分别都使用了 <code>IP</code> 协议，最终 <code>IP</code> 协议通过网卡驱动程序使用网卡实际发送数据。</p>
<blockquote>
<p>协议栈是根据套接字中记录的控制信息来工作的</p>
</blockquote>
<p>套接字本身是一个概念，而用于控制通信操作的控制信息构成了套接字的实体，协议栈在执行操作时需要参阅套接字中的控制信息。我们在系统中使用 <code>netstat</code> 命令就可以看到系统中当前活跃地套接字。</p>
<p><img src="/images/2018-3-31/netstat.png" alt="enter image description here"></p>
<p>当浏览器调用<code>Socket</code>库中 <code>socket</code>、<code>connect</code>、<code>write</code>、<code>read</code>、<code>close</code>等操作时，应用程序与Web 服务器的交互可以被总结为下图：</p>
<p><img src="/images/2018-3-31/socket.png" alt="enter image description here"></p>
<h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>调用 <code>socket</code> 申请创建套接字。协议栈首先分配用于存放套接字所需的内存空间，并写入初始状态。然后，将该套接字的描述符返回给应用程序。收到描述符后，应用程序在进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了套接字，协议栈就能获取所有信息。</p>
<h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>创建套接字后，应用程序调用 <code>connect</code> 将本地套接字与服务器套接字进行连接。所谓“连接”，实际上是通信双方交换控制信息。在套接字创建结束后，并没有保存任何信息，也不知道目标通信对象是谁；而服务器端也同样不知道将要和那一台主机通信。所以，客户端和服务器端需要通过“连接”来做好双方通信的准备。</p>
<p>连接过程中需要的控制信息有两类：</p>
<ol>
<li>数据包头部信息（如 TCP 数据包头部）</li>
<li>套接字中记录的信息</li>
</ol>
<p>“连接”过程由应用程序调用 <code>connect</code> 函数开始。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sockfd, socket_addr, socket_port)</span><br></pre></td></tr></table></figure>

<p>该调用将服务器的 IP 地址和端口号传递给协议栈中的 TCP 模块，然后 TCP 模块会用过 IP 协议于对应的服务器端的 TCP 模块交换控制信息。首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部，将 SYN 设为1，并设置适当窗口大小等。当头部创建好之后，TCP 模块委托 IP 模块进行发送到服务器端的 TCP 模块。之后，服务器的 TCP 模块返回响应，并将头部中 ACK 设置为1。接下来，客户端收到响应，连接被正确建立。这也就是我们知道的“TCP三次握手”。</p>
<p>建立连接后，控制流程被交回到应用程序。</p>
<h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><p>收到数据的过程从应用程序调用 <code>write</code> 把数据交给协议栈开始。对于协议栈来说，要发送的数据就是一定长度的二进制比特流。在发送数据之前，协议栈会首先将数据保存在发送缓冲区中，等到缓冲区满，或者达到一定的等待时间后就才发送。但是缓冲区中信息的长度和等待时间是矛盾的，如果长度优先，那么网络利用效率会提高，但是可能因为等待缓冲区满而造成延迟；如果时间优先，那么等待时间变少，网络利用效率又会降低。TCP 协议的规格没有规定如何实现数据长度和等待时间的平衡，所以不同平台的做法会有差异。</p>
<p>TCP 在协议在收发数据时会对较大的包进行拆分，并使用序号和 ACK 的保证信息发送的完成，并能在客户端和服务器之间实现全双工通信。首先，客户端在连接时计算出发送数据到服务器时的序号初始值，并将初始值发送个服务器；服务器根据初始值计算 ACK 号并返回给客户端；同时，服务器也计算出与客户端通信使用的初始值，并发送给客户端；同样客户端也需要根据服务器发来的初始值计算 ACK 号并返回。</p>
<p>为了适当的设置 ACK 的超时等待时间，TCP 采用了动态调整等待时间的方法，这个时间根据 ACK 号返回所需的时间来判断。若返回变慢，则延长等待时间，若变快，而减少等待时间。为了在等待 ACK 时不浪费计算资源，TCP 使用滑动窗口方法来管理数据发送和 ACK 的操作。接收方在收到数据包后，会根据序号将数据包合并，仅仅确认最后一个收到的数据包的序号，这样大大缓解的出现网络拥挤的可能。</p>
<p>在发送消息后，应用程序调用 <code>read</code> 来委托协议栈获取响应消息。和发送数据一样，接收数据也同样需要将数据保存在缓冲区，在等待收到数据期间，协议栈会将应用程序挂起，等到收到响应消息后再继续执行。</p>
<h3 id="断开连接并删除套接字"><a href="#断开连接并删除套接字" class="headerlink" title="断开连接并删除套接字"></a>断开连接并删除套接字</h3><p>在客户端与服务器之间断开连接的过程则就是我们熟知的 TCP “四次挥手”的过程。首先由客户端生成 TCP 头部，将 FIN 置为 1 发送给服务器，服务器返回确认；然后再由服务器生成 TCP 头部，置控制信息 FIN 为 1 发送给客户端，最后客户端返回确认。</p>
<p>在断开连接之后，原来的通信使用的套接字就不会再使用了。但是为了防止误操作，客户端或服务器会等待一段时间之后才真正删除套接字。</p>
<h3 id="IP-协议发送数据包"><a href="#IP-协议发送数据包" class="headerlink" title="IP 协议发送数据包"></a>IP 协议发送数据包</h3><blockquote>
<p>IP 协议的职责仅仅是将委托的信息打包送到对方手里，或者接收对方发来的数据包。</p>
</blockquote>
<p>IP 协议发送数据包的起点是 TCP 模块委托 IP 模块发送数据包的操作。TCP 模块在 TCP 分组前添加上 TCP 头部，然后整个传给 IP 模块。收到委托后，IP 模块会 TCP 分组当做整块数据，并在前面加上 IP 头部和 MAC 头部。IP 头部包含发往目的地所需要的信息，MAC 头部包含通过以太网将包传输至最近的路由器所需要的控制信息。其中的 MAC 头部中的目的 MAC 地址通过向网络广播 ARP 请求来获得。接下来，封装好的包会被交给网络硬件，如网卡。通过网卡将信息转化为点信号或光信号，并通过网线发送出去，然后这些信号就会到达集线器、路由器等设备，再由转发设备一步一步地送达接收方。</p>
<h2 id="网络设备-——-集线器、交换机和路由器"><a href="#网络设备-——-集线器、交换机和路由器" class="headerlink" title="网络设备 —— 集线器、交换机和路由器"></a>网络设备 —— 集线器、交换机和路由器</h2><p>从计算机发送出来的网络包会通过集线器、路由器等设备转发，最终到达目的地。转发设备根据包头部中的控制信息，查询转发表判断包的目的地，然后将包朝目的地方向转发。也就意味着，HTTP 请求方法、TCP 的确认响应和序号，客户端和服务器之间的关系，这一切都与包的传输无关。所有的包在传输过程中都是独立的，相互之间没有任何关系。</p>
<h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>从信号流出网卡进入网线开始，网卡中的 PHY(MAU) 将包转换成电信号，电信号通过 RJ-45 接口进入双绞线。为了防止信号在传输过程中出现失真、减少噪声对信号的干扰，网线使用的是双绞线。双绞线通过两根信号线的缠绕抵消外源性噪声，通过改变节距抑制内源性噪声。</p>
<p>当信息通过双绞线到达集线器后，会被广播到整个网络中。以太网将包发送到所有设备，然后由设备根据接收方 MAC 地址来判断应该接收哪些包。由于集线器只是原封不动地将信息广播出去，所以即使信号受到噪声的干扰发生了失真，也会原样发送到目的地。这是接收信号的设备（交换机、路由器、服务器等），会在将信号转换成数字信息后通过 FCS（帧校验序列）校验发现错误，并将出错的包丢弃。因为丢弃的包不会触发确认响应，所以协议栈的 TCP 模块会检测到丢包，并对该包进行重传。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机的设计是将网络包原样转发到目的地。首先，信息到达网线接口，接下来，PHY(MAU) 将网线中的信号转换为通用格式，然后传递给 MAC 模块。MAC 模块将信号转换为数字信息，然后通过包末尾的 FCS 校验错误，如果没问题册存放到缓冲区中。交换机中网线接口和后面的电路部分加在一起成为一个端口，或者说交换机的一个端口就相当于计算机上一块网卡，但是交换机的端口不具有 MAC 地址。将包存储缓冲区后，要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了，如果有，就可以通过交换电路将包发送到相应的端口了。特殊的，当交换机发现一个包要发回源端口是，就会直接丢弃这个包。</p>
<p>交换机在转发包的过程中，需要对 MAC 地址表的内容进行维护。</p>
<ol>
<li>收到包时，将发送方 MAC 地址以及其输入端口的号码写入 MAC 地址表中。</li>
<li>删除地址表中某条记录的操作，这是为了防止设备移动是产生问题。</li>
</ol>
<p>交换机相对于集线器的另外一个优势在于，交换机的全双工模式可以同时发送和接收数据。交换机中有自动协商功能，可以由相互连接的双方探测对方是否支持全双工模式，并自动切换成相应的工作模式。此外，交换机可以同时转发多个包。相对的，集线器会将输入信号广播到所有端口，如果同时输入多个信号就会发生碰撞，无法同时传输多路信号。从整体转发能力看，交换机高于集线器。</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>网络包经过集线器和交换机后，就到达了路由器，并在此被转发到下一个路由器。这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。不过在具体的操作上，路由器和交换机是有区别的。因为路由器是基于 IP 设计的，而交换机是基于以太网设计的。</p>
<p>路由器在转发包时，首先会通过通过端口将发过来的包接收进来，这一步的工作取决于端口对应的通信技术。接下来，转发模块会根据接收的包的 IP 头部中记录的接收方 IP 地址，在路由表中进行查询，一次判断转发目标。然后，转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去，也就是转发模块委托端口模块将包发送出去。路由器的以太网端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方。端口还具有 IP 地址。当转发时，首先路由器端口会接收发送自己的以太网包，然后查询转发目标，再由相应端口作为发送方将以太网包发送出去。而交换机只将收到的包转发出去，而自己不会成为发送方或接收方。</p>
<p>在「查表判断转发目标」中，路由器是根据 IP 头部的 IP 地址来判断的。路由表中包含：目标地址、子网掩码、网关、接口、跃点数。实际上第一列的 IP 地址只包含表示子网的网络号部分的比特值，而表示主机号部分的比特值全部为 0。打个比方，路由器在转发时只看接收方地址属于哪个区。</p>
<p>为了知道网络号的比特数，路由表中还有一列子网掩码，通过子网掩码可以判断网络号的比特数。路由器会对路由表中的地址进行路由聚合或路由拆分。路由聚合就是将多个子网合并为一个子网，而路由拆分则会将一个子网拆分成多条记录。</p>
<h4 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h4><p>首先，信号到达网线接口部分，PHY(MAU) 模块和 MAC 模块将信号转换成数字信号，然后通过 FCS 进行错误校验，如果没问题则检查 MAC 头部中的接口方 MAC 地址，看看是不是发给自己的包，如果是就放到接收方缓冲区中，否则就丢弃。完成包接收后，路由器就丢弃包开头的 MAC 头部。接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。首先查询路由表判断转发目标，这一阶段，路由器会选择网络号的最长匹配，如果长度相同的有多条，则选择跃点数最小的记录。如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP 消息告知发送方。</p>
<p>路由表中的最后一样通常为默认路由，这条记录填写接入互联网的路由器地址，被称为默认网关。</p>
<p>在将网络包发送出去之前，路由器还有工作要做。第一是，更新 IP 头部中的 TTL（生存时间）字段，包每经过一个路由器的转发，这个值就会减1，当这个值变成0时，就表示超过了有效期，这个包就会被丢弃。此外，如果包过大，路由器会通过分片功能拆分网络包。路由器也会使用 ARP 来查询下一个转发目标的 MAC 地址。</p>
<blockquote>
<p>IP(路由器) 负责将包送达通信对象这一整体过程，而其中将包传输到下一个路由器的过程则是由以太网(交换机)来负责的。</p>
</blockquote>
<h2 id="进入互联网内部"><a href="#进入互联网内部" class="headerlink" title="进入互联网内部"></a>进入互联网内部</h2><p>互联网的基本工作方式和家庭、公司网络一样，都是通过路由器来转发包，而路由器的基本结构和工作方式也没有什么不同。主要的区别在于距离的不同和路由的维护方式不同。</p>
<p>互联网接入路由器是按照接入网规则来发送包的。ADSL 连接方式如图。</p>
<p><img src="/images/2018-3-31/adsl.png" alt="enter image description here"></p>
<p>首先，客户端生成网络包，经过集线器和路由器到达互联网接入路由器，并在此从以太网包中取出 IP 包并判断转发目标。接下来，如果互联网接入路由器和 ADSL Modem 之间是通过以太网连接的，那么就会按照以太网的规则执行包发送的操作。不同的是，发送信号时，网络包会包上 MAC 头部、PPPoE 头部、PPP 头部，然后按照以太网规则转换成电信号后被发送出去。</p>
<p>互联网接入路由器将包发送出去后，包就到达了 ADSL Modem，然后，ADSL Modem 会把包拆分成很多小格子，每个小格子称为一个信元。然后，ADSL Modem 采用一种用正弦波，使用振幅(ASK)和相位调制(PSK)相结合的正交振幅调制方式对信号进行合成。信元转换为电信号之后，信号会进入一个叫做分离器的设备，然后 ADSL 信号会和电话语音信号混合起来一起从电话线传输出去。</p>
<p>从分离器出来后，就是插电话线的接口，信号会通过电话线到达大楼的 IDF 和 MDF 与外部相连接。信号通过电话线达到电话局之后，会经过配线盘、分离器到达 DSLAM（多路 ADSL Modem）。在这里，电信号会被还原成数字信息——信元。信元从 DSLAM 出来之后，会到达一个叫做 BAS 的包转发设备，然后被还原成原始的包。BAS 是用户登录操作的窗口，通过 PPP 和 PPPoE 协议实现了用户认证和配置下发的功能。接下来，BAS 会将包前面的 MAC 头部和 PPPoE 头部丢弃，取出 PPP 头部以及后面的数据。然后，BAS 会在包的前面加上隧道专用头部，并发送到隧道的出口。</p>
<p>现在网络包已经通过接入网，到达了网络运营商的接入路由器（POP）。通过 POP 发送的包会汇总到网络运行中心（NOC）中。NOC 是运营商的核心设备配备了高性能路由器。互联网内部使用 BGP 机制在运营商之间交换路由信息。对于互联网内部的路由器来说，无论最终目的地是否属于同一家运营商，都可以从路由表中查到，因此只要一次接一次按照路由表中的目标地址来转发包，最终一定可以到达目的地。</p>
<h2 id="服务器端局域网"><a href="#服务器端局域网" class="headerlink" title="服务器端局域网"></a>服务器端局域网</h2><p>网络包从互联网到达服务器的过程根据服务器部署地点的不同而不同。最简单的，服务器直接部署在公司网络上，可以从互联网直接访问。但现在几乎不使用这种方法，原因之一是公网 IP 有限，第二是安全问题，服务器完全暴露在公网中，安全漏洞也都会暴露出来，可以说是“裸奔”。</p>
<p>因此，业界一般会部署防火墙。它只允许允许发往指定服务器的指定应用程序的网络包通过，从而屏蔽其他不允许通过的包。部署防火墙后需要设置包过滤规则，首先，要观察包是如何流动的。通过接收方和发送方 IP 地址，我们可以判断出包的起点和终点。当要限制某个应用程序时，可以在判断条件中加上 TCP 头部或者 UDP 头部中的端口号，例如仅允许访问服务器的 80 端口。不仅仅要设置互联网和公开区域之间的包过滤规则，还需要设置公司内网和互联网之间之间，或者公司内网与公开区域之间的包过滤规则。总之，我们可以在防火墙中设置各种规则，判断是否允许通过。</p>
<p>当服务器的访问量上升，增加服务器线路的带宽是有效地，但并不是网络变快了就可以解决所有的问题。要解决服务器 CPU 过重的问题，可以采用多台 Web 服务器，减少每台服务器的访问量。一般，公司或组织内会使用负载匀衡器分配对服务器的访问。使用负载均衡器时，首先要将负载均衡器的 IP 地址代替 Web 服务器的实际地址注册到 DNS 服务器上。当负载均衡器收到请求，就会判断将请求转发给哪台 Web 服务器。</p>
<p>除了使用多台功能相同的 Web 服务器分担负载之外，还可以将整个系统按功能分成不同的服务器，如 Web 服务器、数据库服务器、缓存服务器等。缓存服务器时一台通过代理机制对数据进行缓存的服务器，它可以将 Web 服务器返回的数据保存在磁盘中，并可以代替 Web 服务器将磁盘中的数据返回给客户端。缓存服务器可以减轻 Web 服务器的负担，缩短 Web 服务器的处理时间。内容分发服务（CDN）也可以起到减轻服务器负担的作用。</p>
<h2 id="终点——服务器"><a href="#终点——服务器" class="headerlink" title="终点——服务器"></a>终点——服务器</h2><p>服务器根据功能的不同有很多种，其硬件和操作系统与客户端有所不同。但是，网络相关的部分，如网卡、协议栈、Socket库等功能和客户端没有什么区别。在连接过程中，客户端发起连接，而服务器等待连接操作，因此 Socket 库的用法有所不同。此外，服务器的程序可以同时和多台客户端计算机进行通信。</p>
<p>当服务器启动并读取配置文件时完成初始化操作后，就会运行等待连接模块。连接模块会创建套接字，然后进入等待连接的暂停状态。接下来，当客户端发起连接时，这个模块会恢复运行并接受连接，然后启动客户端通信模块，并移交完成连接的套接字。此后，客户端通信模块就会使用已连接的套接字与客户端通信，通信结束后，这个模块就退出了。</p>
<p>服务器调用 Socket 库创建套接字。</p>
<ol>
<li>创建套接字</li>
<li>将套接字设置为等待连接状态</li>
<li>接受连接</li>
<li>收发数据</li>
<li>断开管道并删除套接字</li>
</ol>
<p>首先，协议栈调用 <code>socket</code> 创建套接字，接下来调用 <code>bind</code> 将端口号写入套接字中。设置好端口号之后，协议栈会调用 <code>listen</code> 向套接字写入等待连接状态这一控制信息。这样一来，套接字就会开始等待来自客户端的连接网络包。然后，协议栈会调用 <code>accept</code> 来接受连接。一旦客户端的包到达，就会返回响应包并开始接受连接操作。接下来，协议栈会给等待连接的套接字复制一个副本，然后将连接对象等控制信息写入新的套接字中。到这里，我们就创建了一个新的套接字，并和客户端套接字连接在一起了。而最初的那个套接字还会以等待连接的状态继续存在，当再次调用 <code>accept</code>，客户端连接包到达时，它又可以再次执行接收连接操作。为了区分端口号相同的套接字，服务器使用：客户端 IP 地址、客户端端口号、服务器 IP 地址和服务器端口号识别套接字。</p>
<p>服务器收到网络包后，首先由网卡接收信号，然后将其还原成数字信息。接下来需要根据包末尾的帧校验序列（FCS）来校验错误，然后与包末尾的 FCS 值进行比较。当 FCS 一直，接下来检查 MAC 头部中的接收方MAC 地址，看看这个包是不是发给自己的。然后，还原后的数字信息被保存在网卡内部的缓冲区中。因为接下来接收操作需要 CPU 参与，因此网卡需要通过中断将网络包到达的的事件通知给 CPU。CPU 切换到网卡任务后，网卡驱动会从缓冲区中将包读取出来，根据头部中字段调用负责处理该协议的软件。这里，会调用 TCP/IP 协议栈，并将包转交给它。当网络包转交到协议栈时，IP 模块会首先开始工作，检查 IP 头部。IP 模块首先会检查 IP 头部的格式是否符合规范，然后检查接收方 IP 地址，看包是不是发给自己的，若不是，则丢弃。接下来需要检查包有没有被分片，如果是分片的包，则将包暂时存放在内存中，等所有分片到达之后将所有分片组装起来还原成原始包；如果没有分片，则直接保留接收时的样子，不需要进行重组。</p>
<p>接下来检查 IP 头部的协议号字段，并将包转交给相应的模块（TCP/UDP）。如果收到的包是 TCP 发起连接的包，则 TCP 模块会确认头部控制位 SYN；检查接收方端口号；为相应等待连接套接字复制一个新的副本；记录发送方 IP 地址和端口号等信息。</p>
<p>当收到的数据包时，TCP模块会：</p>
<ol>
<li>根据收到包的发送方 IP 地址、发送方端口号、接收方 IP 地址、接收方端口号找到对应的套接字</li>
<li>将数据块拼合起来保存在接收缓冲区中</li>
<li>向客户端返回 ACK</li>
</ol>
<p>当数据收发完成后，便开始执行断开操作。服务器程序首先会调用 Socket 库的 <code>close</code>，TCP 模块会生成一个控制位 FIN 为 1 的 TCP 头部，并委托 IP 模块发送给客户端。当客户端收到这个包后，会返回一个 ACK 号。接下来客户端调用 <code>close</code>，生成一个 FIN 为 1 的 TCP 头部发给服务器，服务器再返回 ACK 号，这时断开操作就完成了。当断开操作完成后，套接字会在一段时间后被删除。</p>
<p>在 Web 服务器中，<code>read</code> 获取的数据内容就是 HTTP 请求消息。服务器程序会根据收到的请求消息从的内容进行相应的处理，并生成响应消息，再通过 <code>write</code> 返回给客户端。请求消息包括一个“方法”的命令，以及数据源的 URI，服务器程序会根据这些内容想客户端返回数据。</p>
<p>当服务器完成对请求消息的各种处理后，就可以返回响应消息了。这与客户端想服务器发送请求消息是时的工作过程相同。Web 服务器发送的响应消息会被分成多个包发送给客户端，然后客户端需要接受数据。</p>
<p>浏览器在收到数据后，为了显示内容，首先需要判断响应消息中的数据属于那种类型，原则上通过 <code>Content-Type</code> 头部字段判断。在得到数据类型后，浏览器就可以做出相应的反应。最终，浏览器就可以显示数据，并等待用户下一个操作了。</p>
<p>从输入网址到显示出网页内容，这个过程只有短短几秒。然后，这几秒的背后，离不开各种设备和软件的相互配合。这段探索之旅，我们可以看到网络的全貌，之后，就可以根据自己的兴趣，深入探索了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/03/26/%E4%B8%8A%E5%B8%9D%E7%9A%84%E6%89%8B%E6%9C%AF%E5%88%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/26/%E4%B8%8A%E5%B8%9D%E7%9A%84%E6%89%8B%E6%9C%AF%E5%88%80/" class="post-title-link" itemprop="url">上帝的手术刀</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-26 22:56:23" itemprop="dateCreated datePublished" datetime="2018-03-26T22:56:23+08:00">2018-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 17:04:49" itemprop="dateModified" datetime="2020-08-09T17:04:49+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/booknotes/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/26/%E4%B8%8A%E5%B8%9D%E7%9A%84%E6%89%8B%E6%9C%AF%E5%88%80/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/26/上帝的手术刀/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="上帝的手术刀"><a href="#上帝的手术刀" class="headerlink" title="上帝的手术刀"></a>上帝的手术刀</h1><p>从中学生物课本上，我们就知道了 DNA 里保存了人类的全部遗传信息。不同的细胞根据功能的不同，利用 DNA 的不同部分合成各式各样的蛋白质，蛋白质决定了我们生命的特点。毕业多年，我把曾经学到过的生物知识都还给老师了，也对现在生物科技的发展状况毫不了解。听说过几家上市的生物科技公司，可对他们具体拥有什么科技，推出了什么产品一无所知。《上帝的手术刀》是浙江大学教授王立铭写的一本科普书籍，从古希腊哲学家对生命的猜想，到现在各大实验室的生物科技竞争，到对未来生物科技的展望，这本书可以当成一部人类探索遗传秘密的编年史。</p>
<p>人类从石器时代进步到农业时代的一大标志就是开始利用生物遗传的力量来为自己生产食物。在驯化了野生小麦、驯养肉猪的过程中，人类就是利用遗传的规律改造其他物种，而保留自己需要的性状。古希腊哲学家任务生物体内存在“泛生子（pangene）”颗粒，它记录了遗传信息并在交配后进入下一代体内。19世纪达尔文和进化论提出生物进化，孟德尔提出基因的显性和隐形，证明基因会在生物的一代代繁衍中顽强的存在，并在合适的情况下重新表现出来，影响生物的性状。20世纪以来，人类逐渐在实验中证明了 DNA 是遗传物质，发现了 DNA 的双螺旋结构和在遗传过程中的半保留复制，并通过实验证明了 DNA 中每三个碱基对应一个密码子，每个密码子编码了唯一的氨基酸，氨基酸最终被装配为蛋白质，蛋白质催生各种化学反应，最终多种生命现象得以发生。一系列实验的结论最终被概括为“中心法则”：</p>
<blockquote>
<p>DNA -&gt; RNA -&gt; 蛋白质。DNA 首先根据碱基互补原则以自己为模板制造一条 RNA 长链；然后 RNA 再根据3碱基对应一个氨基酸的原则制造蛋白质。</p>
</blockquote>
<p>随后，基于对基因的了解来诊断、治愈遗传疾病的尝试也被积极开展。镰刀型红细胞贫血症、艾滋病的治愈案例的出现促使全世界展开了上百项基因治疗实验，但是其中却大多数以失败告终。基因治疗成功的案例吸引大量资源和资金的注入，使得更多研究得以展开，但是更多的失败案例则让基因治疗转入低谷。在不断起伏中，“基因编辑”的技术储备逐渐完成。</p>
<p>基因编辑的“三件套”为：</p>
<ol>
<li>基因组GPS：锌手指蛋白组合</li>
<li>基因组剪刀：FokⅠ蛋白的剪切模块</li>
<li>基因组针线：细胞内天然存在的两套DNA断点修复机制</li>
</ol>
<p>2011和2012年的“神话”蛋白和CRISPR蛋白的相继发现把人类正式带入了基因的“完整可编程”时代。</p>
<p>目前，基因编辑技术的可以的应用阶段可以简单总结为“来自人体-体外处理-体内治疗”，这样的好处在于安全性，避免外源基因给人来带来危害；未来，为了治疗更广泛的疾病，基因编辑的第二阶段——“来自人体-体内处理-体内治疗”是自然而然的发展；为了实现基因治疗的普适性，降低治疗成本，基因编辑拜托“来自人体”的限制，医药企业将能够开发的大批量生产普适药物，让普通人也能够承担；在未来的未来，“体内预防”也或许能够被实现。关于基因编辑的前景，还有广阔的发展的想象空间。</p>
<p>在美好的发展前景后，基因技术也带来了争议、风险，伦理的讨论也无休无止。疾病的“预防”被实现后，那么“改善”也会随之而来，人类可以按自己的喜好来修改自己或者后代的特征。因为能负担基因改善的人总是少数，那么这是不是会加剧不平等、固话社会阶层？在极端情况下，人类甚至可以通过编辑基因来产生新的物种。那时候，人类自己会处于什么位置？这些问题人类只能随着技术的进步去一一应对。</p>
<p>书中对可以基础研究的价值表示了极大的肯定。在基因技术的发展过程中，出现了无数的柳暗花明，如 DNA 双螺旋结构的证明，到后来锌手指蛋白、“神话”蛋白、CRISPR蛋白的发现统统都是在生物领域的冷门基础研究中，“幸运”地被发现的。而这些幸运的发现总是让人感叹大自然的鬼斧神工。生物进化过程中，获得了一整套无比简洁而高效的机制，比如只使用3个碱基对应一个氨基酸，而绝不浪费额外的资源；基于编辑的“三件套”更是全部本来就存在于生物体内，人类所做的并不是重新设计，而是发现和推广。</p>
<p>作为一个程序员，我相信科技发展是不可逆的，它能够让人类社会想好的方向发展。现在，我们经历的每个瞬间都有可能被载入史册，无论是生物科技，还是人工智能，我们都应该用开放的心态拥抱他们，也用严格的监管管控它们，耐心期待技术的成熟，并为人所用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chuanlei Guo</p>
  <div class="site-description" itemprop="description">正因为未知，人与人之间的羁绊才愈发迷人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChuanleiGuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChuanleiGuo" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chuanleiguo@gmail.com" title="E-Mail → mailto:chuanleiguo@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/bestchuan" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;bestchuan" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chuanlei Guo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://chuanleiguo-com.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
